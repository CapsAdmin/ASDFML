local oh = ... or _G.oh

local code = [===============[
	a = b
	_1 = _2


local function test()
	local a = b
	lol = true
	adwawd = ad
	a,b,c = e,f,g
end


local a,b,c = 1,3+2^3,(3+2)^3


local a = a+i < b/2+1
local b = 5+x^2*8
local a = (1+2)+(3+4)




local a = a+i < b/2+1
local b = 5+x^2*8
local a =a < y and y <= z
local a =-x^2
local a =x^y^z
local a = 5+x^2*8
local a = x < y and x*x or y*y
local a = 1+2+3+4
local a = (1+2)+(3+4)
local a = (1+(2)+(3)+4)
local a = (1+(2+3)+4)

local a = 5+(1+2+3+4)

local b = function(a,b,c) local awd = awd*5 end


do
	local a = 1
	do
		local a = 2

		local function asdf()
			for i = 1, 10 do
				local i = i + 2
				if i < 5 then
					local a = 1
				elseif i > 5 then
					local a = 2
				elseif i > 1 then
					local a = 2
				else
					local a = 4
				end
			end


			local i = 0

			while (function(foo) local foo = foo + bar return foo end) or 1 do
				i = i + 1
				if i > 10 then

				end
			end
		end
	end
end

	foo.bar[1+2]["3"][four].five = 1
	a = 1
	b = 2
	foo.bar[1+2]["3"][four].waddwa(a,b,c + 2 + 1 + 22+2 +2)


	a.lol,b,c = 1,2,3
	lol:foo(awdadwwad, awdwadaw, adadw, 2+11+231+23+1+23)

	while true do
		local a = 1
		if true then a = 1 elseif true then b= 2 elseif true and false then c = 3 end
		local a = 2
		asad(adawd+123,21235,325,235,253)
	end
	if true then
		a = 1
	elseif true then
		b= 2
	elseif true and false then
		c = 3
	end


	a = 0b101010

	b = {1,2,3, foo = true, [asd] = true, lol = {1,2,3}}
	b.a = 1
	b.test = function() end

	function b:test()

	end


b.test = {1}

function b:test()
end

b["asdawd"].wad = function(a,b,c)
end


	b.A = {function() end,1,2,true,false,2+4+5}
	function b:B()
	end
	b.C = function() end
	function b:D()
	end
	b["E"].F= function(a,b,c) a = 1
	end

	local a = {a}
	b = 1

local function test(a)
	return 1+2+a*b+d/c
end

if 1+2 > 3 then
	a = 4
elseif false and 32 then
	a = 23
elseif true and asd then
	a = 7
else
	a = 10
end

if 1+5 then
	asdawd = true
else
	asdawd = true
end

if 1203 then
	asdawd = true
end

while true do

end

for _ = 1, 10 do
	print(i  + 4)
end

	foo.bar[1+2]["3"][four].five = 1
	foo.bar[1+2]["3"][four].waddwa:waawd(a,b,c + 2 + 1 + 22+2 +2)
	a.b,c.d,e,f = lol(), asdf(), asas(),1
	a,b,c,d = 1,2,3,4

	foo.bar[1+2]["3"][four].waddwa:waawd(a + function() end, b, c + 2 + 1 + 22+2 +2)

	local a = function(a,b,c) end + 1 + aawd.awdawd(1,2,3) * 1 ^ -2

	local a = 2+1<1/aawd.aw:dw(1,2,3)+1
	local b = 2+1<1/2+1

	local a =a < y and y <= z

	local a =a < y and y <= z
	local a =-x^2

	local a,b,c = 1,2,3
	local a = a+1*2*2,2


	local function test()
		local a = b
		lol = true
		return a+1
	end

	local a = 1
	local b = function() end + 1
	function lol()

	end

	local a = b
	c,d = d
	local a, b = 1, 2, function() end + 1
	local function asdf()
		a, b = 2, 3
		local lol = 2
		for i = 1, 10 do

		end
	end

	local foo = A < B or C > D
	b = a
	b = true

	foo.bar[1+2]["3"][four].five = 1

	b = {1,2,3, foo = true, [asd] = true, lol = {1,2,3}}

	b = {a = 1, [asd] = true, a = 1, b = {a = 1, [asd] = true, a = 1}}

	x={ 1 }
	x[2] = x
	x[x] = 3
	x[3]={ 'indirect recursion', [x]=x }
	y = { x, x }

	x.y = y
	assert (y[1] == y[2])

	s = serialize (x)
	z = loadstring (s)()
	assert (z.y[1] == z.y[2])
	local _={ }

	_[1]={ "indirect recursion" }

	_[2]={ false, false }
	_[3]={ 1, false, _[1], ["y"] = _[2] }
	_[3][2] = _[3]

	_[1][_[3]] = _[3]
	_[3][_[3]] = 3

	_[2][1] = _[3]
	_[2][2] = _[3]


	x={ 1 }
	x[2] = x
	x[x] = 3
	x[3]={ 'indirect recursion', [x]=x }
	y = { x, x }
	x.y = y
	assert (y[1] == y[2])
	s = serialize (x)
	z = loadstring (s)()

	assert (z.y[1] == z.y[2])
	local _={ }
	_[1]={ "indirect recursion" }
	_[2]={ false, false }
	_[3]={ 1, false, _[1], ["y"] = _[2] }
	_[3][2] = _[3]
	_[1][_[3]] = _[3]
	_[3][_[3]] = 3
	_[2][1] = _[3]
	_[2][2] = _[3]


	z = loadstring(1)(2)(3)(4)(5)

	local _={ }


	z = loadstring
	assert(z.y[1] == z.y[2])
	z = loadstring(1)(2)(3)(4)(5)

	lol[3]={
	1,
	false,
	_[1],
	["y"] = _[2]
	}

	assert (z.y[1] == z.y[2])
	local _={ }
	_[1]={ "indirect recursion" }
	_[2]={ false, false }
	_[3]={ 1, false, _[1], ["y"] = _[2] }
	_[3][2] = _[3]
	_[1][_[3]] = _[3]
	_[3][_[3]] = 3
	_[2][1] = _[3]
	_[2][2] = _[3]


	z = loadstring(1)(2)(3)(4)(5)

	local _={ }


	z = loadstring
	assert(z.y[1] == z.y[2])
	z = loadstring(1)(2)(3)(4)(5)


			z = loadstring(1)(2)(3)(4)(5)

	local _={ }


	z = loadstring
	assert(z.y[1] == z.y[2])
	z = loadstring(1)(2)(3)(4)(5)

	foo.bar[1+2]["3"][four].five = 1
	x={ 1 }

		do -- numbers
			for i = 0, 9 do
				char_types[tostring(i)] = "number"
			end
		end

		do -- letters
			char_types["_"] = "letter"

			for i = string.byte("A"), string.byte("z") do
				char_types[string.char(i)] = "letter"
			end
		end

test().awd:lol().lol:w().awdawdwa["awdwad"].awdwadawd.wadwda()

		test(1)(2)(3).awd:lol().lol:w().awdawdwa["awdwad"].awdwadawd.wadwda = true+1
		test(1)(2)(3).awd:lol().lol:w().awdawdwa["awdwad"].awdwadawd.wadwda = function() FOO() end
		test(1)(2)(3).awd:lol().lol:w().awdawdwa()
	_1() _2() someFunction = function() Inside() end Outside()

	z = loadstring
	assert(z.y[1] == z.y[2])
	z = loadstring(1)(2)(3)(4)(5)

	foo.bar[1+2]["3"][four].five = 1
	x={ 1 }

		do -- numbers
			for i = 0, 9 do
				char_types[tostring(i)] = "number"
			end
		end

	do -- letters
		char_types["_"] = "letter"

		for i = string.byte("A"), string.byte("z") do
			char_types[string.char(i)] = "letter"
		end
	end

	test().awd:lol().lol:w().awdawdwa["awdwad"].awdwadawd.wadwda()

		test(1)(2)(3).awd:lol().lol:w().awdawdwa["awdwad"].awdwadawd.wadwda = true+1
		test(1)(2)(3).awd:lol().lol:w().awdawdwa["awdwad"].awdwadawd.wadwda = function() FOO() end
		test(1)(2)(3).awd:lol().lol:w().awdawdwa()
	_1() _2() someFunction = function() Inside() end Outside()


]===============]


codex = vfs.Read("/home/caps/goluwa/game/lua/libraries/oh/test.lua")

codex = [[
	--("vec4"):format(1,2,3)
	(1 + 2)
	("test")
]]

codex = [[

function test(a or 1, b or 2)
	return a + 3
end
]]

function oh.TestLuajitLangToolkit(code)
	local ls = require("lang.lexer")(require("lang.reader").string(code), code)
	local parse = require('lang.parser')
	local lua_ast = require('lang.lua-ast')
	local ast_builder = lua_ast.New()
	local parse_success, ast_tree = pcall(parse, ast_builder, ls)

	for _, data in ipairs(ast_tree.body) do
		log("local ")
		for i, v in ipairs(data.names) do
			log(v.name)
			if i ~= #data.names then
				log(", ")
			end
		end
		log(" = ")
		for i, v in ipairs(data.expressions) do
			if v.kind == "BinaryExpression" then
				local function dump(v)
					local lol = false
					if v.left then
						log("(")
						dump(v.left)
					end
					if lol then
						log(",")
					else
						log(v.value or v.operator or v.name)
					end
					if v.right then
						dump(v.right)
						log(")")
					end
				end
				dump(v)
			else
				log(v.value)
			end

			if i ~= #data.expressions then
				log(", ")
			end
		end
		logn()
	end
end

function oh.CompileCode(code, path)
	local tokens = oh.Tokenize(code)

	--tokens:Dump()

	local str = oh.DumpAST(tokens:ReadBody())
	--print("result:")
	--print(str:trim():indent(1))

	local func, err = loadstring(str, path)

	if not func then
		local line = tonumber(err:match("%b[]:(%d+):"))
		local lines = str:split("\n")
		for i = -1, 1 do
			if lines[line + i] then
				err = err .. "\t" .. lines[line + i]
				if i == 0 then
					err = err .. " --<<< "
				end
				err = err .. "\n"
			end
		end

		return nil, err
	end

	return func, err
end

function oh.Test()
	RELOAD = nil
	_G.oh = runfile("/home/caps/goluwa/game/lua/libraries/oh/oh.lua")

	code = [[[
		if (type(val) == "function" and not val(out[key])) or out[key] ~= val then

		end
	]]

	_G.oh.CompileCode(code)

	do return end
	for path, v in pairs(vfs.GetLoadedLuaFiles()) do
		assert(_G.oh.CompileCode(vfs.Read(path), path))
	end
end

commands.Add("tokenize=arg_line", function(str)
	oh.Tokenize(str):Dump()
end)

commands.Add("lex=arg_line", function(str)
	oh.CompileCode(str)
end)

if RELOAD then
	oh.Test()
end