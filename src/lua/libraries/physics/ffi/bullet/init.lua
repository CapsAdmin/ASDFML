ffi.cdef([[
typedef void* HACD_Vec3_long; //declaration specifier expected near 'HACD_Vec3_long' at line 4228
typedef void* HACD_Vec3_Real; //declaration specifier expected near 'HACD_Vec3_Real' at line 4227
typedef void* HACD_CallBackFunction; //declaration specifier expected near 'HACD_CallBackFunction' at line 4225
typedef void* HACD_HACD; //declaration specifier expected near 'HACD_HACD' at line 4216
typedef void* btSoftBodyNodePtrArray; //declaration specifier expected near 'btSoftBodyNodePtrArray' at line 4204
typedef void* btStridingMeshInterfaceData; //declaration specifier expected near 'btStridingMeshInterfaceData' at line 4169
typedef void* btWorldImporter; //declaration specifier expected near 'btWorldImporter' at line 4140
typedef void* btWheelInfo_RaycastInfo; //declaration specifier expected near 'btWheelInfo_RaycastInfo' at line 4068
typedef void* btWheelInfoConstructionInfo; //declaration specifier expected near 'btWheelInfoConstructionInfo' at line 4041
typedef void* btSubSimplexClosestResult; //declaration specifier expected near 'btSubSimplexClosestResult' at line 3984
typedef void* btUsageBitfield; //declaration specifier expected near 'btUsageBitfield' at line 3964
typedef void* btVehicleRaycaster_btVehicleRaycasterResult; //declaration specifier expected near 'btVehicleRaycaster_btVehicleRaycasterResult' at line 3953
typedef void* btUniversalConstraint; //declaration specifier expected near 'btUniversalConstraint' at line 3943
typedef void* btElement; //declaration specifier expected near 'btElement' at line 3924
typedef void* btUniformScalingShape; //declaration specifier expected near 'btUniformScalingShape' at line 3920
typedef void* btAngularLimit; //declaration specifier expected near 'btAngularLimit' at line 3901
typedef void* btSolverBody; //declaration specifier expected near 'btSolverBody' at line 3898
typedef void* btConstraintArray; //declaration specifier expected near 'btConstraintArray' at line 3893
typedef void* btTypedConstraintType; //declaration specifier expected near 'btTypedConstraintType' at line 3865
typedef void* btJointFeedback; //declaration specifier expected near 'btJointFeedback' at line 3813
typedef void* btTriangleShape; //declaration specifier expected near 'btTriangleShape' at line 3806
typedef void* btTriangleMesh; //declaration specifier expected near 'btTriangleMesh' at line 3793
typedef void* btTriangleMeshShape; //declaration specifier expected near 'btTriangleMeshShape' at line 3786
typedef void* btTriangleInfoMapData; //declaration specifier expected near 'btTriangleInfoMapData' at line 3771
typedef void* btTriangleInfo; //declaration specifier expected near 'btTriangleInfo' at line 3758
typedef void* btTriangleIndexVertexMaterialArray; //declaration specifier expected near 'btTriangleIndexVertexMaterialArray' at line 3749
typedef void* btMaterialProperties; //declaration specifier expected near 'btMaterialProperties' at line 3730
typedef void* IndexedMeshArray; //declaration specifier expected near 'IndexedMeshArray' at line 3728
typedef void* pInternalTriangleIndexCallback_InternalProcessTriangleIndex; //declaration specifier expected near 'pInternalTriangleIndexCallback_InternalProcessTriangleIndex' at line 3703
typedef void* btInternalTriangleIndexCallbackWrapper; //declaration specifier expected near 'btInternalTriangleIndexCallbackWrapper' at line 3702
typedef void* pTriangleCallback_ProcessTriangle; //declaration specifier expected near 'pTriangleCallback_ProcessTriangle' at line 3699
typedef void* btTriangleCallbackWrapper; //declaration specifier expected near 'btTriangleCallbackWrapper' at line 3698
typedef void* btTriangleBuffer; //declaration specifier expected near 'btTriangleBuffer' at line 3693
typedef void* btTriangle; //declaration specifier expected near 'btTriangle' at line 3680
typedef void* btConvexSeparatingDistanceUtil; //declaration specifier expected near 'btConvexSeparatingDistanceUtil' at line 3674
typedef void* btBU_Simplex1to4; //declaration specifier expected near 'btBU_Simplex1to4' at line 3660
typedef void* btInternalTriangleIndexCallback; //declaration specifier expected near 'btInternalTriangleIndexCallback' at line 3650
typedef void* btSphereTriangleCollisionAlgorithm; //declaration specifier expected near 'btSphereTriangleCollisionAlgorithm' at line 3634
typedef void* btSphereTriangleCollisionAlgorithm_CreateFunc; //declaration specifier expected near 'btSphereTriangleCollisionAlgorithm_CreateFunc' at line 3632
typedef void* btSphereSphereCollisionAlgorithm; //declaration specifier expected near 'btSphereSphereCollisionAlgorithm' at line 3629
typedef void* btSphereSphereCollisionAlgorithm_CreateFunc; //declaration specifier expected near 'btSphereSphereCollisionAlgorithm_CreateFunc' at line 3627
typedef void* btSphereShape; //declaration specifier expected near 'btSphereShape' at line 3623
typedef void* btSphereBoxCollisionAlgorithm; //declaration specifier expected near 'btSphereBoxCollisionAlgorithm' at line 3619
typedef void* btSphereBoxCollisionAlgorithm_CreateFunc; //declaration specifier expected near 'btSphereBoxCollisionAlgorithm_CreateFunc' at line 3617
typedef void* btSoftSoftCollisionAlgorithm; //declaration specifier expected near 'btSoftSoftCollisionAlgorithm' at line 3605
typedef void* btSoftSoftCollisionAlgorithm_CreateFunc; //declaration specifier expected near 'btSoftSoftCollisionAlgorithm_CreateFunc' at line 3603
typedef void* btSoftBodyArray; //declaration specifier expected near 'btSoftBodyArray' at line 3598
typedef void* btSoftRigidDynamicsWorld; //declaration specifier expected near 'btSoftRigidDynamicsWorld' at line 3591
typedef void* btSoftRigidCollisionAlgorithm; //declaration specifier expected near 'btSoftRigidCollisionAlgorithm' at line 3589
typedef void* btSoftRigidCollisionAlgorithm_CreateFunc; //declaration specifier expected near 'btSoftRigidCollisionAlgorithm_CreateFunc' at line 3587
typedef void* btSoftBody_eSolverPresets; //declaration specifier expected near 'btSoftBody_eSolverPresets' at line 3550
typedef void* btSoftBody_eVSolver; //declaration specifier expected near 'btSoftBody_eVSolver' at line 3510
typedef void* btSoftBody_vsolver_t; //declaration specifier expected near 'btSoftBody_vsolver_t' at line 3509
typedef void* btSoftBody_ePSolver; //declaration specifier expected near 'btSoftBody_ePSolver' at line 3507
typedef void* btSoftBody_psolver_t; //declaration specifier expected near 'btSoftBody_psolver_t' at line 3506
typedef void* btAlignedSoftBodySContactArray; //declaration specifier expected near 'btAlignedSoftBodySContactArray' at line 3503
typedef void* btAlignedSoftBodyRContactArray; //declaration specifier expected near 'btAlignedSoftBodyRContactArray' at line 3500
typedef void* btAlignedSoftBodyNoteArray; //declaration specifier expected near 'btAlignedSoftBodyNoteArray' at line 3497
typedef void* btAlignedConstCollisionObjectArray; //declaration specifier expected near 'btAlignedConstCollisionObjectArray' at line 3486
typedef void* btAlignedBoolArray; //declaration specifier expected near 'btAlignedBoolArray' at line 3483
typedef void* btAlignedSoftBodyAnchorArray; //declaration specifier expected near 'btAlignedSoftBodyAnchorArray' at line 3477
typedef void* btSoftBody_eFeature; //declaration specifier expected near 'btSoftBody_eFeature' at line 3378
typedef void* btSoftBody_sRayCast; //declaration specifier expected near 'btSoftBody_sRayCast' at line 3375
typedef void* btSoftBody_SolverState; //declaration specifier expected near 'btSoftBody_SolverState' at line 3362
typedef void* btSoftBody_sMedium; //declaration specifier expected near 'btSoftBody_sMedium' at line 3353
typedef void* btSoftBody_SContact; //declaration specifier expected near 'btSoftBody_SContact' at line 3329
typedef void* btSoftBody_sCti; //declaration specifier expected near 'btSoftBody_sCti' at line 3319
typedef void* btSoftBody_RContact; //declaration specifier expected near 'btSoftBody_RContact' at line 3312
typedef void* btSoftBody_RayFromToCaster; //declaration specifier expected near 'btSoftBody_RayFromToCaster' at line 3296
typedef void* btSoftBody_Pose; //declaration specifier expected near 'btSoftBody_Pose' at line 3277
typedef void* btSoftBody_Note; //declaration specifier expected near 'btSoftBody_Note' at line 3267
typedef void* btSoftBody_LJoint; //declaration specifier expected near 'btSoftBody_LJoint' at line 3236
typedef void* btSoftBody_LJoint_Specs; //declaration specifier expected near 'btSoftBody_LJoint_Specs' at line 3232
typedef void* btSoftBody_Joint_eType; //declaration specifier expected near 'btSoftBody_Joint_eType' at line 3214
typedef void* btSoftBody_Joint_Specs; //declaration specifier expected near 'btSoftBody_Joint_Specs' at line 3186
typedef void* pImplicitFn_Eval; //declaration specifier expected near 'pImplicitFn_Eval' at line 3170
typedef void* btSoftBody_ImplicitFn; //declaration specifier expected near 'btSoftBody_ImplicitFn' at line 3169
typedef void* btSoftBody_Feature; //declaration specifier expected near 'btSoftBody_Feature' at line 3165
typedef void* btSoftBody_Element; //declaration specifier expected near 'btSoftBody_Element' at line 3152
typedef void* btAlignedSoftBodyVSolverArray; //declaration specifier expected near 'btAlignedSoftBodyVSolverArray' at line 3123
typedef void* btAlignedSoftBodyPSolverArray; //declaration specifier expected near 'btAlignedSoftBodyPSolverArray' at line 3098
typedef void* btSoftBody_eAeroModel; //declaration specifier expected near 'btSoftBody_eAeroModel' at line 3093
typedef void* btSoftBody_Config; //declaration specifier expected near 'btSoftBody_Config' at line 3091
typedef void* btAlignedSoftBodyNodePtrArray; //declaration specifier expected near 'btAlignedSoftBodyNodePtrArray' at line 3064
typedef void* btSoftBody_CJoint; //declaration specifier expected near 'btSoftBody_CJoint' at line 3031
typedef void* btSoftBody_Impulse; //declaration specifier expected near 'btSoftBody_Impulse' at line 3011
typedef void* btSoftBody_Body; //declaration specifier expected near 'btSoftBody_Body' at line 3004
typedef void* btSoftBody_Anchor; //declaration specifier expected near 'btSoftBody_Anchor' at line 2987
typedef void* btSoftBody_AJoint_Specs; //declaration specifier expected near 'btSoftBody_AJoint_Specs' at line 2977
typedef void* btSoftBody_AJoint; //declaration specifier expected near 'btSoftBody_AJoint' at line 2973
typedef void* btSoftBody_AJoint_IControlWrapper; //declaration specifier expected near 'btSoftBody_AJoint_IControlWrapper' at line 2968
typedef void* pIControl_Speed; //declaration specifier expected near 'pIControl_Speed' at line 2966
typedef void* pIControl_Prepare; //declaration specifier expected near 'pIControl_Prepare' at line 2965
typedef void* btSoftBody_AJoint_IControl; //declaration specifier expected near 'btSoftBody_AJoint_IControl' at line 2964
typedef void* btSparseSdf3; //declaration specifier expected near 'btSparseSdf3' at line 2950
typedef void* btSoftBodySolverOutput; //declaration specifier expected near 'btSoftBodySolverOutput' at line 2941
typedef void* btAlignedObjectArray; //declaration specifier expected near 'btAlignedObjectArray' at line 2930
typedef void* SolverTypes; //declaration specifier expected near 'SolverTypes' at line 2927
typedef void* btSoftBodySolver; //declaration specifier expected near 'btSoftBodySolver' at line 2921
typedef void* btSoftBodyRigidBodyCollisionConfiguration; //declaration specifier expected near 'btSoftBodyRigidBodyCollisionConfiguration' at line 2918
typedef void* btSoftBodyWorldInfo; //declaration specifier expected near 'btSoftBodyWorldInfo' at line 2893
typedef void* btSoftBodyConcaveCollisionAlgorithm; //declaration specifier expected near 'btSoftBodyConcaveCollisionAlgorithm' at line 2889
typedef void* btSoftBodyConcaveCollisionAlgorithm_SwappedCreateFunc; //declaration specifier expected near 'btSoftBodyConcaveCollisionAlgorithm_SwappedCreateFunc' at line 2887
typedef void* btSoftBodyConcaveCollisionAlgorithm_CreateFunc; //declaration specifier expected near 'btSoftBodyConcaveCollisionAlgorithm_CreateFunc' at line 2885
typedef void* btSoftBodyTriangleCallback; //declaration specifier expected near 'btSoftBodyTriangleCallback' at line 2877
typedef void* btTriIndex; //declaration specifier expected near 'btTriIndex' at line 2867
typedef void* btSliderConstraint; //declaration specifier expected near 'btSliderConstraint' at line 2787
typedef void* btUnionFind; //declaration specifier expected near 'btUnionFind' at line 2780
typedef void* btSimulationIslandManager_IslandCallback; //declaration specifier expected near 'btSimulationIslandManager_IslandCallback' at line 2773
typedef void* btShapeHull; //declaration specifier expected near 'btShapeHull' at line 2764
typedef void* btDefaultSerializer; //declaration specifier expected near 'btDefaultSerializer' at line 2759
typedef void* btChunk; //declaration specifier expected near 'btChunk' at line 2745
typedef void* btSequentialImpulseConstraintSolver; //declaration specifier expected near 'btSequentialImpulseConstraintSolver' at line 2739
typedef void* btScaledBvhTriangleMeshShape; //declaration specifier expected near 'btScaledBvhTriangleMeshShape' at line 2736
typedef void* btRigidBody_btRigidBodyConstructionInfo; //declaration specifier expected near 'btRigidBody_btRigidBodyConstructionInfo' at line 2626
typedef void* btDefaultVehicleRaycaster; //declaration specifier expected near 'btDefaultVehicleRaycaster' at line 2624
typedef void* btAlignedWheelInfoArray; //declaration specifier expected near 'btAlignedWheelInfoArray' at line 2606
typedef void* btWheelInfo; //declaration specifier expected near 'btWheelInfo' at line 2591
typedef void* btVehicleRaycaster; //declaration specifier expected near 'btVehicleRaycaster' at line 2589
typedef void* btRaycastVehicle; //declaration specifier expected near 'btRaycastVehicle' at line 2588
typedef void* btRaycastVehicle_btVehicleTuning; //declaration specifier expected near 'btRaycastVehicle_btVehicleTuning' at line 2573
typedef void* btQuantizedBvh_btTraversalMode; //declaration specifier expected near 'btQuantizedBvh_btTraversalMode' at line 2569
typedef void* BvhSubtreeInfoArray; //declaration specifier expected near 'BvhSubtreeInfoArray' at line 2557
typedef void* QuantizedNodeArray; //declaration specifier expected near 'QuantizedNodeArray' at line 2554
typedef void* btQuantizedBvhFloatData; //declaration specifier expected near 'btQuantizedBvhFloatData' at line 2550
typedef void* btQuantizedBvhDoubleData; //declaration specifier expected near 'btQuantizedBvhDoubleData' at line 2548
typedef void* btQuantizedBvh; //declaration specifier expected near 'btQuantizedBvh' at line 2543
typedef void* btNodeOverlapCallback; //declaration specifier expected near 'btNodeOverlapCallback' at line 2540
typedef void* btOptimizedBvhNode; //declaration specifier expected near 'btOptimizedBvhNode' at line 2526
typedef void* btQuantizedBvhNode; //declaration specifier expected near 'btQuantizedBvhNode' at line 2515
typedef void* btPolyhedralConvexAabbCachingShape; //declaration specifier expected near 'btPolyhedralConvexAabbCachingShape' at line 2512
typedef void* btPolyhedralConvexShape; //declaration specifier expected near 'btPolyhedralConvexShape' at line 2501
typedef void* btPolarDecomposition; //declaration specifier expected near 'btPolarDecomposition' at line 2494
typedef void* btPointCollector; //declaration specifier expected near 'btPointCollector' at line 2484
typedef void* btPoint2PointConstraint; //declaration specifier expected near 'btPoint2PointConstraint' at line 2471
typedef void* btConstraintSetting; //declaration specifier expected near 'btConstraintSetting' at line 2462
typedef void* btNullPairCache; //declaration specifier expected near 'btNullPairCache' at line 2429
typedef void* btSortedOverlappingPairCache; //declaration specifier expected near 'btSortedOverlappingPairCache' at line 2425
typedef void* btOverlapFilterCallback; //declaration specifier expected near 'btOverlapFilterCallback' at line 2407
typedef void* btNNCGConstraintSolver; //declaration specifier expected near 'btNNCGConstraintSolver' at line 2394
typedef void* btMaterial; //declaration specifier expected near 'btMaterial' at line 2392
typedef void* btMultimaterialTriangleMeshShape; //declaration specifier expected near 'btMultimaterialTriangleMeshShape' at line 2387
typedef void* btPositionAndRadius; //declaration specifier expected near 'btPositionAndRadius' at line 2380
typedef void* btMultiSphereShape; //declaration specifier expected near 'btMultiSphereShape' at line 2374
typedef void* btAlignedMatrix3x3Array; //declaration specifier expected near 'btAlignedMatrix3x3Array' at line 2282
typedef void* btMultiBodySolverConstraint; //declaration specifier expected near 'btMultiBodySolverConstraint' at line 2204
typedef void* btMultiBodyPoint2Point; //declaration specifier expected near 'btMultiBodyPoint2Point' at line 2199
typedef void* eFeatherstoneJointType; //declaration specifier expected near 'eFeatherstoneJointType' at line 2166
typedef void* btSpatialMotionVector; //declaration specifier expected near 'btSpatialMotionVector' at line 2146
typedef void* btMultibodyLink; //declaration specifier expected near 'btMultibodyLink' at line 2144
typedef void* btMultiBodyLinkCollider; //declaration specifier expected near 'btMultiBodyLinkCollider' at line 2137
typedef void* btMultiBodyJointMotor; //declaration specifier expected near 'btMultiBodyJointMotor' at line 2133
typedef void* btMultiBodyJointLimitConstraint; //declaration specifier expected near 'btMultiBodyJointLimitConstraint' at line 2131
typedef void* btMultiBodyDynamicsWorld; //declaration specifier expected near 'btMultiBodyDynamicsWorld' at line 2121
typedef void* btMultiBody; //declaration specifier expected near 'btMultiBody' at line 2110
typedef void* btMultiBodyJacobianData; //declaration specifier expected near 'btMultiBodyJacobianData' at line 2104
typedef void* btMultiBodyConstraintArray; //declaration specifier expected near 'btMultiBodyConstraintArray' at line 2103
typedef void* btMultiBodyConstraint; //declaration specifier expected near 'btMultiBodyConstraint' at line 2101
typedef void* btMultiBodyConstraintSolver; //declaration specifier expected near 'btMultiBodyConstraintSolver' at line 2098
typedef void* btMotionState; //declaration specifier expected near 'btMotionState' at line 2094
typedef void* pMotionState_SetWorldTransform; //declaration specifier expected near 'pMotionState_SetWorldTransform' at line 2092
typedef void* pMotionState_GetWorldTransform; //declaration specifier expected near 'pMotionState_GetWorldTransform' at line 2091
typedef void* btMotionStateWrapper; //declaration specifier expected near 'btMotionStateWrapper' at line 2090
typedef void* btMinkowskiSumShape; //declaration specifier expected near 'btMinkowskiSumShape' at line 2082
typedef void* btMinkowskiPenetrationDepthSolver; //declaration specifier expected near 'btMinkowskiPenetrationDepthSolver' at line 2080
typedef void* ContactAddedCallback; //declaration specifier expected near 'ContactAddedCallback' at line 2064
typedef void* btConstraintRow; //declaration specifier expected near 'btConstraintRow' at line 1994
typedef void* btMLCPSolver; //declaration specifier expected near 'btMLCPSolver' at line 1987
typedef void* btVectorXf; //declaration specifier expected near 'btVectorXf' at line 1983
typedef void* btMatrixXf; //declaration specifier expected near 'btMatrixXf' at line 1982
typedef void* btMLCPSolverInterface; //declaration specifier expected near 'btMLCPSolverInterface' at line 1981
typedef void* btLemkeSolver; //declaration specifier expected near 'btLemkeSolver' at line 1971
typedef void* btKinematicCharacterController; //declaration specifier expected near 'btKinematicCharacterController' at line 1958
typedef void* btIDebugDrawWrapper; //declaration specifier expected near 'btIDebugDrawWrapper' at line 1955
typedef void* btHingeAccumulatedAngleConstraint; //declaration specifier expected near 'btHingeAccumulatedAngleConstraint' at line 1944
typedef void* btHingeConstraint; //declaration specifier expected near 'btHingeConstraint' at line 1900
typedef void* btHinge2Constraint; //declaration specifier expected near 'btHinge2Constraint' at line 1890
typedef void* btHeightfieldTerrainShape; //declaration specifier expected near 'btHeightfieldTerrainShape' at line 1883
typedef void* btGjkPairDetector; //declaration specifier expected near 'btGjkPairDetector' at line 1862
typedef void* btGjkEpaPenetrationDepthSolver; //declaration specifier expected near 'btGjkEpaPenetrationDepthSolver' at line 1860
typedef void* btGjkConvexCast; //declaration specifier expected near 'btGjkConvexCast' at line 1858
typedef void* btGhostPairCallback; //declaration specifier expected near 'btGhostPairCallback' at line 1856
typedef void* btHashedOverlappingPairCache; //declaration specifier expected near 'btHashedOverlappingPairCache' at line 1854
typedef void* btPairCachingGhostObject; //declaration specifier expected near 'btPairCachingGhostObject' at line 1852
typedef void* btGhostObject; //declaration specifier expected near 'btGhostObject' at line 1839
typedef void* btGeneric6DofSpringConstraint; //declaration specifier expected near 'btGeneric6DofSpringConstraint' at line 1825
typedef void* RotateOrder; //declaration specifier expected near 'RotateOrder' at line 1779
typedef void* btGeneric6DofSpring2Constraint; //declaration specifier expected near 'btGeneric6DofSpring2Constraint' at line 1777
typedef void* btTranslationalLimitMotor2; //declaration specifier expected near 'btTranslationalLimitMotor2' at line 1735
typedef void* btRotationalLimitMotor2; //declaration specifier expected near 'btRotationalLimitMotor2' at line 1689
typedef void* btTranslationalLimitMotor; //declaration specifier expected near 'btTranslationalLimitMotor' at line 1617
typedef void* btRotationalLimitMotor; //declaration specifier expected near 'btRotationalLimitMotor' at line 1577
typedef void* btGearConstraint; //declaration specifier expected near 'btGearConstraint' at line 1568
typedef void* btGImpactMeshShapePart; //declaration specifier expected near 'btGImpactMeshShapePart' at line 1557
typedef void* PHY_ScalarType; //declaration specifier expected near 'PHY_ScalarType' at line 1530
typedef void* btGImpactMeshShapePart_TrimeshPrimitiveManager; //declaration specifier expected near 'btGImpactMeshShapePart_TrimeshPrimitiveManager' at line 1520
typedef void* btGImpactCompoundShape; //declaration specifier expected near 'btGImpactCompoundShape' at line 1510
typedef void* btGImpactCompoundShape_CompoundPrimitiveManager; //declaration specifier expected near 'btGImpactCompoundShape_CompoundPrimitiveManager' at line 1508
typedef void* eGIMPACT_SHAPE_TYPE; //declaration specifier expected near 'eGIMPACT_SHAPE_TYPE' at line 1492
typedef void* btTriangleShapeEx; //declaration specifier expected near 'btTriangleShapeEx' at line 1487
typedef void* btGImpactBoxSet; //declaration specifier expected near 'btGImpactBoxSet' at line 1484
typedef void* btTetrahedronShapeEx; //declaration specifier expected near 'btTetrahedronShapeEx' at line 1480
typedef void* btGImpactQuantizedBvh; //declaration specifier expected near 'btGImpactQuantizedBvh' at line 1454
typedef void* btQuantizedBvhTree; //declaration specifier expected near 'btQuantizedBvhTree' at line 1437
typedef void* GIM_QUANTIZED_BVH_NODE_ARRAY; //declaration specifier expected near 'GIM_QUANTIZED_BVH_NODE_ARRAY' at line 1435
typedef void* BT_QUANTIZED_BVH_NODE; //declaration specifier expected near 'BT_QUANTIZED_BVH_NODE' at line 1422
typedef void* btGImpactShapeInterface; //declaration specifier expected near 'btGImpactShapeInterface' at line 1411
typedef void* btGImpactCollisionAlgorithm; //declaration specifier expected near 'btGImpactCollisionAlgorithm' at line 1405
typedef void* btGImpactCollisionAlgorithm_CreateFunc; //declaration specifier expected near 'btGImpactCollisionAlgorithm_CreateFunc' at line 1403
typedef void* btGImpactBvh; //declaration specifier expected near 'btGImpactBvh' at line 1377
typedef void* btPrimitiveTriangle; //declaration specifier expected near 'btPrimitiveTriangle' at line 1373
typedef void* btPrimitiveManagerBase; //declaration specifier expected near 'btPrimitiveManagerBase' at line 1370
typedef void* btBvhTree; //declaration specifier expected near 'btBvhTree' at line 1355
typedef void* GIM_BVH_TREE_NODE_ARRAY; //declaration specifier expected near 'GIM_BVH_TREE_NODE_ARRAY' at line 1353
typedef void* GIM_BVH_DATA_ARRAY; //declaration specifier expected near 'GIM_BVH_DATA_ARRAY' at line 1351
typedef void* GIM_BVH_TREE_NODE; //declaration specifier expected near 'GIM_BVH_TREE_NODE' at line 1341
typedef void* GIM_BVH_DATA; //declaration specifier expected near 'GIM_BVH_DATA' at line 1334
typedef void* btPairSet; //declaration specifier expected near 'btPairSet' at line 1330
typedef void* GIM_PAIR; //declaration specifier expected near 'GIM_PAIR' at line 1321
typedef void* btFixedConstraint; //declaration specifier expected near 'btFixedConstraint' at line 1319
typedef void* btEmptyShape; //declaration specifier expected near 'btEmptyShape' at line 1317
typedef void* btEmptyAlgorithm; //declaration specifier expected near 'btEmptyAlgorithm' at line 1315
typedef void* btEmptyAlgorithm_CreateFunc; //declaration specifier expected near 'btEmptyAlgorithm_CreateFunc' at line 1313
typedef void* btInternalTickCallback; //declaration specifier expected near 'btInternalTickCallback' at line 1304
typedef void* btDynamicsWorldType; //declaration specifier expected near 'btDynamicsWorldType' at line 1296
typedef void* btSimulationIslandManager; //declaration specifier expected near 'btSimulationIslandManager' at line 1235
typedef void* btTypedConstraint; //declaration specifier expected near 'btTypedConstraint' at line 1230
typedef void* btDiscreteDynamicsWorld; //declaration specifier expected near 'btDiscreteDynamicsWorld' at line 1227
typedef void* btStorageResult; //declaration specifier expected near 'btStorageResult' at line 1219
typedef void* btDiscreteCollisionDetectorInterface; //declaration specifier expected near 'btDiscreteCollisionDetectorInterface' at line 1215
typedef void* btDiscreteCollisionDetectorInterface_Result; //declaration specifier expected near 'btDiscreteCollisionDetectorInterface_Result' at line 1210
typedef void* btDiscreteCollisionDetectorInterface_ClosestPointInput; //declaration specifier expected near 'btDiscreteCollisionDetectorInterface_ClosestPointInput' at line 1201
typedef void* btVertexBufferDescriptor; //declaration specifier expected near 'btVertexBufferDescriptor' at line 1199
typedef void* btDefaultSoftBodySolver; //declaration specifier expected near 'btDefaultSoftBodySolver' at line 1197
typedef void* btDefaultMotionState; //declaration specifier expected near 'btDefaultMotionState' at line 1185
typedef void* btDefaultCollisionConfiguration; //declaration specifier expected near 'btDefaultCollisionConfiguration' at line 1175
typedef void* btDefaultCollisionConstructionInfo; //declaration specifier expected near 'btDefaultCollisionConstructionInfo' at line 1160
typedef void* btAlignedStkNNArray; //declaration specifier expected near 'btAlignedStkNNArray' at line 1135
typedef void* btAlignedDbvtNodeArray; //declaration specifier expected near 'btAlignedDbvtNodeArray' at line 1127
typedef void* btAlignedStkNpsArray; //declaration specifier expected near 'btAlignedStkNpsArray' at line 1110
typedef void* btDbvt_sStkNPS; //declaration specifier expected near 'btDbvt_sStkNPS' at line 1099
typedef void* btDbvt_sStkNP; //declaration specifier expected near 'btDbvt_sStkNP' at line 1092
typedef void* btDbvt_sStkNN; //declaration specifier expected near 'btDbvt_sStkNN' at line 1084
typedef void* btDbvt_sStkCLN; //declaration specifier expected near 'btDbvt_sStkCLN' at line 1077
typedef void* btDbvt_IWriter; //declaration specifier expected near 'btDbvt_IWriter' at line 1072
typedef void* btDbvt_ICollide; //declaration specifier expected near 'btDbvt_ICollide' at line 1064
typedef void* btDbvt_IClone; //declaration specifier expected near 'btDbvt_IClone' at line 1060
typedef void* btDbvtVolume; //declaration specifier expected near 'btDbvtVolume' at line 1052
typedef void* btDbvtAabbMm; //declaration specifier expected near 'btDbvtAabbMm' at line 1027
typedef void* btDbvtBroadphase; //declaration specifier expected near 'btDbvtBroadphase' at line 981
typedef void* btDbvtProxy; //declaration specifier expected near 'btDbvtProxy' at line 974
typedef void* btDantzigSolver; //declaration specifier expected near 'btDantzigSolver' at line 972
typedef void* btCylinderShapeZ; //declaration specifier expected near 'btCylinderShapeZ' at line 969
typedef void* btCylinderShapeX; //declaration specifier expected near 'btCylinderShapeX' at line 966
typedef void* btCylinderShape; //declaration specifier expected near 'btCylinderShape' at line 959
typedef void* btConvexTriangleMeshShape; //declaration specifier expected near 'btConvexTriangleMeshShape' at line 954
typedef void* btAlignedFaceArray; //declaration specifier expected near 'btAlignedFaceArray' at line 926
typedef void* btConvexPolyhedron; //declaration specifier expected near 'btConvexPolyhedron' at line 923
typedef void* btAlignedIntArray; //declaration specifier expected near 'btAlignedIntArray' at line 919
typedef void* btFace; //declaration specifier expected near 'btFace' at line 917
typedef void* btConvexPointCloudShape; //declaration specifier expected near 'btConvexPointCloudShape' at line 907
typedef void* btConvexPlaneCollisionAlgorithm; //declaration specifier expected near 'btConvexPlaneCollisionAlgorithm' at line 904
typedef void* btConvexPlaneCollisionAlgorithm_CreateFunc; //declaration specifier expected near 'btConvexPlaneCollisionAlgorithm_CreateFunc' at line 898
typedef void* btConvexInternalAabbCachingShape; //declaration specifier expected near 'btConvexInternalAabbCachingShape' at line 893
typedef void* btConvexInternalShape; //declaration specifier expected near 'btConvexInternalShape' at line 883
typedef void* btConvexHullShape; //declaration specifier expected near 'btConvexHullShape' at line 871
typedef void* btConvexConvexAlgorithm; //declaration specifier expected near 'btConvexConvexAlgorithm' at line 867
typedef void* btConvexConvexAlgorithm_CreateFunc; //declaration specifier expected near 'btConvexConvexAlgorithm_CreateFunc' at line 857
typedef void* btConvexConcaveCollisionAlgorithm; //declaration specifier expected near 'btConvexConcaveCollisionAlgorithm' at line 854
typedef void* btConvexConcaveCollisionAlgorithm_SwappedCreateFunc; //declaration specifier expected near 'btConvexConcaveCollisionAlgorithm_SwappedCreateFunc' at line 852
typedef void* btConvexConcaveCollisionAlgorithm_CreateFunc; //declaration specifier expected near 'btConvexConcaveCollisionAlgorithm_CreateFunc' at line 850
typedef void* btConvexTriangleCallback; //declaration specifier expected near 'btConvexTriangleCallback' at line 839
typedef void* btConvexCast; //declaration specifier expected near 'btConvexCast' at line 836
typedef void* btConvexCast_CastResult; //declaration specifier expected near 'btConvexCast_CastResult' at line 816
typedef void* btConvex2dShape; //declaration specifier expected near 'btConvex2dShape' at line 813
typedef void* btConvex2dConvex2dAlgorithm; //declaration specifier expected near 'btConvex2dConvex2dAlgorithm' at line 809
typedef void* btConvex2dConvex2dAlgorithm_CreateFunc; //declaration specifier expected near 'btConvex2dConvex2dAlgorithm_CreateFunc' at line 799
typedef void* btStaticPlaneShape; //declaration specifier expected near 'btStaticPlaneShape' at line 797
typedef void* btConvexPenetrationDepthSolver; //declaration specifier expected near 'btConvexPenetrationDepthSolver' at line 795
typedef void* btVoronoiSimplexSolver; //declaration specifier expected near 'btVoronoiSimplexSolver' at line 794
typedef void* btContinuousConvexCollision; //declaration specifier expected near 'btContinuousConvexCollision' at line 793
typedef void* btContactSolverInfoData; //declaration specifier expected near 'btContactSolverInfoData' at line 747
typedef void* btContactConstraint; //declaration specifier expected near 'btContactConstraint' at line 744
typedef void* btConstraintSolverType; //declaration specifier expected near 'btConstraintSolverType' at line 739
typedef void* btContactSolverInfo; //declaration specifier expected near 'btContactSolverInfo' at line 737
typedef void* btConstraintSolver; //declaration specifier expected near 'btConstraintSolver' at line 736
typedef void* btTypedConstraint_btConstraintInfo2; //declaration specifier expected near 'btTypedConstraint_btConstraintInfo2' at line 711
typedef void* btTypedConstraint_btConstraintInfo1; //declaration specifier expected near 'btTypedConstraint_btConstraintInfo1' at line 709
typedef void* btConeTwistConstraint; //declaration specifier expected near 'btConeTwistConstraint' at line 698
typedef void* btConeShapeZ; //declaration specifier expected near 'btConeShapeZ' at line 696
typedef void* btConeShapeX; //declaration specifier expected near 'btConeShapeX' at line 694
typedef void* btConeShape; //declaration specifier expected near 'btConeShape' at line 688
typedef void* btConcaveShape; //declaration specifier expected near 'btConcaveShape' at line 686
typedef void* btDbvt; //declaration specifier expected near 'btDbvt' at line 677
typedef void* btDbvtNode; //declaration specifier expected near 'btDbvtNode' at line 660
typedef void* btCompoundShapeChild; //declaration specifier expected near 'btCompoundShapeChild' at line 655
typedef void* btGImpactMeshShape; //declaration specifier expected near 'btGImpactMeshShape' at line 653
typedef void* btCompoundShape; //declaration specifier expected near 'btCompoundShape' at line 652
typedef void* btCompoundCompoundCollisionAlgorithm; //declaration specifier expected near 'btCompoundCompoundCollisionAlgorithm' at line 650
typedef void* btCompoundCompoundCollisionAlgorithm_SwappedCreateFunc; //declaration specifier expected near 'btCompoundCompoundCollisionAlgorithm_SwappedCreateFunc' at line 648
typedef void* btCompoundCompoundCollisionAlgorithm_CreateFunc; //declaration specifier expected near 'btCompoundCompoundCollisionAlgorithm_CreateFunc' at line 646
typedef void* btCompoundCollisionAlgorithm; //declaration specifier expected near 'btCompoundCollisionAlgorithm' at line 643
typedef void* btCompoundCollisionAlgorithm_SwappedCreateFunc; //declaration specifier expected near 'btCompoundCollisionAlgorithm_SwappedCreateFunc' at line 641
typedef void* btCompoundCollisionAlgorithm_CreateFunc; //declaration specifier expected near 'btCompoundCollisionAlgorithm_CreateFunc' at line 639
typedef void* btCollisionObjectArray; //declaration specifier expected near 'btCollisionObjectArray' at line 617
typedef void* btConvexShape; //declaration specifier expected near 'btConvexShape' at line 611
typedef void* btCollisionWorld_RayResultCallback; //declaration specifier expected near 'btCollisionWorld_RayResultCallback' at line 589
typedef void* pRayResultCallback_NeedsCollision; //declaration specifier expected near 'pRayResultCallback_NeedsCollision' at line 586
typedef void* pRayResultCallback_AddSingleResult; //declaration specifier expected near 'pRayResultCallback_AddSingleResult' at line 585
typedef void* btCollisionWorld_RayResultCallbackWrapper; //declaration specifier expected near 'btCollisionWorld_RayResultCallbackWrapper' at line 584
typedef void* btCollisionWorld_LocalRayResult; //declaration specifier expected near 'btCollisionWorld_LocalRayResult' at line 567
typedef void* btCollisionWorld_LocalShapeInfo; //declaration specifier expected near 'btCollisionWorld_LocalShapeInfo' at line 554
typedef void* btCollisionWorld_LocalConvexResult; //declaration specifier expected near 'btCollisionWorld_LocalConvexResult' at line 543
typedef void* btCollisionWorld_ConvexResultCallback; //declaration specifier expected near 'btCollisionWorld_ConvexResultCallback' at line 542
typedef void* pConvexResultCallback_NeedsCollision; //declaration specifier expected near 'pConvexResultCallback_NeedsCollision' at line 539
typedef void* pConvexResultCallback_AddSingleResult; //declaration specifier expected near 'pConvexResultCallback_AddSingleResult' at line 538
typedef void* btCollisionWorld_ConvexResultCallbackWrapper; //declaration specifier expected near 'btCollisionWorld_ConvexResultCallbackWrapper' at line 537
typedef void* btManifoldPoint; //declaration specifier expected near 'btManifoldPoint' at line 529
typedef void* btCollisionWorld_ContactResultCallback; //declaration specifier expected near 'btCollisionWorld_ContactResultCallback' at line 528
typedef void* pContactResultCallback_NeedsCollision; //declaration specifier expected near 'pContactResultCallback_NeedsCollision' at line 525
typedef void* pContactResultCallback_AddSingleResult; //declaration specifier expected near 'pContactResultCallback_AddSingleResult' at line 524
typedef void* btCollisionWorld_ContactResultCallbackWrapper; //declaration specifier expected near 'btCollisionWorld_ContactResultCallbackWrapper' at line 523
typedef void* btCollisionWorld_ClosestRayResultCallback; //declaration specifier expected near 'btCollisionWorld_ClosestRayResultCallback' at line 513
typedef void* btCollisionWorld_ClosestConvexResultCallback; //declaration specifier expected near 'btCollisionWorld_ClosestConvexResultCallback' at line 501
typedef void* btAlignedVector3Array; //declaration specifier expected near 'btAlignedVector3Array' at line 494
typedef void* btAlignedScalarArray; //declaration specifier expected near 'btAlignedScalarArray' at line 492
typedef void* btCollisionWorld_AllHitsRayResultCallback; //declaration specifier expected near 'btCollisionWorld_AllHitsRayResultCallback' at line 489
typedef void* btCollisionShape; //declaration specifier expected near 'btCollisionShape' at line 383
typedef void* btNearCallback; //declaration specifier expected near 'btNearCallback' at line 376
typedef void* btCollisionDispatcher; //declaration specifier expected near 'btCollisionDispatcher' at line 371
typedef void* btPoolAllocator; //declaration specifier expected near 'btPoolAllocator' at line 362
typedef void* btCollisionConfiguration; //declaration specifier expected near 'btCollisionConfiguration' at line 360
typedef void* btCollisionAlgorithmCreateFunc; //declaration specifier expected near 'btCollisionAlgorithmCreateFunc' at line 359
typedef void* btManifoldResult; //declaration specifier expected near 'btManifoldResult' at line 354
typedef void* btDispatcherInfo; //declaration specifier expected near 'btDispatcherInfo' at line 353
typedef void* btCharacterControllerInterface; //declaration specifier expected near 'btCharacterControllerInterface' at line 335
typedef void* btCapsuleShapeZ; //declaration specifier expected near 'btCapsuleShapeZ' at line 333
typedef void* btCapsuleShapeX; //declaration specifier expected near 'btCapsuleShapeX' at line 331
typedef void* btCapsuleShape; //declaration specifier expected near 'btCapsuleShape' at line 326
typedef void* btSerializer; //declaration specifier expected near 'btSerializer' at line 319
typedef void* btTriangleCallback; //declaration specifier expected near 'btTriangleCallback' at line 315
typedef void* btTriangleInfoMap; //declaration specifier expected near 'btTriangleInfoMap' at line 312
typedef void* btOptimizedBvh; //declaration specifier expected near 'btOptimizedBvh' at line 309
typedef void* btStridingMeshInterface; //declaration specifier expected near 'btStridingMeshInterface' at line 303
typedef void* btBvhTriangleMeshShape; //declaration specifier expected near 'btBvhTriangleMeshShape' at line 302
typedef void* btBulletXmlWorldImporter; //declaration specifier expected near 'btBulletXmlWorldImporter' at line 299
typedef void* btDynamicsWorld; //declaration specifier expected near 'btDynamicsWorld' at line 292
typedef void* btBulletWorldImporter; //declaration specifier expected near 'btBulletWorldImporter' at line 290
typedef void* btAligendCharPtrArray; //declaration specifier expected near 'btAligendCharPtrArray' at line 283
typedef void* btAlignedStructHandleArray; //declaration specifier expected near 'btAlignedStructHandleArray' at line 278
typedef void* bParse_btBulletFile; //declaration specifier expected near 'bParse_btBulletFile' at line 273
typedef void* btCollisionAlgorithm; //declaration specifier expected near 'btCollisionAlgorithm' at line 265
typedef void* btBroadphaseInterface; //declaration specifier expected near 'btBroadphaseInterface' at line 220
typedef void* btBroadphaseRayCallback; //declaration specifier expected near 'btBroadphaseRayCallback' at line 214
typedef void* btBroadphaseRayCallbackWrapper; //declaration specifier expected near 'btBroadphaseRayCallbackWrapper' at line 212
typedef void* btBroadphaseAabbCallback; //declaration specifier expected near 'btBroadphaseAabbCallback' at line 209
typedef void* pBroadphaseAabbCallback_Process; //declaration specifier expected near 'pBroadphaseAabbCallback_Process' at line 207
typedef void* btBroadphaseAabbCallbackWrapper; //declaration specifier expected near 'btBroadphaseAabbCallbackWrapper' at line 206
typedef void* eBT_PLANE_INTERSECTION_TYPE; //declaration specifier expected near 'eBT_PLANE_INTERSECTION_TYPE' at line 194
typedef void* btAABB; //declaration specifier expected near 'btAABB' at line 171
typedef void* BT_BOX_BOX_TRANSFORM_CACHE; //declaration specifier expected near 'BT_BOX_BOX_TRANSFORM_CACHE' at line 158
typedef void* btBoxShape; //declaration specifier expected near 'btBoxShape' at line 152
typedef void* btBoxBoxDetector; //declaration specifier expected near 'btBoxBoxDetector' at line 151
typedef void* btBoxBoxCollisionAlgorithm; //declaration specifier expected near 'btBoxBoxCollisionAlgorithm' at line 148
typedef void* btBoxBoxCollisionAlgorithm_CreateFunc; //declaration specifier expected near 'btBoxBoxCollisionAlgorithm_CreateFunc' at line 146
typedef void* btVector3; //declaration specifier expected near 'btVector3' at line 141
typedef void* btBox2dShape; //declaration specifier expected near 'btBox2dShape' at line 134
typedef void* btCollisionObjectWrapper; //declaration specifier expected near 'btCollisionObjectWrapper' at line 132
typedef void* btCollisionAlgorithmConstructionInfo; //declaration specifier expected near 'btCollisionAlgorithmConstructionInfo' at line 130
typedef void* btBox2dBox2dCollisionAlgorithm; //declaration specifier expected near 'btBox2dBox2dCollisionAlgorithm' at line 129
typedef void* btBox2dBox2dCollisionAlgorithm_CreateFunc; //declaration specifier expected near 'btBox2dBox2dCollisionAlgorithm_CreateFunc' at line 127
typedef void* bt32BitAxisSweep3_Handle; //declaration specifier expected near 'bt32BitAxisSweep3_Handle' at line 116
typedef void* bt32BitAxisSweep3; //declaration specifier expected near 'bt32BitAxisSweep3' at line 110
typedef void* btBroadphaseProxy; //declaration specifier expected near 'btBroadphaseProxy' at line 106
typedef void* btOverlappingPairCallback; //declaration specifier expected near 'btOverlappingPairCallback' at line 100
typedef void* btOverlapCallback; //declaration specifier expected near 'btOverlapCallback' at line 98
typedef void* btAxisSweep3_Handle; //declaration specifier expected near 'btAxisSweep3_Handle' at line 96
typedef void* btDispatcher; //declaration specifier expected near 'btDispatcher' at line 94
typedef void* btOverlappingPairCache; //declaration specifier expected near 'btOverlappingPairCache' at line 91
typedef void* btAxisSweep3; //declaration specifier expected near 'btAxisSweep3' at line 88
typedef void* btAlignedSoftBodyTetraArray; //declaration specifier expected near 'btAlignedSoftBodyTetraArray' at line 83
typedef void* btSoftBody_Tetra; //declaration specifier expected near 'btSoftBody_Tetra' at line 82
typedef void* btAlignedSoftBodyNodeArray; //declaration specifier expected near 'btAlignedSoftBodyNodeArray' at line 76
typedef void* btSoftBody_Node; //declaration specifier expected near 'btSoftBody_Node' at line 75
typedef void* btAlignedSoftBodyMaterialArray; //declaration specifier expected near 'btAlignedSoftBodyMaterialArray' at line 70
typedef void* btSoftBody_Material; //declaration specifier expected near 'btSoftBody_Material' at line 69
typedef void* btAlignedSoftBodyLinkArray; //declaration specifier expected near 'btAlignedSoftBodyLinkArray' at line 63
typedef void* btSoftBody_Link; //declaration specifier expected near 'btSoftBody_Link' at line 62
typedef void* btAlignedSoftBodyJointArray; //declaration specifier expected near 'btAlignedSoftBodyJointArray' at line 57
typedef void* btSoftBody_Joint; //declaration specifier expected near 'btSoftBody_Joint' at line 56
typedef void* btAlignedSoftBodyFaceArray; //declaration specifier expected near 'btAlignedSoftBodyFaceArray' at line 51
typedef void* btSoftBody_Face; //declaration specifier expected near 'btSoftBody_Face' at line 50
typedef void* btAlignedSoftBodyClusterArray; //declaration specifier expected near 'btAlignedSoftBodyClusterArray' at line 45
typedef void* btSoftBody_Cluster; //declaration specifier expected near 'btSoftBody_Cluster' at line 44
typedef void* btAlignedSoftBodyArray; //declaration specifier expected near 'btAlignedSoftBodyArray' at line 39
typedef void* btSoftBody; //declaration specifier expected near 'btSoftBody' at line 38
typedef void* btPersistentManifold; //declaration specifier expected near 'btPersistentManifold' at line 32
typedef void* btAlignedManifoldArray; //declaration specifier expected near 'btAlignedManifoldArray' at line 30
typedef void* btAlignedIndexedMeshArray; //declaration specifier expected near 'btAlignedIndexedMeshArray' at line 25
typedef void* btIndexedMesh; //declaration specifier expected near 'btIndexedMesh' at line 24
typedef void* btAlignedCollisionObjectArray; //declaration specifier expected near 'btAlignedCollisionObjectArray' at line 19
typedef void* btCollisionObject; //declaration specifier expected near 'btCollisionObject' at line 18
typedef void* btAlignedBroadphasePairArray; //declaration specifier expected near 'btAlignedBroadphasePairArray' at line 13
typedef void* btBroadphasePair; //declaration specifier expected near 'btBroadphasePair' at line 12
typedef void* btCollisionWorld; //declaration specifier expected near 'btCollisionWorld' at line 9
typedef void* btIDebugDraw; //declaration specifier expected near 'btIDebugDraw' at line 7
typedef void* btActionInterface; //declaration specifier expected near 'btActionInterface' at line 6
typedef void* pIAction_UpdateAction; //declaration specifier expected near 'pIAction_UpdateAction' at line 4
typedef void* pIAction_DebugDraw; //declaration specifier expected near 'pIAction_DebugDraw' at line 3
typedef void* btActionInterfaceWrapper; //declaration specifier expected near 'btActionInterfaceWrapper' at line 2
typedef float btScalar;
btActionInterfaceWrapper* btActionInterfaceWrapper_new(pIAction_DebugDraw debugDrawCallback, pIAction_UpdateAction updateActionCallback);
void btActionInterface_debugDraw(btActionInterface* obj, btIDebugDraw* debugDrawer);
void btActionInterface_updateAction(btActionInterface* obj, btCollisionWorld* collisionWorld, btScalar deltaTimeStep);
void btActionInterface_delete(btActionInterface* obj);
btBroadphasePair* btAlignedBroadphasePairArray_at(btAlignedBroadphasePairArray* obj, int n);
void btAlignedBroadphasePairArray_push_back(btAlignedBroadphasePairArray* obj, btBroadphasePair* val);
void btAlignedBroadphasePairArray_resizeNoInitialize(btAlignedBroadphasePairArray* obj, int newSize);
int btAlignedBroadphasePairArray_size(btAlignedBroadphasePairArray* obj);
btCollisionObject* btAlignedCollisionObjectArray_at(btAlignedCollisionObjectArray* obj, int n);
void btAlignedCollisionObjectArray_push_back(btAlignedCollisionObjectArray* obj, btCollisionObject* val);
void btAlignedCollisionObjectArray_resizeNoInitialize(btAlignedCollisionObjectArray* obj, int newSize);
int btAlignedCollisionObjectArray_size(btAlignedCollisionObjectArray* obj);
btIndexedMesh* btAlignedIndexedMeshArray_at(btAlignedIndexedMeshArray* obj, int n);
void btAlignedIndexedMeshArray_push_back(btAlignedIndexedMeshArray* obj, btIndexedMesh* val);
void btAlignedIndexedMeshArray_resizeNoInitialize(btAlignedIndexedMeshArray* obj, int newSize);
int btAlignedIndexedMeshArray_size(btAlignedIndexedMeshArray* obj);
btAlignedManifoldArray* btAlignedManifoldArray_new();
btPersistentManifold* btAlignedManifoldArray_at(btAlignedManifoldArray* obj, int n);
void btAlignedManifoldArray_push_back(btAlignedManifoldArray* obj, btPersistentManifold* val);
void btAlignedManifoldArray_resizeNoInitialize(btAlignedManifoldArray* obj, int newSize);
int btAlignedManifoldArray_size(btAlignedManifoldArray* obj);
void btAlignedManifoldArray_delete(btAlignedManifoldArray* obj);
btSoftBody* btAlignedSoftBodyArray_at(btAlignedSoftBodyArray* obj, int n);
void btAlignedSoftBodyArray_push_back(btAlignedSoftBodyArray* obj, btSoftBody* val);
void btAlignedSoftBodyArray_resizeNoInitialize(btAlignedSoftBodyArray* obj, int newSize);
int btAlignedSoftBodyArray_size(btAlignedSoftBodyArray* obj);
btSoftBody_Cluster* btAlignedSoftBodyClusterArray_at(btAlignedSoftBodyClusterArray* obj, int n);
void btAlignedSoftBodyClusterArray_push_back(btAlignedSoftBodyClusterArray* obj, btSoftBody_Cluster* val);
void btAlignedSoftBodyClusterArray_resizeNoInitialize(btAlignedSoftBodyClusterArray* obj, int newSize);
int btAlignedSoftBodyClusterArray_size(btAlignedSoftBodyClusterArray* obj);
btSoftBody_Face* btAlignedSoftBodyFaceArray_at(btAlignedSoftBodyFaceArray* obj, int n);
void btAlignedSoftBodyFaceArray_push_back(btAlignedSoftBodyFaceArray* obj, btSoftBody_Face* val);
void btAlignedSoftBodyFaceArray_resizeNoInitialize(btAlignedSoftBodyFaceArray* obj, int newSize);
int btAlignedSoftBodyFaceArray_size(btAlignedSoftBodyFaceArray* obj);
btSoftBody_Joint* btAlignedSoftBodyJointArray_at(btAlignedSoftBodyJointArray* obj, int n);
void btAlignedSoftBodyJointArray_push_back(btAlignedSoftBodyJointArray* obj, btSoftBody_Joint* val);
void btAlignedSoftBodyJointArray_resizeNoInitialize(btAlignedSoftBodyJointArray* obj, int newSize);
int btAlignedSoftBodyJointArray_size(btAlignedSoftBodyJointArray* obj);
btSoftBody_Link* btAlignedSoftBodyLinkArray_at(btAlignedSoftBodyLinkArray* obj, int n);
void btAlignedSoftBodyLinkArray_push_back(btAlignedSoftBodyLinkArray* obj, btSoftBody_Link* val);
void btAlignedSoftBodyLinkArray_resizeNoInitialize(btAlignedSoftBodyLinkArray* obj, int newSize);
void btAlignedSoftBodyLinkArray_set(btAlignedSoftBodyLinkArray* obj, btSoftBody_Link* val, int index);
int btAlignedSoftBodyLinkArray_size(btAlignedSoftBodyLinkArray* obj);
btSoftBody_Material* btAlignedSoftBodyMaterialArray_at(btAlignedSoftBodyMaterialArray* obj, int n);
void btAlignedSoftBodyMaterialArray_push_back(btAlignedSoftBodyMaterialArray* obj, btSoftBody_Material* val);
void btAlignedSoftBodyMaterialArray_resizeNoInitialize(btAlignedSoftBodyMaterialArray* obj, int newSize);
int btAlignedSoftBodyMaterialArray_size(btAlignedSoftBodyMaterialArray* obj);
btSoftBody_Node* btAlignedSoftBodyNodeArray_at(btAlignedSoftBodyNodeArray* obj, int n);
int btAlignedSoftBodyNodeArray_index_of(btAlignedSoftBodyNodeArray* obj, btSoftBody_Node* val);
void btAlignedSoftBodyNodeArray_push_back(btAlignedSoftBodyNodeArray* obj, btSoftBody_Node* val);
void btAlignedSoftBodyNodeArray_resizeNoInitialize(btAlignedSoftBodyNodeArray* obj, int newSize);
int btAlignedSoftBodyNodeArray_size(btAlignedSoftBodyNodeArray* obj);
btSoftBody_Tetra* btAlignedSoftBodyTetraArray_at(btAlignedSoftBodyTetraArray* obj, int n);
void btAlignedSoftBodyTetraArray_push_back(btAlignedSoftBodyTetraArray* obj, btSoftBody_Tetra* val);
void btAlignedSoftBodyTetraArray_resizeNoInitialize(btAlignedSoftBodyTetraArray* obj, int newSize);
int btAlignedSoftBodyTetraArray_size(btAlignedSoftBodyTetraArray* obj);
btAxisSweep3* btAxisSweep3_new(const btScalar* worldAabbMin, const btScalar* worldAabbMax);
btAxisSweep3* btAxisSweep3_new2(const btScalar* worldAabbMin, const btScalar* worldAabbMax, unsigned short maxHandles);
btAxisSweep3* btAxisSweep3_new3(const btScalar* worldAabbMin, const btScalar* worldAabbMax, unsigned short maxHandles, btOverlappingPairCache* pairCache);
btAxisSweep3* btAxisSweep3_new4(const btScalar* worldAabbMin, const btScalar* worldAabbMax, unsigned short maxHandles, btOverlappingPairCache* pairCache, bool disableRaycastAccelerator);
unsigned short btAxisSweep3_addHandle(btAxisSweep3* obj, const btScalar* aabbMin, const btScalar* aabbMax, void* pOwner, unsigned short collisionFilterGroup, unsigned short collisionFilterMask, btDispatcher* dispatcher, void* multiSapProxy);
btAxisSweep3_Handle* btAxisSweep3_getHandle(btAxisSweep3* obj, unsigned short index);
unsigned short btAxisSweep3_getNumHandles(btAxisSweep3* obj, btOverlapCallback* callback);
btOverlappingPairCallback* btAxisSweep3_getOverlappingPairUserCallback(btAxisSweep3* obj);
void btAxisSweep3_processAllOverlappingPairs(btAxisSweep3* obj, btOverlapCallback* callback);
void btAxisSweep3_quantize(btAxisSweep3* obj, unsigned short* out, const btScalar* point, int isMax);
void btAxisSweep3_removeHandle(btAxisSweep3* obj, unsigned short handle, btDispatcher* dispatcher);
void btAxisSweep3_setOverlappingPairUserCallback(btAxisSweep3* obj, btOverlappingPairCallback* pairCallback);
bool btAxisSweep3_testAabbOverlap(btAxisSweep3* obj, btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1);
void btAxisSweep3_unQuantize(btAxisSweep3* obj, btBroadphaseProxy* proxy, btScalar* aabbMin, btScalar* aabbMax);
void btAxisSweep3_updateHandle(btAxisSweep3* obj, unsigned short handle, const btScalar* aabbMin, const btScalar* aabbMax, btDispatcher* dispatcher);
bt32BitAxisSweep3* bt32BitAxisSweep3_new(const btScalar* worldAabbMin, const btScalar* worldAabbMax);
bt32BitAxisSweep3* bt32BitAxisSweep3_new2(const btScalar* worldAabbMin, const btScalar* worldAabbMax, unsigned int maxHandles);
bt32BitAxisSweep3* bt32BitAxisSweep3_new3(const btScalar* worldAabbMin, const btScalar* worldAabbMax, unsigned int maxHandles, btOverlappingPairCache* pairCache);
bt32BitAxisSweep3* bt32BitAxisSweep3_new4(const btScalar* worldAabbMin, const btScalar* worldAabbMax, unsigned int maxHandles, btOverlappingPairCache* pairCache, bool disableRaycastAccelerator);
unsigned int bt32BitAxisSweep3_addHandle(bt32BitAxisSweep3* obj, const btScalar* aabbMin, const btScalar* aabbMax, void* pOwner, unsigned short collisionFilterGroup, unsigned short collisionFilterMask, btDispatcher* dispatcher, void* multiSapProxy);
bt32BitAxisSweep3_Handle* bt32BitAxisSweep3_getHandle(bt32BitAxisSweep3* obj, unsigned int index);
unsigned int bt32BitAxisSweep3_getNumHandles(bt32BitAxisSweep3* obj, btOverlapCallback* callback);
btOverlappingPairCache* bt32BitAxisSweep3_getOverlappingPairCache(bt32BitAxisSweep3* obj);
void bt32BitAxisSweep3_processAllOverlappingPairs(bt32BitAxisSweep3* obj, btOverlapCallback* callback);
void bt32BitAxisSweep3_quantize(btAxisSweep3* obj, unsigned int* out, const btScalar* point, int isMax);
void bt32BitAxisSweep3_removeHandle(bt32BitAxisSweep3* obj, unsigned int handle, btDispatcher* dispatcher);
void bt32BitAxisSweep3_setOverlappingPairUserCallback(bt32BitAxisSweep3* obj, btOverlappingPairCallback* pairCallback);
bool bt32BitAxisSweep3_testAabbOverlap(bt32BitAxisSweep3* obj, btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1);
void bt32BitAxisSweep3_unQuantize(bt32BitAxisSweep3* obj, btBroadphaseProxy* proxy, btScalar* aabbMin, btScalar* aabbMax);
void bt32BitAxisSweep3_updateHandle(bt32BitAxisSweep3* obj, unsigned int handle, const btScalar* aabbMin, const btScalar* aabbMax, btDispatcher* dispatcher);
btBox2dBox2dCollisionAlgorithm_CreateFunc* btBox2dBox2dCollisionAlgorithm_CreateFunc_new();
btBox2dBox2dCollisionAlgorithm* btBox2dBox2dCollisionAlgorithm_new(const btCollisionAlgorithmConstructionInfo* ci);
btBox2dBox2dCollisionAlgorithm* btBox2dBox2dCollisionAlgorithm_new2(btPersistentManifold* mf, const btCollisionAlgorithmConstructionInfo* ci, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap);
btBox2dShape* btBox2dShape_new(const btScalar* boxHalfExtents);
btBox2dShape* btBox2dShape_new2(btScalar boxHalfExtent);
btBox2dShape* btBox2dShape_new3(btScalar boxHalfExtentX, btScalar boxHalfExtentY, btScalar boxHalfExtentZ);
void btBox2dShape_getCentroid(btBox2dShape* obj, btScalar* value);
void btBox2dShape_getHalfExtentsWithMargin(btBox2dShape* obj, btScalar* value);
void btBox2dShape_getHalfExtentsWithoutMargin(btBox2dShape* obj, btScalar* value);
const btVector3* btBox2dShape_getNormals(btBox2dShape* obj);
void btBox2dShape_getPlaneEquation(btBox2dShape* obj, btScalar* plane, int i);
int btBox2dShape_getVertexCount(btBox2dShape* obj);
const btVector3* btBox2dShape_getVertices(btBox2dShape* obj);
btBoxBoxCollisionAlgorithm_CreateFunc* btBoxBoxCollisionAlgorithm_CreateFunc_new();
btBoxBoxCollisionAlgorithm* btBoxBoxCollisionAlgorithm_new(const btCollisionAlgorithmConstructionInfo* ci);
btBoxBoxCollisionAlgorithm* btBoxBoxCollisionAlgorithm_new2(btPersistentManifold* mf, const btCollisionAlgorithmConstructionInfo* ci, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap);
btBoxBoxDetector* btBoxBoxDetector_new(const btBoxShape* box1, const btBoxShape* box2);
const btBoxShape* btBoxBoxDetector_getBox1(btBoxBoxDetector* obj);
const btBoxShape* btBoxBoxDetector_getBox2(btBoxBoxDetector* obj);
void btBoxBoxDetector_setBox1(btBoxBoxDetector* obj, const btBoxShape* value);
void btBoxBoxDetector_setBox2(btBoxBoxDetector* obj, const btBoxShape* value);
BT_BOX_BOX_TRANSFORM_CACHE* BT_BOX_BOX_TRANSFORM_CACHE_new();
void BT_BOX_BOX_TRANSFORM_CACHE_calc_absolute_matrix(BT_BOX_BOX_TRANSFORM_CACHE* obj);
void BT_BOX_BOX_TRANSFORM_CACHE_calc_from_full_invert(BT_BOX_BOX_TRANSFORM_CACHE* obj, const btScalar* trans0, const btScalar* trans1);
void BT_BOX_BOX_TRANSFORM_CACHE_calc_from_homogenic(BT_BOX_BOX_TRANSFORM_CACHE* obj, const btScalar* trans0, const btScalar* trans1);
void BT_BOX_BOX_TRANSFORM_CACHE_getAR(BT_BOX_BOX_TRANSFORM_CACHE* obj, btScalar* value);
void BT_BOX_BOX_TRANSFORM_CACHE_getR1to0(BT_BOX_BOX_TRANSFORM_CACHE* obj, btScalar* value);
void BT_BOX_BOX_TRANSFORM_CACHE_getT1to0(BT_BOX_BOX_TRANSFORM_CACHE* obj, btScalar* value);
void BT_BOX_BOX_TRANSFORM_CACHE_setAR(BT_BOX_BOX_TRANSFORM_CACHE* obj, const btScalar* value);
void BT_BOX_BOX_TRANSFORM_CACHE_setR1to0(BT_BOX_BOX_TRANSFORM_CACHE* obj, const btScalar* value);
void BT_BOX_BOX_TRANSFORM_CACHE_setT1to0(BT_BOX_BOX_TRANSFORM_CACHE* obj, const btScalar* value);
void BT_BOX_BOX_TRANSFORM_CACHE_transform(BT_BOX_BOX_TRANSFORM_CACHE* obj, const btScalar* point, btScalar* value);
void BT_BOX_BOX_TRANSFORM_CACHE_delete(BT_BOX_BOX_TRANSFORM_CACHE* obj);
btAABB* btAABB_new();
btAABB* btAABB_new2(const btScalar* V1, const btScalar* V2, const btScalar* V3);
btAABB* btAABB_new3(const btScalar* V1, const btScalar* V2, const btScalar* V3, btScalar margin);
btAABB* btAABB_new4(const btAABB* other);
btAABB* btAABB_new5(const btAABB* other, btScalar margin);
void btAABB_appy_transform(btAABB* obj, const btScalar* trans);
void btAABB_appy_transform_trans_cache(btAABB* obj, const BT_BOX_BOX_TRANSFORM_CACHE* trans);
bool btAABB_collide_plane(btAABB* obj, const btScalar* plane);
bool btAABB_collide_ray(btAABB* obj, const btScalar* vorigin, const btScalar* vdir);
bool btAABB_collide_triangle_exact(btAABB* obj, const btScalar* p1, const btScalar* p2, const btScalar* p3, const btScalar* triangle_plane);
void btAABB_copy_with_margin(btAABB* obj, const btAABB* other, btScalar margin);
void btAABB_find_intersection(btAABB* obj, const btAABB* other, btAABB* intersection);
void btAABB_get_center_extend(btAABB* obj, btScalar* center, btScalar* extend);
void btAABB_getMax(btAABB* obj, btScalar* value);
void btAABB_getMin(btAABB* obj, btScalar* value);
bool btAABB_has_collision(btAABB* obj, const btAABB* other);
void btAABB_increment_margin(btAABB* obj, btScalar margin);
void btAABB_invalidate(btAABB* obj);
void btAABB_merge(btAABB* obj, const btAABB* box);
bool btAABB_overlapping_trans_cache(btAABB* obj, const btAABB* box, const BT_BOX_BOX_TRANSFORM_CACHE* transcache, bool fulltest);
bool btAABB_overlapping_trans_conservative(btAABB* obj, const btAABB* box, btScalar* trans1_to_0);
bool btAABB_overlapping_trans_conservative2(btAABB* obj, const btAABB* box, const BT_BOX_BOX_TRANSFORM_CACHE* trans1_to_0);
eBT_PLANE_INTERSECTION_TYPE btAABB_plane_classify(btAABB* obj, const btScalar* plane);
void btAABB_projection_interval(btAABB* obj, const btScalar* direction, btScalar* vmin, btScalar* vmax);
void btAABB_setMax(btAABB* obj, const btScalar* value);
void btAABB_setMin(btAABB* obj, const btScalar* value);
void btAABB_delete(btAABB* obj);
btBoxShape* btBoxShape_new(const btScalar* boxHalfExtents);
btBoxShape* btBoxShape_new2(btScalar boxHalfExtent);
btBoxShape* btBoxShape_new3(btScalar boxHalfExtentX, btScalar boxHalfExtentY, btScalar boxHalfExtentZ);
void btBoxShape_getHalfExtentsWithMargin(btBoxShape* obj, btScalar* value);
void btBoxShape_getHalfExtentsWithoutMargin(btBoxShape* obj, btScalar* value);
void btBoxShape_getPlaneEquation(btBoxShape* obj, btScalar* plane, int i);
btBroadphaseAabbCallbackWrapper* btBroadphaseAabbCallbackWrapper_new(pBroadphaseAabbCallback_Process processCallback);
bool btBroadphaseAabbCallback_process(btBroadphaseAabbCallback* obj, const btBroadphaseProxy* proxy);
void btBroadphaseAabbCallback_delete(btBroadphaseAabbCallback* obj);
btBroadphaseRayCallbackWrapper* btBroadphaseRayCallbackWrapper_new(pBroadphaseAabbCallback_Process processCallback);
btScalar btBroadphaseRayCallback_getLambda_max(btBroadphaseRayCallback* obj);
void btBroadphaseRayCallback_getRayDirectionInverse(btBroadphaseRayCallback* obj, btScalar* value);
unsigned int* btBroadphaseRayCallback_getSigns(btBroadphaseRayCallback* obj);
void btBroadphaseRayCallback_setLambda_max(btBroadphaseRayCallback* obj, btScalar value);
void btBroadphaseRayCallback_setRayDirectionInverse(btBroadphaseRayCallback* obj, const btScalar* value);
void btBroadphaseInterface_aabbTest(btBroadphaseInterface* obj, const btScalar* aabbMin, const btScalar* aabbMax, btBroadphaseAabbCallback* callback);
void btBroadphaseInterface_calculateOverlappingPairs(btBroadphaseInterface* obj, btDispatcher* dispatcher);
btBroadphaseProxy* btBroadphaseInterface_createProxy(btBroadphaseInterface* obj, const btScalar* aabbMin, const btScalar* aabbMax, int shapeType, void* userPtr, short collisionFilterGroup, short collisionFilterMask, btDispatcher* dispatcher, void* multiSapProxy);
void btBroadphaseInterface_destroyProxy(btBroadphaseInterface* obj, btBroadphaseProxy* proxy, btDispatcher* dispatcher);
void btBroadphaseInterface_getAabb(btBroadphaseInterface* obj, btBroadphaseProxy* proxy, btScalar* aabbMin, btScalar* aabbMax);
void btBroadphaseInterface_getBroadphaseAabb(btBroadphaseInterface* obj, btScalar* aabbMin, btScalar* aabbMax);
btOverlappingPairCache* btBroadphaseInterface_getOverlappingPairCache(btBroadphaseInterface* obj);
void btBroadphaseInterface_printStats(btBroadphaseInterface* obj);
void btBroadphaseInterface_rayTest(btBroadphaseInterface* obj, const btScalar* rayFrom, const btScalar* rayTo, btBroadphaseRayCallback* rayCallback);
void btBroadphaseInterface_rayTest2(btBroadphaseInterface* obj, const btScalar* rayFrom, const btScalar* rayTo, btBroadphaseRayCallback* rayCallback, const btScalar* aabbMin);
void btBroadphaseInterface_rayTest3(btBroadphaseInterface* obj, const btScalar* rayFrom, const btScalar* rayTo, btBroadphaseRayCallback* rayCallback, const btScalar* aabbMin, const btScalar* aabbMax);
void btBroadphaseInterface_resetPool(btBroadphaseInterface* obj, btDispatcher* dispatcher);
void btBroadphaseInterface_setAabb(btBroadphaseInterface* obj, btBroadphaseProxy* proxy, const btScalar* aabbMin, const btScalar* aabbMax, btDispatcher* dispatcher);
void btBroadphaseInterface_delete(btBroadphaseInterface* obj);
btBroadphaseProxy* btBroadphaseProxy_new();
btBroadphaseProxy* btBroadphaseProxy_new2(const btScalar* aabbMin, const btScalar* aabbMax, void* userPtr, short collisionFilterGroup, short collisionFilterMask);
btBroadphaseProxy* btBroadphaseProxy_new3(const btScalar* aabbMin, const btScalar* aabbMax, void* userPtr, short collisionFilterGroup, short collisionFilterMask, void* multiSapParentProxy);
void btBroadphaseProxy_getAabbMax(btBroadphaseProxy* obj, btScalar* value);
void btBroadphaseProxy_getAabbMin(btBroadphaseProxy* obj, btScalar* value);
void* btBroadphaseProxy_getClientObject(btBroadphaseProxy* obj);
short btBroadphaseProxy_getCollisionFilterGroup(btBroadphaseProxy* obj);
short btBroadphaseProxy_getCollisionFilterMask(btBroadphaseProxy* obj);
void* btBroadphaseProxy_getMultiSapParentProxy(btBroadphaseProxy* obj);
int btBroadphaseProxy_getUid(btBroadphaseProxy* obj);
int btBroadphaseProxy_getUniqueId(btBroadphaseProxy* obj);
bool btBroadphaseProxy_isCompound(int proxyType);
bool btBroadphaseProxy_isConcave(int proxyType);
bool btBroadphaseProxy_isConvex(int proxyType);
bool btBroadphaseProxy_isConvex2d(int proxyType);
bool btBroadphaseProxy_isInfinite(int proxyType);
bool btBroadphaseProxy_isNonMoving(int proxyType);
bool btBroadphaseProxy_isPolyhedral(int proxyType);
bool btBroadphaseProxy_isSoftBody(int proxyType);
void btBroadphaseProxy_setAabbMax(btBroadphaseProxy* obj, const btScalar* value);
void btBroadphaseProxy_setAabbMin(btBroadphaseProxy* obj, const btScalar* value);
void btBroadphaseProxy_setClientObject(btBroadphaseProxy* obj, void* value);
void btBroadphaseProxy_setCollisionFilterGroup(btBroadphaseProxy* obj, short value);
void btBroadphaseProxy_setCollisionFilterMask(btBroadphaseProxy* obj, short value);
void btBroadphaseProxy_setMultiSapParentProxy(btBroadphaseProxy* obj, void* value);
void btBroadphaseProxy_setUniqueId(btBroadphaseProxy* obj, int value);
void btBroadphaseProxy_delete(btBroadphaseProxy* obj);
btBroadphasePair* btBroadphasePair_new();
btBroadphasePair* btBroadphasePair_new2(const btBroadphasePair* other);
btBroadphasePair* btBroadphasePair_new3(btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1);
btCollisionAlgorithm* btBroadphasePair_getAlgorithm(btBroadphasePair* obj);
btBroadphaseProxy* btBroadphasePair_getPProxy0(btBroadphasePair* obj);
btBroadphaseProxy* btBroadphasePair_getPProxy1(btBroadphasePair* obj);
void btBroadphasePair_setAlgorithm(btBroadphasePair* obj, btCollisionAlgorithm* value);
void btBroadphasePair_setPProxy0(btBroadphasePair* obj, btBroadphaseProxy* value);
void btBroadphasePair_setPProxy1(btBroadphasePair* obj, btBroadphaseProxy* value);
void btBroadphasePair_delete(btBroadphasePair* obj);
bParse_btBulletFile* btBulletFile_new();
bParse_btBulletFile* btBulletFile_new2(const char* fileName);
bParse_btBulletFile* btBulletFile_new3(char* memoryBuffer, int len);
void btBulletFile_addStruct(bParse_btBulletFile* obj, const char* structType, void* data, int len, void* oldPtr, int code);
btAlignedStructHandleArray* btBulletFile_getBvhs(bParse_btBulletFile* obj);
btAlignedStructHandleArray* btBulletFile_getCollisionObjects(bParse_btBulletFile* obj);
btAlignedStructHandleArray* btBulletFile_getCollisionShapes(bParse_btBulletFile* obj);
btAlignedStructHandleArray* btBulletFile_getConstraints(bParse_btBulletFile* obj);
btAligendCharPtrArray* btBulletFile_getDataBlocks(bParse_btBulletFile* obj);
btAlignedStructHandleArray* btBulletFile_getDynamicsWorldInfo(bParse_btBulletFile* obj);
btAlignedStructHandleArray* btBulletFile_getRigidBodies(bParse_btBulletFile* obj);
btAlignedStructHandleArray* btBulletFile_getSoftBodies(bParse_btBulletFile* obj);
btAlignedStructHandleArray* btBulletFile_getTriangleInfoMaps(bParse_btBulletFile* obj);
void btBulletFile_parseData(bParse_btBulletFile* obj);
btBulletWorldImporter* btBulletWorldImporter_new();
btBulletWorldImporter* btBulletWorldImporter_new2(btDynamicsWorld* world);
bool btBulletWorldImporter_convertAllObjects(btBulletWorldImporter* obj, bParse_btBulletFile* file);
bool btBulletWorldImporter_loadFile(btBulletWorldImporter* obj, const char* fileName);
bool btBulletWorldImporter_loadFile2(btBulletWorldImporter* obj, const char* fileName, const char* preSwapFilenameOut);
bool btBulletWorldImporter_loadFileFromMemory(btBulletWorldImporter* obj, char* memoryBuffer, int len);
bool btBulletWorldImporter_loadFileFromMemory2(btBulletWorldImporter* obj, bParse_btBulletFile* file);
btBulletXmlWorldImporter* btBulletXmlWorldImporter_new(btDynamicsWorld* world);
bool btBulletXmlWorldImporter_loadFile(btBulletXmlWorldImporter* obj, const char* fileName);
btBvhTriangleMeshShape* btBvhTriangleMeshShape_new(btStridingMeshInterface* meshInterface, bool useQuantizedAabbCompression);
btBvhTriangleMeshShape* btBvhTriangleMeshShape_new2(btStridingMeshInterface* meshInterface, bool useQuantizedAabbCompression, bool buildBvh);
btBvhTriangleMeshShape* btBvhTriangleMeshShape_new3(btStridingMeshInterface* meshInterface, bool useQuantizedAabbCompression, const btScalar* bvhAabbMin, const btScalar* bvhAabbMax);
btBvhTriangleMeshShape* btBvhTriangleMeshShape_new4(btStridingMeshInterface* meshInterface, bool useQuantizedAabbCompression, const btScalar* bvhAabbMin, const btScalar* bvhAabbMax, bool buildBvh);
void btBvhTriangleMeshShape_buildOptimizedBvh(btBvhTriangleMeshShape* obj);
btOptimizedBvh* btBvhTriangleMeshShape_getOptimizedBvh(btBvhTriangleMeshShape* obj);
bool btBvhTriangleMeshShape_getOwnsBvh(btBvhTriangleMeshShape* obj);
btTriangleInfoMap* btBvhTriangleMeshShape_getTriangleInfoMap(btBvhTriangleMeshShape* obj);
void btBvhTriangleMeshShape_partialRefitTree(btBvhTriangleMeshShape* obj, const btScalar* aabbMin, const btScalar* aabbMax);
void btBvhTriangleMeshShape_performConvexcast(btBvhTriangleMeshShape* obj, btTriangleCallback* callback, const btScalar* boxSource, const btScalar* boxTarget, const btScalar* boxMin, const btScalar* boxMax);
void btBvhTriangleMeshShape_performRaycast(btBvhTriangleMeshShape* obj, btTriangleCallback* callback, const btScalar* raySource, const btScalar* rayTarget);
void btBvhTriangleMeshShape_refitTree(btBvhTriangleMeshShape* obj, const btScalar* aabbMin, const btScalar* aabbMax);
void btBvhTriangleMeshShape_serializeSingleBvh(btBvhTriangleMeshShape* obj, btSerializer* serializer);
void btBvhTriangleMeshShape_serializeSingleTriangleInfoMap(btBvhTriangleMeshShape* obj, btSerializer* serializer);
void btBvhTriangleMeshShape_setOptimizedBvh(btBvhTriangleMeshShape* obj, btOptimizedBvh* bvh);
void btBvhTriangleMeshShape_setOptimizedBvh2(btBvhTriangleMeshShape* obj, btOptimizedBvh* bvh, const btScalar* localScaling);
void btBvhTriangleMeshShape_setTriangleInfoMap(btBvhTriangleMeshShape* obj, btTriangleInfoMap* triangleInfoMap);
bool btBvhTriangleMeshShape_usesQuantizedAabbCompression(btBvhTriangleMeshShape* obj);
btCapsuleShape* btCapsuleShape_new(btScalar radius, btScalar height);
btScalar btCapsuleShape_getHalfHeight(btCapsuleShape* obj);
btScalar btCapsuleShape_getRadius(btCapsuleShape* obj);
int btCapsuleShape_getUpAxis(btCapsuleShape* obj);
btCapsuleShapeX* btCapsuleShapeX_new(btScalar radius, btScalar height);
btCapsuleShapeZ* btCapsuleShapeZ_new(btScalar radius, btScalar height);
bool btCharacterControllerInterface_canJump(btCharacterControllerInterface* obj);
void btCharacterControllerInterface_jump(btCharacterControllerInterface* obj);
bool btCharacterControllerInterface_onGround(btCharacterControllerInterface* obj);
void btCharacterControllerInterface_playerStep(btCharacterControllerInterface* obj, btCollisionWorld* collisionWorld, btScalar dt);
void btCharacterControllerInterface_preStep(btCharacterControllerInterface* obj, btCollisionWorld* collisionWorld);
void btCharacterControllerInterface_reset(btCharacterControllerInterface* obj, btCollisionWorld* collisionWorld);
void btCharacterControllerInterface_setUpInterpolate(btCharacterControllerInterface* obj, bool value);
void btCharacterControllerInterface_setWalkDirection(btCharacterControllerInterface* obj, const btScalar* walkDirection);
void btCharacterControllerInterface_setVelocityForTimeInterval(btCharacterControllerInterface* obj, const btScalar* velocity, btScalar timeInterval);
void btCharacterControllerInterface_warp(btCharacterControllerInterface* obj, const btScalar* origin);
btCollisionAlgorithmConstructionInfo* btCollisionAlgorithmConstructionInfo_new();
btCollisionAlgorithmConstructionInfo* btCollisionAlgorithmConstructionInfo_new2(btDispatcher* dispatcher, int temp);
btDispatcher* btCollisionAlgorithmConstructionInfo_getDispatcher1(btCollisionAlgorithmConstructionInfo* obj);
btPersistentManifold* btCollisionAlgorithmConstructionInfo_getManifold(btCollisionAlgorithmConstructionInfo* obj);
void btCollisionAlgorithmConstructionInfo_setDispatcher1(btCollisionAlgorithmConstructionInfo* obj, btDispatcher* value);
void btCollisionAlgorithmConstructionInfo_setManifold(btCollisionAlgorithmConstructionInfo* obj, btPersistentManifold* value);
void btCollisionAlgorithmConstructionInfo_delete(btCollisionAlgorithmConstructionInfo* obj);
btScalar btCollisionAlgorithm_calculateTimeOfImpact(btCollisionAlgorithm* obj, btCollisionObject* body0, btCollisionObject* body1, const btDispatcherInfo* dispatchInfo, btManifoldResult* resultOut);
void btCollisionAlgorithm_getAllContactManifolds(btCollisionAlgorithm* obj, btAlignedManifoldArray* manifoldArray);
void btCollisionAlgorithm_processCollision(btCollisionAlgorithm* obj, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, const btDispatcherInfo* dispatchInfo, btManifoldResult* resultOut);
void btCollisionAlgorithm_delete(btCollisionAlgorithm* obj);
btCollisionAlgorithmCreateFunc* btCollisionConfiguration_getCollisionAlgorithmCreateFunc(btCollisionConfiguration* obj, int proxyType0, int proxyType1);
btPoolAllocator* btCollisionConfiguration_getCollisionAlgorithmPool(btCollisionConfiguration* obj);
btPoolAllocator* btCollisionConfiguration_getPersistentManifoldPool(btCollisionConfiguration* obj);
void btCollisionConfiguration_delete(btCollisionConfiguration* obj);
btCollisionAlgorithmCreateFunc* btCollisionAlgorithmCreateFunc_new();
btCollisionAlgorithm* btCollisionAlgorithmCreateFunc_CreateCollisionAlgorithm(btCollisionAlgorithmCreateFunc* obj, btCollisionAlgorithmConstructionInfo* __unnamed0, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap);
bool btCollisionAlgorithmCreateFunc_getSwapped(btCollisionAlgorithmCreateFunc* obj);
void btCollisionAlgorithmCreateFunc_setSwapped(btCollisionAlgorithmCreateFunc* obj, bool value);
void btCollisionAlgorithmCreateFunc_delete(btCollisionAlgorithmCreateFunc* obj);
btCollisionDispatcher* btCollisionDispatcher_new(btCollisionConfiguration* collisionConfiguration);
void btCollisionDispatcher_defaultNearCallback(btBroadphasePair* collisionPair, btCollisionDispatcher* dispatcher, const btDispatcherInfo* dispatchInfo);
const btCollisionConfiguration* btCollisionDispatcher_getCollisionConfiguration(btCollisionDispatcher* obj);
int btCollisionDispatcher_getDispatcherFlags(btCollisionDispatcher* obj);
btNearCallback btCollisionDispatcher_getNearCallback(btCollisionDispatcher* obj);
void btCollisionDispatcher_registerCollisionCreateFunc(btCollisionDispatcher* obj, int proxyType0, int proxyType1, btCollisionAlgorithmCreateFunc* createFunc);
void btCollisionDispatcher_setCollisionConfiguration(btCollisionDispatcher* obj, btCollisionConfiguration* config);
void btCollisionDispatcher_setDispatcherFlags(btCollisionDispatcher* obj, int flags);
void btCollisionDispatcher_setNearCallback(btCollisionDispatcher* obj, btNearCallback nearCallback);
const btCollisionObject* btCollisionObjectWrapper_getCollisionObject(btCollisionObjectWrapper* obj);
const btCollisionShape* btCollisionObjectWrapper_getCollisionShape(btCollisionObjectWrapper* obj);
int btCollisionObjectWrapper_getIndex(btCollisionObjectWrapper* obj);
const btCollisionObjectWrapper* btCollisionObjectWrapper_getParent(btCollisionObjectWrapper* obj);
int btCollisionObjectWrapper_getPartId(btCollisionObjectWrapper* obj);
void btCollisionObjectWrapper_getWorldTransform(btCollisionObjectWrapper* obj, btScalar* value);
void btCollisionObjectWrapper_setCollisionObject(btCollisionObjectWrapper* obj, const btCollisionObject* value);
void btCollisionObjectWrapper_setIndex(btCollisionObjectWrapper* obj, int value);
void btCollisionObjectWrapper_setParent(btCollisionObjectWrapper* obj, const btCollisionObjectWrapper* value);
void btCollisionObjectWrapper_setPartId(btCollisionObjectWrapper* obj, int value);
void btCollisionObjectWrapper_setShape(btCollisionObjectWrapper* obj, const btCollisionShape* value);
btCollisionObject* btCollisionObject_new();
void btCollisionObject_activate(btCollisionObject* obj);
void btCollisionObject_activate2(btCollisionObject* obj, bool forceActivation);
int btCollisionObject_calculateSerializeBufferSize(btCollisionObject* obj);
bool btCollisionObject_checkCollideWith(btCollisionObject* obj, const btCollisionObject* co);
bool btCollisionObject_checkCollideWithOverride(btCollisionObject* obj, const btCollisionObject* co);
void btCollisionObject_forceActivationState(btCollisionObject* obj, int newState);
int btCollisionObject_getActivationState(btCollisionObject* obj);
void btCollisionObject_getAnisotropicFriction(btCollisionObject* obj, btScalar* value);
btBroadphaseProxy* btCollisionObject_getBroadphaseHandle(btCollisionObject* obj);
btScalar btCollisionObject_getCcdMotionThreshold(btCollisionObject* obj);
btScalar btCollisionObject_getCcdSquareMotionThreshold(btCollisionObject* obj);
btScalar btCollisionObject_getCcdSweptSphereRadius(btCollisionObject* obj);
int btCollisionObject_getCollisionFlags(btCollisionObject* obj);
btCollisionShape* btCollisionObject_getCollisionShape(btCollisionObject* obj);
int btCollisionObject_getCompanionId(btCollisionObject* obj);
btScalar btCollisionObject_getContactProcessingThreshold(btCollisionObject* obj);
btScalar btCollisionObject_getDeactivationTime(btCollisionObject* obj);
btScalar btCollisionObject_getFriction(btCollisionObject* obj);
btScalar btCollisionObject_getHitFraction(btCollisionObject* obj);
int btCollisionObject_getInternalType(btCollisionObject* obj);
void btCollisionObject_getInterpolationAngularVelocity(btCollisionObject* obj, btScalar* angvel);
void btCollisionObject_getInterpolationLinearVelocity(btCollisionObject* obj, btScalar* linvel);
void btCollisionObject_getInterpolationWorldTransform(btCollisionObject* obj, btScalar* trans);
int btCollisionObject_getIslandTag(btCollisionObject* obj);
btScalar btCollisionObject_getRestitution(btCollisionObject* obj);
btScalar btCollisionObject_getRollingFriction(btCollisionObject* obj);
int btCollisionObject_getUserIndex(btCollisionObject* obj);
void* btCollisionObject_getUserPointer(btCollisionObject* obj);
void btCollisionObject_getWorldTransform(btCollisionObject* obj, btScalar* worldTrans);
bool btCollisionObject_hasAnisotropicFriction(btCollisionObject* obj);
bool btCollisionObject_hasAnisotropicFriction2(btCollisionObject* obj, int frictionMode);
bool btCollisionObject_hasContactResponse(btCollisionObject* obj);
void* btCollisionObject_internalGetExtensionPointer(btCollisionObject* obj);
void btCollisionObject_internalSetExtensionPointer(btCollisionObject* obj, void* pointer);
bool btCollisionObject_isActive(btCollisionObject* obj);
bool btCollisionObject_isKinematicObject(btCollisionObject* obj);
bool btCollisionObject_isStaticObject(btCollisionObject* obj);
bool btCollisionObject_isStaticOrKinematicObject(btCollisionObject* obj);
bool btCollisionObject_mergesSimulationIslands(btCollisionObject* obj);
const char* btCollisionObject_serialize(btCollisionObject* obj, void* dataBuffer, btSerializer* serializer);
void btCollisionObject_serializeSingleObject(btCollisionObject* obj, btSerializer* serializer);
void btCollisionObject_setActivationState(btCollisionObject* obj, int newState);
void btCollisionObject_setAnisotropicFriction(btCollisionObject* obj, const btScalar* anisotropicFriction);
void btCollisionObject_setAnisotropicFriction2(btCollisionObject* obj, const btScalar* anisotropicFriction, int frictionMode);
void btCollisionObject_setBroadphaseHandle(btCollisionObject* obj, btBroadphaseProxy* handle);
void btCollisionObject_setCcdMotionThreshold(btCollisionObject* obj, btScalar ccdMotionThreshold);
void btCollisionObject_setCcdSweptSphereRadius(btCollisionObject* obj, btScalar radius);
void btCollisionObject_setCollisionFlags(btCollisionObject* obj, int flags);
void btCollisionObject_setCollisionShape(btCollisionObject* obj, btCollisionShape* collisionShape);
void btCollisionObject_setCompanionId(btCollisionObject* obj, int id);
void btCollisionObject_setContactProcessingThreshold(btCollisionObject* obj, btScalar contactProcessingThreshold);
void btCollisionObject_setDeactivationTime(btCollisionObject* obj, btScalar time);
void btCollisionObject_setFriction(btCollisionObject* obj, btScalar frict);
void btCollisionObject_setHitFraction(btCollisionObject* obj, btScalar hitFraction);
void btCollisionObject_setIgnoreCollisionCheck(btCollisionObject* obj, const btCollisionObject* co, bool ignoreCollisionCheck);
void btCollisionObject_setInterpolationAngularVelocity(btCollisionObject* obj, const btScalar* angvel);
void btCollisionObject_setInterpolationLinearVelocity(btCollisionObject* obj, const btScalar* linvel);
void btCollisionObject_setInterpolationWorldTransform(btCollisionObject* obj, const btScalar* trans);
void btCollisionObject_setIslandTag(btCollisionObject* obj, int tag);
void btCollisionObject_setRestitution(btCollisionObject* obj, btScalar rest);
void btCollisionObject_setRollingFriction(btCollisionObject* obj, btScalar frict);
void btCollisionObject_setUserIndex(btCollisionObject* obj, int index);
void btCollisionObject_setUserPointer(btCollisionObject* obj, void* userPointer);
void btCollisionObject_setWorldTransform(btCollisionObject* obj, const btScalar* worldTrans);
void btCollisionObject_delete(btCollisionObject* obj);
void btCollisionShape_calculateLocalInertia(btCollisionShape* obj, btScalar mass, btScalar* inertia);
int btCollisionShape_calculateSerializeBufferSize(btCollisionShape* obj);
void btCollisionShape_calculateTemporalAabb(btCollisionShape* obj, const btScalar* curTrans, const btScalar* linvel, const btScalar* angvel, btScalar timeStep, btScalar* temporalAabbMin, btScalar* temporalAabbMax);
void btCollisionShape_getAabb(btCollisionShape* obj, const btScalar* t, btScalar* aabbMin, btScalar* aabbMax);
btScalar btCollisionShape_getAngularMotionDisc(btCollisionShape* obj);
void btCollisionShape_getAnisotropicRollingFrictionDirection(btCollisionShape* obj, btScalar* value);
void btCollisionShape_getBoundingSphere(btCollisionShape* obj, btScalar* center, btScalar* radius);
btScalar btCollisionShape_getContactBreakingThreshold(btCollisionShape* obj, btScalar defaultContactThresholdFactor);
void btCollisionShape_getLocalScaling(btCollisionShape* obj, btScalar* scaling);
btScalar btCollisionShape_getMargin(btCollisionShape* obj);
const char* btCollisionShape_getName(btCollisionShape* obj);
int btCollisionShape_getShapeType(btCollisionShape* obj);
int btCollisionShape_getUserIndex(btCollisionShape* obj);
void* btCollisionShape_getUserPointer(btCollisionShape* obj);
bool btCollisionShape_isCompound(btCollisionShape* obj);
bool btCollisionShape_isConcave(btCollisionShape* obj);
bool btCollisionShape_isConvex(btCollisionShape* obj);
bool btCollisionShape_isConvex2d(btCollisionShape* obj);
bool btCollisionShape_isInfinite(btCollisionShape* obj);
bool btCollisionShape_isNonMoving(btCollisionShape* obj);
bool btCollisionShape_isPolyhedral(btCollisionShape* obj);
bool btCollisionShape_isSoftBody(btCollisionShape* obj);
const char* btCollisionShape_serialize(btCollisionShape* obj, void* dataBuffer, btSerializer* serializer);
void btCollisionShape_serializeSingleShape(btCollisionShape* obj, btSerializer* serializer);
void btCollisionShape_setLocalScaling(btCollisionShape* obj, const btScalar* scaling);
void btCollisionShape_setMargin(btCollisionShape* obj, btScalar margin);
void btCollisionShape_setUserIndex(btCollisionShape* obj, int index);
void btCollisionShape_setUserPointer(btCollisionShape* obj, void* userPtr);
void btCollisionShape_delete(btCollisionShape* obj);
btCollisionWorld_AllHitsRayResultCallback* btCollisionWorld_AllHitsRayResultCallback_new(const btScalar* rayFromWorld, const btScalar* rayToWorld);
btAlignedCollisionObjectArray* btCollisionWorld_AllHitsRayResultCallback_getCollisionObjects(btCollisionWorld_AllHitsRayResultCallback* obj);
btAlignedScalarArray* btCollisionWorld_AllHitsRayResultCallback_getHitFractions(btCollisionWorld_AllHitsRayResultCallback* obj);
btAlignedVector3Array* btCollisionWorld_AllHitsRayResultCallback_getHitNormalWorld(btCollisionWorld_AllHitsRayResultCallback* obj);
btAlignedVector3Array* btCollisionWorld_AllHitsRayResultCallback_getHitPointWorld(btCollisionWorld_AllHitsRayResultCallback* obj);
void btCollisionWorld_AllHitsRayResultCallback_getRayFromWorld(btCollisionWorld_AllHitsRayResultCallback* obj, btScalar* value);
void btCollisionWorld_AllHitsRayResultCallback_getRayToWorld(btCollisionWorld_AllHitsRayResultCallback* obj, btScalar* value);
void btCollisionWorld_AllHitsRayResultCallback_setRayFromWorld(btCollisionWorld_AllHitsRayResultCallback* obj, const btScalar* value);
void btCollisionWorld_AllHitsRayResultCallback_setRayToWorld(btCollisionWorld_AllHitsRayResultCallback* obj, const btScalar* value);
btCollisionWorld_ClosestConvexResultCallback* btCollisionWorld_ClosestConvexResultCallback_new(const btScalar* convexFromWorld, const btScalar* convexToWorld);
void btCollisionWorld_ClosestConvexResultCallback_getConvexFromWorld(btCollisionWorld_ClosestConvexResultCallback* obj, btScalar* value);
void btCollisionWorld_ClosestConvexResultCallback_getConvexToWorld(btCollisionWorld_ClosestConvexResultCallback* obj, btScalar* value);
const btCollisionObject* btCollisionWorld_ClosestConvexResultCallback_getHitCollisionObject(btCollisionWorld_ClosestConvexResultCallback* obj);
void btCollisionWorld_ClosestConvexResultCallback_getHitNormalWorld(btCollisionWorld_ClosestConvexResultCallback* obj, btScalar* value);
void btCollisionWorld_ClosestConvexResultCallback_getHitPointWorld(btCollisionWorld_ClosestConvexResultCallback* obj, btScalar* value);
void btCollisionWorld_ClosestConvexResultCallback_setConvexFromWorld(btCollisionWorld_ClosestConvexResultCallback* obj, const btScalar* value);
void btCollisionWorld_ClosestConvexResultCallback_setConvexToWorld(btCollisionWorld_ClosestConvexResultCallback* obj, const btScalar* value);
void btCollisionWorld_ClosestConvexResultCallback_setHitCollisionObject(btCollisionWorld_ClosestConvexResultCallback* obj, const btCollisionObject* value);
void btCollisionWorld_ClosestConvexResultCallback_setHitNormalWorld(btCollisionWorld_ClosestConvexResultCallback* obj, const btScalar* value);
void btCollisionWorld_ClosestConvexResultCallback_setHitPointWorld(btCollisionWorld_ClosestConvexResultCallback* obj, const btScalar* value);
btCollisionWorld_ClosestRayResultCallback* btCollisionWorld_ClosestRayResultCallback_new(const btScalar* rayFromWorld, const btScalar* rayToWorld);
void btCollisionWorld_ClosestRayResultCallback_getHitNormalWorld(btCollisionWorld_ClosestRayResultCallback* obj, btScalar* value);
void btCollisionWorld_ClosestRayResultCallback_getHitPointWorld(btCollisionWorld_ClosestRayResultCallback* obj, btScalar* value);
void btCollisionWorld_ClosestRayResultCallback_getRayFromWorld(btCollisionWorld_ClosestRayResultCallback* obj, btScalar* value);
void btCollisionWorld_ClosestRayResultCallback_getRayToWorld(btCollisionWorld_ClosestRayResultCallback* obj, btScalar* value);
void btCollisionWorld_ClosestRayResultCallback_setHitNormalWorld(btCollisionWorld_ClosestRayResultCallback* obj, const btScalar* value);
void btCollisionWorld_ClosestRayResultCallback_setHitPointWorld(btCollisionWorld_ClosestRayResultCallback* obj, const btScalar* value);
void btCollisionWorld_ClosestRayResultCallback_setRayFromWorld(btCollisionWorld_ClosestRayResultCallback* obj, const btScalar* value);
void btCollisionWorld_ClosestRayResultCallback_setRayToWorld(btCollisionWorld_ClosestRayResultCallback* obj, const btScalar* value);
btCollisionWorld_ContactResultCallbackWrapper* btCollisionWorld_ContactResultCallbackWrapper_new(pContactResultCallback_AddSingleResult addSingleResultCallback, pContactResultCallback_NeedsCollision needsCollisionCallback);
bool btCollisionWorld_ContactResultCallbackWrapper_needsCollision(btCollisionWorld_ContactResultCallbackWrapper* obj, btBroadphaseProxy* proxy0);
btScalar btCollisionWorld_ContactResultCallback_addSingleResult(btCollisionWorld_ContactResultCallback* obj, btManifoldPoint* cp, const btCollisionObjectWrapper* colObj0Wrap, int partId0, int index0, const btCollisionObjectWrapper* colObj1Wrap, int partId1, int index1);
short btCollisionWorld_ContactResultCallback_getCollisionFilterGroup(btCollisionWorld_ContactResultCallback* obj);
short btCollisionWorld_ContactResultCallback_getCollisionFilterMask(btCollisionWorld_ContactResultCallback* obj);
bool btCollisionWorld_ContactResultCallback_needsCollision(btCollisionWorld_ContactResultCallback* obj, btBroadphaseProxy* proxy0);
void btCollisionWorld_ContactResultCallback_setCollisionFilterGroup(btCollisionWorld_ContactResultCallback* obj, short value);
void btCollisionWorld_ContactResultCallback_setCollisionFilterMask(btCollisionWorld_ContactResultCallback* obj, short value);
void btCollisionWorld_ContactResultCallback_delete(btCollisionWorld_ContactResultCallback* obj);
btCollisionWorld_ConvexResultCallbackWrapper* btCollisionWorld_ConvexResultCallbackWrapper_new(pConvexResultCallback_AddSingleResult addSingleResultCallback, pConvexResultCallback_NeedsCollision needsCollisionCallback);
bool btCollisionWorld_ConvexResultCallbackWrapper_needsCollision(btCollisionWorld_ConvexResultCallbackWrapper* obj, btBroadphaseProxy* proxy0);
btScalar btCollisionWorld_ConvexResultCallback_addSingleResult(btCollisionWorld_ConvexResultCallback* obj, btCollisionWorld_LocalConvexResult* convexResult, bool normalInWorldSpace);
btScalar btCollisionWorld_ConvexResultCallback_getClosestHitFraction(btCollisionWorld_ConvexResultCallback* obj);
short btCollisionWorld_ConvexResultCallback_getCollisionFilterGroup(btCollisionWorld_ConvexResultCallback* obj);
short btCollisionWorld_ConvexResultCallback_getCollisionFilterMask(btCollisionWorld_ConvexResultCallback* obj);
bool btCollisionWorld_ConvexResultCallback_hasHit(btCollisionWorld_ConvexResultCallback* obj);
bool btCollisionWorld_ConvexResultCallback_needsCollision(btCollisionWorld_ConvexResultCallback* obj, btBroadphaseProxy* proxy0);
void btCollisionWorld_ConvexResultCallback_setClosestHitFraction(btCollisionWorld_ConvexResultCallback* obj, btScalar value);
void btCollisionWorld_ConvexResultCallback_setCollisionFilterGroup(btCollisionWorld_ConvexResultCallback* obj, short value);
void btCollisionWorld_ConvexResultCallback_setCollisionFilterMask(btCollisionWorld_ConvexResultCallback* obj, short value);
void btCollisionWorld_ConvexResultCallback_delete(btCollisionWorld_ConvexResultCallback* obj);
btCollisionWorld_LocalConvexResult* btCollisionWorld_LocalConvexResult_new(const btCollisionObject* hitCollisionObject, btCollisionWorld_LocalShapeInfo* localShapeInfo, const btScalar* hitNormalLocal, const btScalar* hitPointLocal, btScalar hitFraction);
const btCollisionObject* btCollisionWorld_LocalConvexResult_getHitCollisionObject(btCollisionWorld_LocalConvexResult* obj);
btScalar btCollisionWorld_LocalConvexResult_getHitFraction(btCollisionWorld_LocalConvexResult* obj);
void btCollisionWorld_LocalConvexResult_getHitNormalLocal(btCollisionWorld_LocalConvexResult* obj, btScalar* value);
void btCollisionWorld_LocalConvexResult_getHitPointLocal(btCollisionWorld_LocalConvexResult* obj, btScalar* value);
btCollisionWorld_LocalShapeInfo* btCollisionWorld_LocalConvexResult_getLocalShapeInfo(btCollisionWorld_LocalConvexResult* obj);
void btCollisionWorld_LocalConvexResult_setHitCollisionObject(btCollisionWorld_LocalConvexResult* obj, const btCollisionObject* value);
void btCollisionWorld_LocalConvexResult_setHitFraction(btCollisionWorld_LocalConvexResult* obj, btScalar value);
void btCollisionWorld_LocalConvexResult_setHitNormalLocal(btCollisionWorld_LocalConvexResult* obj, const btScalar* value);
void btCollisionWorld_LocalConvexResult_setHitPointLocal(btCollisionWorld_LocalConvexResult* obj, const btScalar* value);
void btCollisionWorld_LocalConvexResult_setLocalShapeInfo(btCollisionWorld_LocalConvexResult* obj, btCollisionWorld_LocalShapeInfo* value);
void btCollisionWorld_LocalConvexResult_delete(btCollisionWorld_LocalConvexResult* obj);
btCollisionWorld_LocalRayResult* btCollisionWorld_LocalRayResult_new(const btCollisionObject* collisionObject, btCollisionWorld_LocalShapeInfo* localShapeInfo, const btScalar* hitNormalLocal, btScalar hitFraction);
const btCollisionObject* btCollisionWorld_LocalRayResult_getCollisionObject(btCollisionWorld_LocalRayResult* obj);
btScalar btCollisionWorld_LocalRayResult_getHitFraction(btCollisionWorld_LocalRayResult* obj);
void btCollisionWorld_LocalRayResult_getHitNormalLocal(btCollisionWorld_LocalRayResult* obj, btScalar* value);
btCollisionWorld_LocalShapeInfo* btCollisionWorld_LocalRayResult_getLocalShapeInfo(btCollisionWorld_LocalRayResult* obj);
void btCollisionWorld_LocalRayResult_setCollisionObject(btCollisionWorld_LocalRayResult* obj, const btCollisionObject* value);
void btCollisionWorld_LocalRayResult_setHitFraction(btCollisionWorld_LocalRayResult* obj, btScalar value);
void btCollisionWorld_LocalRayResult_setHitNormalLocal(btCollisionWorld_LocalRayResult* obj, const btScalar* value);
void btCollisionWorld_LocalRayResult_setLocalShapeInfo(btCollisionWorld_LocalRayResult* obj, btCollisionWorld_LocalShapeInfo* value);
void btCollisionWorld_LocalRayResult_delete(btCollisionWorld_LocalRayResult* obj);
btCollisionWorld_LocalShapeInfo* btCollisionWorld_LocalShapeInfo_new();
int btCollisionWorld_LocalShapeInfo_getShapePart(btCollisionWorld_LocalShapeInfo* obj);
int btCollisionWorld_LocalShapeInfo_getTriangleIndex(btCollisionWorld_LocalShapeInfo* obj);
void btCollisionWorld_LocalShapeInfo_setShapePart(btCollisionWorld_LocalShapeInfo* obj, int value);
void btCollisionWorld_LocalShapeInfo_setTriangleIndex(btCollisionWorld_LocalShapeInfo* obj, int value);
void btCollisionWorld_LocalShapeInfo_delete(btCollisionWorld_LocalShapeInfo* obj);
btCollisionWorld_RayResultCallbackWrapper* btCollisionWorld_RayResultCallbackWrapper_new(pRayResultCallback_AddSingleResult addSingleResultCallback, pRayResultCallback_NeedsCollision needsCollisionCallback);
bool btCollisionWorld_RayResultCallbackWrapper_needsCollision(btCollisionWorld_RayResultCallbackWrapper* obj, btBroadphaseProxy* proxy0);
btScalar btCollisionWorld_RayResultCallback_addSingleResult(btCollisionWorld_RayResultCallback* obj, btCollisionWorld_LocalRayResult* rayResult, bool normalInWorldSpace);
btScalar btCollisionWorld_RayResultCallback_getClosestHitFraction(btCollisionWorld_RayResultCallback* obj);
short btCollisionWorld_RayResultCallback_getCollisionFilterGroup(btCollisionWorld_RayResultCallback* obj);
short btCollisionWorld_RayResultCallback_getCollisionFilterMask(btCollisionWorld_RayResultCallback* obj);
const btCollisionObject* btCollisionWorld_RayResultCallback_getCollisionObject(btCollisionWorld_RayResultCallback* obj);
unsigned int btCollisionWorld_RayResultCallback_getFlags(btCollisionWorld_RayResultCallback* obj);
bool btCollisionWorld_RayResultCallback_hasHit(btCollisionWorld_RayResultCallback* obj);
bool btCollisionWorld_RayResultCallback_needsCollision(btCollisionWorld_RayResultCallback* obj, btBroadphaseProxy* proxy0);
void btCollisionWorld_RayResultCallback_setClosestHitFraction(btCollisionWorld_RayResultCallback* obj, btScalar value);
void btCollisionWorld_RayResultCallback_setCollisionFilterGroup(btCollisionWorld_RayResultCallback* obj, short value);
void btCollisionWorld_RayResultCallback_setCollisionFilterMask(btCollisionWorld_RayResultCallback* obj, short value);
void btCollisionWorld_RayResultCallback_setCollisionObject(btCollisionWorld_RayResultCallback* obj, const btCollisionObject* value);
void btCollisionWorld_RayResultCallback_setFlags(btCollisionWorld_RayResultCallback* obj, unsigned int value);
void btCollisionWorld_RayResultCallback_delete(btCollisionWorld_RayResultCallback* obj);
btCollisionWorld* btCollisionWorld_new(btDispatcher* dispatcher, btBroadphaseInterface* broadphasePairCache, btCollisionConfiguration* collisionConfiguration);
void btCollisionWorld_addCollisionObject(btCollisionWorld* obj, btCollisionObject* collisionObject);
void btCollisionWorld_addCollisionObject2(btCollisionWorld* obj, btCollisionObject* collisionObject, short collisionFilterGroup);
void btCollisionWorld_addCollisionObject3(btCollisionWorld* obj, btCollisionObject* collisionObject, short collisionFilterGroup, short collisionFilterMask);
void btCollisionWorld_computeOverlappingPairs(btCollisionWorld* obj);
void btCollisionWorld_contactPairTest(btCollisionWorld* obj, btCollisionObject* colObjA, btCollisionObject* colObjB, btCollisionWorld_ContactResultCallback* resultCallback);
void btCollisionWorld_contactTest(btCollisionWorld* obj, btCollisionObject* colObj, btCollisionWorld_ContactResultCallback* resultCallback);
void btCollisionWorld_convexSweepTest(btCollisionWorld* obj, const btConvexShape* castShape, const btScalar* from, const btScalar* to, btCollisionWorld_ConvexResultCallback* resultCallback);
void btCollisionWorld_convexSweepTest2(btCollisionWorld* obj, const btConvexShape* castShape, const btScalar* from, const btScalar* to, btCollisionWorld_ConvexResultCallback* resultCallback, btScalar allowedCcdPenetration);
void btCollisionWorld_debugDrawObject(btCollisionWorld* obj, const btScalar* worldTransform, const btCollisionShape* shape, const btScalar* color);
void btCollisionWorld_debugDrawWorld(btCollisionWorld* obj);
btBroadphaseInterface* btCollisionWorld_getBroadphase(btCollisionWorld* obj);
const btCollisionObjectArray* btCollisionWorld_getCollisionObjectArray(btCollisionWorld* obj);
btIDebugDraw* btCollisionWorld_getDebugDrawer(btCollisionWorld* obj);
const btDispatcher* btCollisionWorld_getDispatcher(btCollisionWorld* obj);
const btDispatcherInfo* btCollisionWorld_getDispatchInfo(btCollisionWorld* obj);
bool btCollisionWorld_getForceUpdateAllAabbs(btCollisionWorld* obj);
int btCollisionWorld_getNumCollisionObjects(btCollisionWorld* obj);
btOverlappingPairCache* btCollisionWorld_getPairCache(btCollisionWorld* obj);
void btCollisionWorld_objectQuerySingle(const btConvexShape* castShape, const btScalar* rayFromTrans, const btScalar* rayToTrans, btCollisionObject* collisionObject, const btCollisionShape* collisionShape, const btScalar* colObjWorldTransform, btCollisionWorld_ConvexResultCallback* resultCallback, btScalar allowedPenetration);
void btCollisionWorld_objectQuerySingleInternal(const btConvexShape* castShape, const btScalar* convexFromTrans, const btScalar* convexToTrans, const btCollisionObjectWrapper* colObjWrap, btCollisionWorld_ConvexResultCallback* resultCallback, btScalar allowedPenetration);
void btCollisionWorld_performDiscreteCollisionDetection(btCollisionWorld* obj);
void btCollisionWorld_rayTest(btCollisionWorld* obj, const btScalar* rayFromWorld, const btScalar* rayToWorld, btCollisionWorld_RayResultCallback* resultCallback);
void btCollisionWorld_rayTestSingle(const btScalar* rayFromTrans, const btScalar* rayToTrans, btCollisionObject* collisionObject, const btCollisionShape* collisionShape, const btScalar* colObjWorldTransform, btCollisionWorld_RayResultCallback* resultCallback);
void btCollisionWorld_rayTestSingleInternal(const btScalar* rayFromTrans, const btScalar* rayToTrans, const btCollisionObjectWrapper* collisionObjectWrap, btCollisionWorld_RayResultCallback* resultCallback);
void btCollisionWorld_removeCollisionObject(btCollisionWorld* obj, btCollisionObject* collisionObject);
void btCollisionWorld_serialize(btCollisionWorld* obj, btSerializer* serializer);
void btCollisionWorld_setBroadphase(btCollisionWorld* obj, btBroadphaseInterface* pairCache);
void btCollisionWorld_setDebugDrawer(btCollisionWorld* obj, btIDebugDraw* debugDrawer);
void btCollisionWorld_setForceUpdateAllAabbs(btCollisionWorld* obj, bool forceUpdateAllAabbs);
void btCollisionWorld_updateAabbs(btCollisionWorld* obj);
void btCollisionWorld_updateSingleAabb(btCollisionWorld* obj, btCollisionObject* colObj);
void btCollisionWorld_delete(btCollisionWorld* obj);
btCompoundCollisionAlgorithm_CreateFunc* btCompoundCollisionAlgorithm_CreateFunc_new();
btCompoundCollisionAlgorithm_SwappedCreateFunc* btCompoundCollisionAlgorithm_SwappedCreateFunc_new();
btCompoundCollisionAlgorithm* btCompoundCollisionAlgorithm_new(const btCollisionAlgorithmConstructionInfo* ci, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, bool isSwapped);
btCollisionAlgorithm* btCompoundCollisionAlgorithm_getChildAlgorithm(btCompoundCollisionAlgorithm* obj, int n);
btCompoundCompoundCollisionAlgorithm_CreateFunc* btCompoundCompoundCollisionAlgorithm_CreateFunc_new();
btCompoundCompoundCollisionAlgorithm_SwappedCreateFunc* btCompoundCompoundCollisionAlgorithm_SwappedCreateFunc_new();
btCompoundCompoundCollisionAlgorithm* btCompoundCompoundCollisionAlgorithm_new(const btCollisionAlgorithmConstructionInfo* ci, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, bool isSwapped);
btCompoundShape* btCompoundFromGImpact_btCreateCompoundFromGimpactShape(const btGImpactMeshShape* gimpactMesh, btScalar depth);
btCompoundShapeChild* btCompoundShapeChild_new();
btScalar btCompoundShapeChild_getChildMargin(btCompoundShapeChild* obj);
btCollisionShape* btCompoundShapeChild_getChildShape(btCompoundShapeChild* obj);
int btCompoundShapeChild_getChildShapeType(btCompoundShapeChild* obj);
btDbvtNode* btCompoundShapeChild_getNode(btCompoundShapeChild* obj);
void btCompoundShapeChild_getTransform(btCompoundShapeChild* obj, btScalar* value);
void btCompoundShapeChild_setChildMargin(btCompoundShapeChild* obj, btScalar value);
void btCompoundShapeChild_setChildShape(btCompoundShapeChild* obj, btCollisionShape* value);
void btCompoundShapeChild_setChildShapeType(btCompoundShapeChild* obj, int value);
void btCompoundShapeChild_setNode(btCompoundShapeChild* obj, btDbvtNode* value);
void btCompoundShapeChild_setTransform(btCompoundShapeChild* obj, const btScalar* value);
void btCompoundShapeChild_delete(btCompoundShapeChild* obj);
btCompoundShape* btCompoundShape_new();
btCompoundShape* btCompoundShape_new2(bool enableDynamicAabbTree);
void btCompoundShape_addChildShape(btCompoundShape* obj, const btScalar* localTransform, btCollisionShape* shape);
void btCompoundShape_calculatePrincipalAxisTransform(btCompoundShape* obj, btScalar* masses, btScalar* principal, btScalar* inertia);
void btCompoundShape_createAabbTreeFromChildren(btCompoundShape* obj);
btCompoundShapeChild* btCompoundShape_getChildList(btCompoundShape* obj);
const btCollisionShape* btCompoundShape_getChildShape(btCompoundShape* obj, int index);
void btCompoundShape_getChildTransform(btCompoundShape* obj, int index, btScalar* value);
btDbvt* btCompoundShape_getDynamicAabbTree(btCompoundShape* obj);
int btCompoundShape_getNumChildShapes(btCompoundShape* obj);
int btCompoundShape_getUpdateRevision(btCompoundShape* obj);
void btCompoundShape_recalculateLocalAabb(btCompoundShape* obj);
void btCompoundShape_removeChildShape(btCompoundShape* obj, btCollisionShape* shape);
void btCompoundShape_removeChildShapeByIndex(btCompoundShape* obj, int childShapeindex);
void btCompoundShape_updateChildTransform(btCompoundShape* obj, int childIndex, const btScalar* newChildTransform);
void btCompoundShape_updateChildTransform2(btCompoundShape* obj, int childIndex, const btScalar* newChildTransform, bool shouldRecalculateLocalAabb);
void btConcaveShape_processAllTriangles(btConcaveShape* obj, btTriangleCallback* callback, const btScalar* aabbMin, const btScalar* aabbMax);
btConeShape* btConeShape_new(btScalar radius, btScalar height);
int btConeShape_getConeUpIndex(btConeShape* obj);
btScalar btConeShape_getHeight(btConeShape* obj);
btScalar btConeShape_getRadius(btConeShape* obj);
void btConeShape_setConeUpIndex(btConeShape* obj, int upIndex);
btConeShapeX* btConeShapeX_new(btScalar radius, btScalar height);
btConeShapeZ* btConeShapeZ_new(btScalar radius, btScalar height);
btConeTwistConstraint* btConeTwistConstraint_new(btRigidBody* rbA, btRigidBody* rbB, const btScalar* rbAFrame, const btScalar* rbBFrame);
btConeTwistConstraint* btConeTwistConstraint_new2(btRigidBody* rbA, const btScalar* rbAFrame);
void btConeTwistConstraint_calcAngleInfo(btConeTwistConstraint* obj);
void btConeTwistConstraint_calcAngleInfo2(btConeTwistConstraint* obj, const btScalar* transA, const btScalar* transB, const btScalar* invInertiaWorldA, const btScalar* invInertiaWorldB);
void btConeTwistConstraint_enableMotor(btConeTwistConstraint* obj, bool b);
void btConeTwistConstraint_getAFrame(btConeTwistConstraint* obj, btScalar* value);
void btConeTwistConstraint_getBFrame(btConeTwistConstraint* obj, btScalar* value);
btScalar btConeTwistConstraint_getFixThresh(btConeTwistConstraint* obj);
void btConeTwistConstraint_getFrameOffsetA(btConeTwistConstraint* obj, btScalar* value);
void btConeTwistConstraint_getFrameOffsetB(btConeTwistConstraint* obj, btScalar* value);
void btConeTwistConstraint_getInfo1NonVirtual(btConeTwistConstraint* obj, btTypedConstraint_btConstraintInfo1* info);
void btConeTwistConstraint_getInfo2NonVirtual(btConeTwistConstraint* obj, btTypedConstraint_btConstraintInfo2* info, const btScalar* transA, const btScalar* transB, const btScalar* invInertiaWorldA, const btScalar* invInertiaWorldB);
void btConeTwistConstraint_GetPointForAngle(btConeTwistConstraint* obj, btScalar fAngleInRadians, btScalar fLength, btScalar* value);
int btConeTwistConstraint_getSolveSwingLimit(btConeTwistConstraint* obj);
int btConeTwistConstraint_getSolveTwistLimit(btConeTwistConstraint* obj);
btScalar btConeTwistConstraint_getSwingSpan1(btConeTwistConstraint* obj);
btScalar btConeTwistConstraint_getSwingSpan2(btConeTwistConstraint* obj);
btScalar btConeTwistConstraint_getTwistAngle(btConeTwistConstraint* obj);
btScalar btConeTwistConstraint_getTwistLimitSign(btConeTwistConstraint* obj);
btScalar btConeTwistConstraint_getTwistSpan(btConeTwistConstraint* obj);
bool btConeTwistConstraint_isPastSwingLimit(btConeTwistConstraint* obj);
void btConeTwistConstraint_setAngularOnly(btConeTwistConstraint* obj, bool angularOnly);
void btConeTwistConstraint_setDamping(btConeTwistConstraint* obj, btScalar damping);
void btConeTwistConstraint_setFixThresh(btConeTwistConstraint* obj, btScalar fixThresh);
void btConeTwistConstraint_setFrames(btConeTwistConstraint* obj, const btScalar* frameA, const btScalar* frameB);
void btConeTwistConstraint_setLimit(btConeTwistConstraint* obj, btScalar _swingSpan1, btScalar _swingSpan2, btScalar _twistSpan);
void btConeTwistConstraint_setLimit2(btConeTwistConstraint* obj, btScalar _swingSpan1, btScalar _swingSpan2, btScalar _twistSpan, btScalar _softness);
void btConeTwistConstraint_setLimit3(btConeTwistConstraint* obj, btScalar _swingSpan1, btScalar _swingSpan2, btScalar _twistSpan, btScalar _softness, btScalar _biasFactor);
void btConeTwistConstraint_setLimit4(btConeTwistConstraint* obj, btScalar _swingSpan1, btScalar _swingSpan2, btScalar _twistSpan, btScalar _softness, btScalar _biasFactor, btScalar _relaxationFactor);
void btConeTwistConstraint_setLimit5(btConeTwistConstraint* obj, int limitIndex, btScalar limitValue);
void btConeTwistConstraint_setMaxMotorImpulse(btConeTwistConstraint* obj, btScalar maxMotorImpulse);
void btConeTwistConstraint_setMaxMotorImpulseNormalized(btConeTwistConstraint* obj, btScalar maxMotorImpulse);
void btConeTwistConstraint_setMotorTarget(btConeTwistConstraint* obj, const btScalar* q);
void btConeTwistConstraint_setMotorTargetInConstraintSpace(btConeTwistConstraint* obj, const btScalar* q);
void btConeTwistConstraint_updateRHS(btConeTwistConstraint* obj, btScalar timeStep);
void btConstraintSolver_allSolved(btConstraintSolver* obj, const btContactSolverInfo* __unnamed0, btIDebugDraw* __unnamed1);
btConstraintSolverType btConstraintSolver_getSolverType(btConstraintSolver* obj);
void btConstraintSolver_prepareSolve(btConstraintSolver* obj, int __unnamed0, int __unnamed1);
void btConstraintSolver_reset(btConstraintSolver* obj);
void btConstraintSolver_delete(btConstraintSolver* obj);
const btPersistentManifold* btContactConstraint_getContactManifold(btContactConstraint* obj);
void btContactConstraint_setContactManifold(btContactConstraint* obj, btPersistentManifold* contactManifold);
btContactSolverInfoData* btContactSolverInfoData_new();
btScalar btContactSolverInfoData_getDamping(btContactSolverInfoData* obj);
btScalar btContactSolverInfoData_getErp(btContactSolverInfoData* obj);
btScalar btContactSolverInfoData_getErp2(btContactSolverInfoData* obj);
btScalar btContactSolverInfoData_getFriction(btContactSolverInfoData* obj);
btScalar btContactSolverInfoData_getGlobalCfm(btContactSolverInfoData* obj);
btScalar btContactSolverInfoData_getLinearSlop(btContactSolverInfoData* obj);
btScalar btContactSolverInfoData_getMaxErrorReduction(btContactSolverInfoData* obj);
btScalar btContactSolverInfoData_getMaxGyroscopicForce(btContactSolverInfoData* obj);
int btContactSolverInfoData_getMinimumSolverBatchSize(btContactSolverInfoData* obj);
int btContactSolverInfoData_getNumIterations(btContactSolverInfoData* obj);
int btContactSolverInfoData_getRestingContactRestitutionThreshold(btContactSolverInfoData* obj);
btScalar btContactSolverInfoData_getRestitution(btContactSolverInfoData* obj);
btScalar btContactSolverInfoData_getSingleAxisRollingFrictionThreshold(btContactSolverInfoData* obj);
int btContactSolverInfoData_getSolverMode(btContactSolverInfoData* obj);
btScalar btContactSolverInfoData_getSor(btContactSolverInfoData* obj);
int btContactSolverInfoData_getSplitImpulse(btContactSolverInfoData* obj);
btScalar btContactSolverInfoData_getSplitImpulsePenetrationThreshold(btContactSolverInfoData* obj);
btScalar btContactSolverInfoData_getSplitImpulseTurnErp(btContactSolverInfoData* obj);
btScalar btContactSolverInfoData_getTau(btContactSolverInfoData* obj);
btScalar btContactSolverInfoData_getTimeStep(btContactSolverInfoData* obj);
btScalar btContactSolverInfoData_getWarmstartingFactor(btContactSolverInfoData* obj);
void btContactSolverInfoData_setDamping(btContactSolverInfoData* obj, btScalar value);
void btContactSolverInfoData_setErp(btContactSolverInfoData* obj, btScalar value);
void btContactSolverInfoData_setErp2(btContactSolverInfoData* obj, btScalar value);
void btContactSolverInfoData_setFriction(btContactSolverInfoData* obj, btScalar value);
void btContactSolverInfoData_setGlobalCfm(btContactSolverInfoData* obj, btScalar value);
void btContactSolverInfoData_setLinearSlop(btContactSolverInfoData* obj, btScalar value);
void btContactSolverInfoData_setMaxErrorReduction(btContactSolverInfoData* obj, btScalar value);
void btContactSolverInfoData_setMaxGyroscopicForce(btContactSolverInfoData* obj, btScalar value);
void btContactSolverInfoData_setMinimumSolverBatchSize(btContactSolverInfoData* obj, int value);
void btContactSolverInfoData_setNumIterations(btContactSolverInfoData* obj, int value);
void btContactSolverInfoData_setRestingContactRestitutionThreshold(btContactSolverInfoData* obj, int value);
void btContactSolverInfoData_setRestitution(btContactSolverInfoData* obj, btScalar value);
void btContactSolverInfoData_setSingleAxisRollingFrictionThreshold(btContactSolverInfoData* obj, btScalar value);
void btContactSolverInfoData_setSolverMode(btContactSolverInfoData* obj, int value);
void btContactSolverInfoData_setSor(btContactSolverInfoData* obj, btScalar value);
void btContactSolverInfoData_setSplitImpulse(btContactSolverInfoData* obj, int value);
void btContactSolverInfoData_setSplitImpulsePenetrationThreshold(btContactSolverInfoData* obj, btScalar value);
void btContactSolverInfoData_setSplitImpulseTurnErp(btContactSolverInfoData* obj, btScalar value);
void btContactSolverInfoData_setTau(btContactSolverInfoData* obj, btScalar value);
void btContactSolverInfoData_setTimeStep(btContactSolverInfoData* obj, btScalar value);
void btContactSolverInfoData_setWarmstartingFactor(btContactSolverInfoData* obj, btScalar value);
void btContactSolverInfoData_delete(btContactSolverInfoData* obj);
btContactSolverInfo* btContactSolverInfo_new();
btContinuousConvexCollision* btContinuousConvexCollision_new(const btConvexShape* shapeA, const btConvexShape* shapeB, btVoronoiSimplexSolver* simplexSolver, btConvexPenetrationDepthSolver* penetrationDepthSolver);
btContinuousConvexCollision* btContinuousConvexCollision_new2(const btConvexShape* shapeA, const btStaticPlaneShape* plane);
btConvex2dConvex2dAlgorithm_CreateFunc* btConvex2dConvex2dAlgorithm_CreateFunc_new(btVoronoiSimplexSolver* simplexSolver, btConvexPenetrationDepthSolver* pdSolver);
int btConvex2dConvex2dAlgorithm_CreateFunc_getMinimumPointsPerturbationThreshold(btConvex2dConvex2dAlgorithm_CreateFunc* obj);
int btConvex2dConvex2dAlgorithm_CreateFunc_getNumPerturbationIterations(btConvex2dConvex2dAlgorithm_CreateFunc* obj);
btConvexPenetrationDepthSolver* btConvex2dConvex2dAlgorithm_CreateFunc_getPdSolver(btConvex2dConvex2dAlgorithm_CreateFunc* obj);
btVoronoiSimplexSolver* btConvex2dConvex2dAlgorithm_CreateFunc_getSimplexSolver(btConvex2dConvex2dAlgorithm_CreateFunc* obj);
void btConvex2dConvex2dAlgorithm_CreateFunc_setMinimumPointsPerturbationThreshold(btConvex2dConvex2dAlgorithm_CreateFunc* obj, int value);
void btConvex2dConvex2dAlgorithm_CreateFunc_setNumPerturbationIterations(btConvex2dConvex2dAlgorithm_CreateFunc* obj, int value);
void btConvex2dConvex2dAlgorithm_CreateFunc_setPdSolver(btConvex2dConvex2dAlgorithm_CreateFunc* obj, btConvexPenetrationDepthSolver* value);
void btConvex2dConvex2dAlgorithm_CreateFunc_setSimplexSolver(btConvex2dConvex2dAlgorithm_CreateFunc* obj, btVoronoiSimplexSolver* value);
btConvex2dConvex2dAlgorithm* btConvex2dConvex2dAlgorithm_new(btPersistentManifold* mf, const btCollisionAlgorithmConstructionInfo* ci, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, btVoronoiSimplexSolver* simplexSolver, btConvexPenetrationDepthSolver* pdSolver, int numPerturbationIterations, int minimumPointsPerturbationThreshold);
const btPersistentManifold* btConvex2dConvex2dAlgorithm_getManifold(btConvex2dConvex2dAlgorithm* obj);
void btConvex2dConvex2dAlgorithm_setLowLevelOfDetail(btConvex2dConvex2dAlgorithm* obj, bool useLowLevel);
btConvex2dShape* btConvex2dShape_new(btConvexShape* convexChildShape);
const btConvexShape* btConvex2dShape_getChildShape(btConvex2dShape* obj);
btConvexCast_CastResult* btConvexCast_CastResult_new();
void btConvexCast_CastResult_DebugDraw(btConvexCast_CastResult* obj, btScalar fraction);
void btConvexCast_CastResult_drawCoordSystem(btConvexCast_CastResult* obj, const btScalar* trans);
btScalar btConvexCast_CastResult_getAllowedPenetration(btConvexCast_CastResult* obj);
btIDebugDraw* btConvexCast_CastResult_getDebugDrawer(btConvexCast_CastResult* obj);
btScalar btConvexCast_CastResult_getFraction(btConvexCast_CastResult* obj);
void btConvexCast_CastResult_getHitPoint(btConvexCast_CastResult* obj, btScalar* value);
void btConvexCast_CastResult_getHitTransformA(btConvexCast_CastResult* obj, btScalar* value);
void btConvexCast_CastResult_getHitTransformB(btConvexCast_CastResult* obj, btScalar* value);
void btConvexCast_CastResult_getNormal(btConvexCast_CastResult* obj, btScalar* value);
void btConvexCast_CastResult_reportFailure(btConvexCast_CastResult* obj, int errNo, int numIterations);
void btConvexCast_CastResult_setAllowedPenetration(btConvexCast_CastResult* obj, btScalar value);
void btConvexCast_CastResult_setDebugDrawer(btConvexCast_CastResult* obj, btIDebugDraw* value);
void btConvexCast_CastResult_setFraction(btConvexCast_CastResult* obj, btScalar value);
void btConvexCast_CastResult_setHitPoint(btConvexCast_CastResult* obj, const btScalar* value);
void btConvexCast_CastResult_setHitTransformA(btConvexCast_CastResult* obj, const btScalar* value);
void btConvexCast_CastResult_setHitTransformB(btConvexCast_CastResult* obj, const btScalar* value);
void btConvexCast_CastResult_setNormal(btConvexCast_CastResult* obj, const btScalar* value);
void btConvexCast_CastResult_delete(btConvexCast_CastResult* obj);
bool btConvexCast_calcTimeOfImpact(btConvexCast* obj, const btScalar* fromA, const btScalar* toA, const btScalar* fromB, const btScalar* toB, btConvexCast_CastResult* result);
void btConvexCast_delete(btConvexCast* obj);
btConvexTriangleCallback* btConvexTriangleCallback_new(btDispatcher* dispatcher, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, bool isSwapped);
void btConvexTriangleCallback_clearCache(btConvexTriangleCallback* obj);
void btConvexTriangleCallback_clearWrapperData(btConvexTriangleCallback* obj);
void btConvexTriangleCallback_getAabbMax(btConvexTriangleCallback* obj, btScalar* value);
void btConvexTriangleCallback_getAabbMin(btConvexTriangleCallback* obj, btScalar* value);
btPersistentManifold* btConvexTriangleCallback_getManifoldPtr(btConvexTriangleCallback* obj);
int btConvexTriangleCallback_getTriangleCount(btConvexTriangleCallback* obj);
void btConvexTriangleCallback_setManifoldPtr(btConvexTriangleCallback* obj, btPersistentManifold* value);
void btConvexTriangleCallback_setTimeStepAndCounters(btConvexTriangleCallback* obj, btScalar collisionMarginTriangle, const btDispatcherInfo* dispatchInfo, const btCollisionObjectWrapper* convexBodyWrap, const btCollisionObjectWrapper* triBodyWrap, btManifoldResult* resultOut);
void btConvexTriangleCallback_setTriangleCount(btConvexTriangleCallback* obj, int value);
btConvexConcaveCollisionAlgorithm_CreateFunc* btConvexConcaveCollisionAlgorithm_CreateFunc_new();
btConvexConcaveCollisionAlgorithm_SwappedCreateFunc* btConvexConcaveCollisionAlgorithm_SwappedCreateFunc_new();
btConvexConcaveCollisionAlgorithm* btConvexConcaveCollisionAlgorithm_new(const btCollisionAlgorithmConstructionInfo* ci, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, bool isSwapped);
void btConvexConcaveCollisionAlgorithm_clearCache(btConvexConcaveCollisionAlgorithm* obj);
btConvexConvexAlgorithm_CreateFunc* btConvexConvexAlgorithm_CreateFunc_new(btVoronoiSimplexSolver* simplexSolver, btConvexPenetrationDepthSolver* pdSolver);
int btConvexConvexAlgorithm_CreateFunc_getMinimumPointsPerturbationThreshold(btConvexConvexAlgorithm_CreateFunc* obj);
int btConvexConvexAlgorithm_CreateFunc_getNumPerturbationIterations(btConvexConvexAlgorithm_CreateFunc* obj);
btConvexPenetrationDepthSolver* btConvexConvexAlgorithm_CreateFunc_getPdSolver(btConvexConvexAlgorithm_CreateFunc* obj);
btVoronoiSimplexSolver* btConvexConvexAlgorithm_CreateFunc_getSimplexSolver(btConvexConvexAlgorithm_CreateFunc* obj);
void btConvexConvexAlgorithm_CreateFunc_setMinimumPointsPerturbationThreshold(btConvexConvexAlgorithm_CreateFunc* obj, int value);
void btConvexConvexAlgorithm_CreateFunc_setNumPerturbationIterations(btConvexConvexAlgorithm_CreateFunc* obj, int value);
void btConvexConvexAlgorithm_CreateFunc_setPdSolver(btConvexConvexAlgorithm_CreateFunc* obj, btConvexPenetrationDepthSolver* value);
void btConvexConvexAlgorithm_CreateFunc_setSimplexSolver(btConvexConvexAlgorithm_CreateFunc* obj, btVoronoiSimplexSolver* value);
btConvexConvexAlgorithm* btConvexConvexAlgorithm_new(btPersistentManifold* mf, const btCollisionAlgorithmConstructionInfo* ci, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, btVoronoiSimplexSolver* simplexSolver, btConvexPenetrationDepthSolver* pdSolver, int numPerturbationIterations, int minimumPointsPerturbationThreshold);
const btPersistentManifold* btConvexConvexAlgorithm_getManifold(btConvexConvexAlgorithm* obj);
void btConvexConvexAlgorithm_setLowLevelOfDetail(btConvexConvexAlgorithm* obj, bool useLowLevel);
btConvexHullShape* btConvexHullShape_new();
btConvexHullShape* btConvexHullShape_new2(const btScalar* points);
btConvexHullShape* btConvexHullShape_new3(const btScalar* points, int numPoints);
btConvexHullShape* btConvexHullShape_new4(const btScalar* points, int numPoints, int stride);
void btConvexHullShape_addPoint(btConvexHullShape* obj, const btScalar* point);
void btConvexHullShape_addPoint2(btConvexHullShape* obj, const btScalar* point, bool recalculateLocalAabb);
int btConvexHullShape_getNumPoints(btConvexHullShape* obj);
const btVector3* btConvexHullShape_getPoints(btConvexHullShape* obj);
void btConvexHullShape_getScaledPoint(btConvexHullShape* obj, int i, btScalar* value);
const btVector3* btConvexHullShape_getUnscaledPoints(btConvexHullShape* obj);
void btConvexHullShape_project(btConvexHullShape* obj, const btScalar* trans, const btScalar* dir, btScalar* minProj, btScalar* maxProj, btScalar* witnesPtMin, btScalar* witnesPtMax);
btConvexInternalShape* btConvexInternalShape_new();
void btConvexInternalShape_getImplicitShapeDimensions(btConvexInternalShape* obj, btScalar* dimensions);
void btConvexInternalShape_getLocalScalingNV(btConvexInternalShape* obj, btScalar* value);
btScalar btConvexInternalShape_getMarginNV(btConvexInternalShape* obj);
void btConvexInternalShape_setImplicitShapeDimensions(btConvexInternalShape* obj, const btScalar* dimensions);
void btConvexInternalShape_setSafeMargin(btConvexInternalShape* obj, btScalar minDimension);
void btConvexInternalShape_setSafeMargin2(btConvexInternalShape* obj, btScalar minDimension, btScalar defaultMarginMultiplier);
void btConvexInternalShape_setSafeMargin3(btConvexInternalShape* obj, const btScalar* halfExtents);
void btConvexInternalShape_setSafeMargin4(btConvexInternalShape* obj, const btScalar* halfExtents, btScalar defaultMarginMultiplier);
btConvexInternalAabbCachingShape* btConvexInternalAabbCachingShape_new();
void btConvexInternalAabbCachingShape_recalcLocalAabb(btConvexInternalAabbCachingShape* obj);
bool btConvexPenetrationDepthSolver_calcPenDepth(btConvexPenetrationDepthSolver* obj, btVoronoiSimplexSolver* simplexSolver, const btConvexShape* convexA, const btConvexShape* convexB, const btScalar* transA, const btScalar* transB, btScalar* v, btScalar* pa, btScalar* pb, btIDebugDraw* debugDraw);
void btConvexPenetrationDepthSolver_delete(btConvexPenetrationDepthSolver* obj);
btConvexPlaneCollisionAlgorithm_CreateFunc* btConvexPlaneCollisionAlgorithm_CreateFunc_new();
int btConvexPlaneCollisionAlgorithm_CreateFunc_getMinimumPointsPerturbationThreshold(btConvexPlaneCollisionAlgorithm_CreateFunc* obj);
int btConvexPlaneCollisionAlgorithm_CreateFunc_getNumPerturbationIterations(btConvexPlaneCollisionAlgorithm_CreateFunc* obj);
void btConvexPlaneCollisionAlgorithm_CreateFunc_setMinimumPointsPerturbationThreshold(btConvexPlaneCollisionAlgorithm_CreateFunc* obj, int value);
void btConvexPlaneCollisionAlgorithm_CreateFunc_setNumPerturbationIterations(btConvexPlaneCollisionAlgorithm_CreateFunc* obj, int value);
btConvexPlaneCollisionAlgorithm* btConvexPlaneCollisionAlgorithm_new(btPersistentManifold* mf, const btCollisionAlgorithmConstructionInfo* ci, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, bool isSwapped, int numPerturbationIterations, int minimumPointsPerturbationThreshold);
void btConvexPlaneCollisionAlgorithm_collideSingleContact(btConvexPlaneCollisionAlgorithm* obj, const btScalar* perturbeRot, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, const btDispatcherInfo* dispatchInfo, btManifoldResult* resultOut);
btConvexPointCloudShape* btConvexPointCloudShape_new();
btConvexPointCloudShape* btConvexPointCloudShape_new2(btVector3* points, int numPoints, const btScalar* localScaling);
btConvexPointCloudShape* btConvexPointCloudShape_new3(btVector3* points, int numPoints, const btScalar* localScaling, bool computeAabb);
int btConvexPointCloudShape_getNumPoints(btConvexPointCloudShape* obj);
void btConvexPointCloudShape_getScaledPoint(btConvexPointCloudShape* obj, int index, btScalar* value);
btVector3* btConvexPointCloudShape_getUnscaledPoints(btConvexPointCloudShape* obj);
void btConvexPointCloudShape_setPoints(btConvexPointCloudShape* obj, btVector3* points, int numPoints);
void btConvexPointCloudShape_setPoints2(btConvexPointCloudShape* obj, btVector3* points, int numPoints, bool computeAabb);
void btConvexPointCloudShape_setPoints3(btConvexPointCloudShape* obj, btVector3* points, int numPoints, bool computeAabb, const btScalar* localScaling);
btFace* btFace_new();
btAlignedIntArray* btFace_getIndices(btFace* obj);
btScalar* btFace_getPlane(btFace* obj);
void btFace_delete(btFace* obj);
btConvexPolyhedron* btConvexPolyhedron_new();
void btConvexPolyhedron_getExtents(btConvexPolyhedron* obj, btScalar* value);
btAlignedFaceArray* btConvexPolyhedron_getFaces(btConvexPolyhedron* obj);
void btConvexPolyhedron_getLocalCenter(btConvexPolyhedron* obj, btScalar* value);
void btConvexPolyhedron_getMC(btConvexPolyhedron* obj, btScalar* value);
void btConvexPolyhedron_getME(btConvexPolyhedron* obj, btScalar* value);
btScalar btConvexPolyhedron_getRadius(btConvexPolyhedron* obj);
btAlignedVector3Array* btConvexPolyhedron_getUniqueEdges(btConvexPolyhedron* obj);
btAlignedVector3Array* btConvexPolyhedron_getVertices(btConvexPolyhedron* obj);
void btConvexPolyhedron_initialize(btConvexPolyhedron* obj);
void btConvexPolyhedron_project(btConvexPolyhedron* obj, const btScalar* trans, const btScalar* dir, btScalar* minProj, btScalar* maxProj, btScalar* witnesPtMin, btScalar* witnesPtMax);
void btConvexPolyhedron_setExtents(btConvexPolyhedron* obj, const btScalar* value);
void btConvexPolyhedron_setLocalCenter(btConvexPolyhedron* obj, const btScalar* value);
void btConvexPolyhedron_setMC(btConvexPolyhedron* obj, const btScalar* value);
void btConvexPolyhedron_setME(btConvexPolyhedron* obj, const btScalar* value);
void btConvexPolyhedron_setRadius(btConvexPolyhedron* obj, btScalar value);
bool btConvexPolyhedron_testContainment(btConvexPolyhedron* obj);
void btConvexPolyhedron_delete(btConvexPolyhedron* obj);
void btConvexShape_batchedUnitVectorGetSupportingVertexWithoutMargin(btConvexShape* obj, const btVector3* vectors, btVector3* supportVerticesOut, int numVectors);
void btConvexShape_getAabbNonVirtual(btConvexShape* obj, const btScalar* t, btScalar* aabbMin, btScalar* aabbMax);
void btConvexShape_getAabbSlow(btConvexShape* obj, const btScalar* t, btScalar* aabbMin, btScalar* aabbMax);
btScalar btConvexShape_getMarginNonVirtual(btConvexShape* obj);
int btConvexShape_getNumPreferredPenetrationDirections(btConvexShape* obj);
void btConvexShape_getPreferredPenetrationDirection(btConvexShape* obj, int index, btScalar* penetrationVector);
void btConvexShape_localGetSupportingVertex(btConvexShape* obj, const btScalar* vec, btScalar* value);
void btConvexShape_localGetSupportingVertexWithoutMargin(btConvexShape* obj, const btScalar* vec, btScalar* value);
void btConvexShape_localGetSupportVertexNonVirtual(btConvexShape* obj, const btScalar* vec, btScalar* value);
void btConvexShape_localGetSupportVertexWithoutMarginNonVirtual(btConvexShape* obj, const btScalar* vec, btScalar* value);
void btConvexShape_project(btConvexShape* obj, const btScalar* trans, const btScalar* dir, btScalar* min, btScalar* max);
btConvexTriangleMeshShape* btConvexTriangleMeshShape_new(btStridingMeshInterface* meshInterface);
btConvexTriangleMeshShape* btConvexTriangleMeshShape_new2(btStridingMeshInterface* meshInterface, bool calcAabb);
void btConvexTriangleMeshShape_calculatePrincipalAxisTransform(btConvexTriangleMeshShape* obj, btScalar* principal, btScalar* inertia, btScalar* volume);
const btStridingMeshInterface* btConvexTriangleMeshShape_getMeshInterface(btConvexTriangleMeshShape* obj);
btCylinderShape* btCylinderShape_new(const btScalar* halfExtents);
btCylinderShape* btCylinderShape_new2(btScalar halfExtentX, btScalar halfExtentY, btScalar halfExtentZ);
void btCylinderShape_getHalfExtentsWithMargin(btCylinderShape* obj, btScalar* value);
void btCylinderShape_getHalfExtentsWithoutMargin(btCylinderShape* obj, btScalar* value);
btScalar btCylinderShape_getRadius(btCylinderShape* obj);
int btCylinderShape_getUpAxis(btCylinderShape* obj);
btCylinderShapeX* btCylinderShapeX_new(const btScalar* halfExtents);
btCylinderShapeX* btCylinderShapeX_new2(btScalar halfExtentX, btScalar halfExtentY, btScalar halfExtentZ);
btCylinderShapeZ* btCylinderShapeZ_new(const btScalar* halfExtents);
btCylinderShapeZ* btCylinderShapeZ_new2(btScalar halfExtentX, btScalar halfExtentY, btScalar halfExtentZ);
btDantzigSolver* btDantzigSolver_new();
btDbvtProxy* btDbvtProxy_new(const btScalar* aabbMin, const btScalar* aabbMax, void* userPtr, short collisionFilterGroup, short collisionFilterMask);
btDbvtNode* btDbvtProxy_getLeaf(btDbvtProxy* obj);
btDbvtProxy** btDbvtProxy_getLinks(btDbvtProxy* obj);
int btDbvtProxy_getStage(btDbvtProxy* obj);
void btDbvtProxy_setLeaf(btDbvtProxy* obj, btDbvtNode* value);
void btDbvtProxy_setStage(btDbvtProxy* obj, int value);
btDbvtBroadphase* btDbvtBroadphase_new();
btDbvtBroadphase* btDbvtBroadphase_new2(btOverlappingPairCache* paircache);
void btDbvtBroadphase_benchmark(btBroadphaseInterface* __unnamed0);
void btDbvtBroadphase_collide(btDbvtBroadphase* obj, btDispatcher* dispatcher);
int btDbvtBroadphase_getCid(btDbvtBroadphase* obj);
int btDbvtBroadphase_getCupdates(btDbvtBroadphase* obj);
bool btDbvtBroadphase_getDeferedcollide(btDbvtBroadphase* obj);
int btDbvtBroadphase_getDupdates(btDbvtBroadphase* obj);
int btDbvtBroadphase_getFixedleft(btDbvtBroadphase* obj);
int btDbvtBroadphase_getFupdates(btDbvtBroadphase* obj);
int btDbvtBroadphase_getGid(btDbvtBroadphase* obj);
bool btDbvtBroadphase_getNeedcleanup(btDbvtBroadphase* obj);
int btDbvtBroadphase_getNewpairs(btDbvtBroadphase* obj);
btOverlappingPairCache* btDbvtBroadphase_getPaircache(btDbvtBroadphase* obj);
int btDbvtBroadphase_getPid(btDbvtBroadphase* obj);
btScalar btDbvtBroadphase_getPrediction(btDbvtBroadphase* obj);
bool btDbvtBroadphase_getReleasepaircache(btDbvtBroadphase* obj);
btDbvt* btDbvtBroadphase_getSets(btDbvtBroadphase* obj);
int btDbvtBroadphase_getStageCurrent(btDbvtBroadphase* obj);
btDbvtProxy** btDbvtBroadphase_getStageRoots(btDbvtBroadphase* obj);
unsigned int btDbvtBroadphase_getUpdates_call(btDbvtBroadphase* obj);
unsigned int btDbvtBroadphase_getUpdates_done(btDbvtBroadphase* obj);
btScalar btDbvtBroadphase_getUpdates_ratio(btDbvtBroadphase* obj);
btScalar btDbvtBroadphase_getVelocityPrediction(btDbvtBroadphase* obj);
void btDbvtBroadphase_optimize(btDbvtBroadphase* obj);
void btDbvtBroadphase_performDeferredRemoval(btDbvtBroadphase* obj, btDispatcher* dispatcher);
void btDbvtBroadphase_setAabbForceUpdate(btDbvtBroadphase* obj, btBroadphaseProxy* absproxy, const btScalar* aabbMin, const btScalar* aabbMax, btDispatcher* __unnamed3);
void btDbvtBroadphase_setCid(btDbvtBroadphase* obj, int value);
void btDbvtBroadphase_setCupdates(btDbvtBroadphase* obj, int value);
void btDbvtBroadphase_setDeferedcollide(btDbvtBroadphase* obj, bool value);
void btDbvtBroadphase_setDupdates(btDbvtBroadphase* obj, int value);
void btDbvtBroadphase_setFixedleft(btDbvtBroadphase* obj, int value);
void btDbvtBroadphase_setFupdates(btDbvtBroadphase* obj, int value);
void btDbvtBroadphase_setGid(btDbvtBroadphase* obj, int value);
void btDbvtBroadphase_setNeedcleanup(btDbvtBroadphase* obj, bool value);
void btDbvtBroadphase_setNewpairs(btDbvtBroadphase* obj, int value);
void btDbvtBroadphase_setPaircache(btDbvtBroadphase* obj, btOverlappingPairCache* value);
void btDbvtBroadphase_setPid(btDbvtBroadphase* obj, int value);
void btDbvtBroadphase_setPrediction(btDbvtBroadphase* obj, btScalar value);
void btDbvtBroadphase_setReleasepaircache(btDbvtBroadphase* obj, bool value);
void btDbvtBroadphase_setStageCurrent(btDbvtBroadphase* obj, int value);
void btDbvtBroadphase_setUpdates_call(btDbvtBroadphase* obj, unsigned int value);
void btDbvtBroadphase_setUpdates_done(btDbvtBroadphase* obj, unsigned int value);
void btDbvtBroadphase_setUpdates_ratio(btDbvtBroadphase* obj, btScalar value);
void btDbvtBroadphase_setVelocityPrediction(btDbvtBroadphase* obj, btScalar prediction);
btDbvtAabbMm* btDbvtAabbMm_new();
void btDbvtAabbMm_Center(btDbvtAabbMm* obj, btScalar* value);
int btDbvtAabbMm_Classify(btDbvtAabbMm* obj, const btScalar* n, btScalar o, int s);
bool btDbvtAabbMm_Contain(btDbvtAabbMm* obj, const btDbvtAabbMm* a);
void btDbvtAabbMm_Expand(btDbvtAabbMm* obj, const btScalar* e);
void btDbvtAabbMm_Extents(btDbvtAabbMm* obj, btScalar* value);
btDbvtAabbMm* btDbvtAabbMm_FromCE(const btScalar* c, const btScalar* e);
btDbvtAabbMm* btDbvtAabbMm_FromCR(const btScalar* c, btScalar r);
btDbvtAabbMm* btDbvtAabbMm_FromMM(const btScalar* mi, const btScalar* mx);
btDbvtAabbMm* btDbvtAabbMm_FromPoints(const btVector3** ppts, int n);
btDbvtAabbMm* btDbvtAabbMm_FromPoints2(const btVector3* pts, int n);
void btDbvtAabbMm_Lengths(btDbvtAabbMm* obj, btScalar* value);
void btDbvtAabbMm_Maxs(btDbvtAabbMm* obj, btScalar* value);
void btDbvtAabbMm_Mins(btDbvtAabbMm* obj, btScalar* value);
btScalar btDbvtAabbMm_ProjectMinimum(btDbvtAabbMm* obj, const btScalar* v, unsigned int signs);
void btDbvtAabbMm_SignedExpand(btDbvtAabbMm* obj, const btScalar* e);
void btDbvtAabbMm_tMaxs(btDbvtAabbMm* obj, btScalar* value);
void btDbvtAabbMm_tMins(btDbvtAabbMm* obj, btScalar* value);
void btDbvtAabbMm_delete(btDbvtAabbMm* obj);
btDbvtNode* btDbvtNode_new();
btDbvtNode** btDbvtNode_getChilds(btDbvtNode* obj);
void* btDbvtNode_getData(btDbvtNode* obj);
int btDbvtNode_getDataAsInt(btDbvtNode* obj);
btDbvtNode* btDbvtNode_getParent(btDbvtNode* obj);
btDbvtVolume* btDbvtNode_getVolume(btDbvtNode* obj);
bool btDbvtNode_isinternal(btDbvtNode* obj);
bool btDbvtNode_isleaf(btDbvtNode* obj);
void btDbvtNode_setData(btDbvtNode* obj, void* value);
void btDbvtNode_setDataAsInt(btDbvtNode* obj, int value);
void btDbvtNode_setParent(btDbvtNode* obj, btDbvtNode* value);
void btDbvtNode_delete(btDbvtNode* obj);
btDbvt_IClone* btDbvt_IClone_new();
void btDbvt_IClone_CloneLeaf(btDbvt_IClone* obj, btDbvtNode* __unnamed0);
void btDbvt_IClone_delete(btDbvt_IClone* obj);
btDbvt_ICollide* btDbvt_ICollide_new();
bool btDbvt_ICollide_AllLeaves(btDbvt_ICollide* obj, const btDbvtNode* __unnamed0);
bool btDbvt_ICollide_Descent(btDbvt_ICollide* obj, const btDbvtNode* __unnamed0);
void btDbvt_ICollide_Process(btDbvt_ICollide* obj, const btDbvtNode* __unnamed0, const btDbvtNode* __unnamed1);
void btDbvt_ICollide_Process2(btDbvt_ICollide* obj, const btDbvtNode* __unnamed0);
void btDbvt_ICollide_Process3(btDbvt_ICollide* obj, const btDbvtNode* n, btScalar __unnamed1);
void btDbvt_ICollide_delete(btDbvt_ICollide* obj);
void btDbvt_IWriter_Prepare(btDbvt_IWriter* obj, const btDbvtNode* root, int numnodes);
void btDbvt_IWriter_WriteLeaf(btDbvt_IWriter* obj, const btDbvtNode* __unnamed0, int index, int parent);
void btDbvt_IWriter_WriteNode(btDbvt_IWriter* obj, const btDbvtNode* __unnamed0, int index, int parent, int child0, int child1);
void btDbvt_IWriter_delete(btDbvt_IWriter* obj);
btDbvt_sStkCLN* btDbvt_sStkCLN_new(const btDbvtNode* n, btDbvtNode* p);
const btDbvtNode* btDbvt_sStkCLN_getNode(btDbvt_sStkCLN* obj);
btDbvtNode* btDbvt_sStkCLN_getParent(btDbvt_sStkCLN* obj);
void btDbvt_sStkCLN_setNode(btDbvt_sStkCLN* obj, const btDbvtNode* value);
void btDbvt_sStkCLN_setParent(btDbvt_sStkCLN* obj, btDbvtNode* value);
void btDbvt_sStkCLN_delete(btDbvt_sStkCLN* obj);
btDbvt_sStkNN* btDbvt_sStkNN_new();
btDbvt_sStkNN* btDbvt_sStkNN_new2(const btDbvtNode* na, const btDbvtNode* nb);
const btDbvtNode* btDbvt_sStkNN_getA(btDbvt_sStkNN* obj);
const btDbvtNode* btDbvt_sStkNN_getB(btDbvt_sStkNN* obj);
void btDbvt_sStkNN_setA(btDbvt_sStkNN* obj, const btDbvtNode* value);
void btDbvt_sStkNN_setB(btDbvt_sStkNN* obj, const btDbvtNode* value);
void btDbvt_sStkNN_delete(btDbvt_sStkNN* obj);
btDbvt_sStkNP* btDbvt_sStkNP_new(const btDbvtNode* n, unsigned int m);
int btDbvt_sStkNP_getMask(btDbvt_sStkNP* obj);
const btDbvtNode* btDbvt_sStkNP_getNode(btDbvt_sStkNP* obj);
void btDbvt_sStkNP_setMask(btDbvt_sStkNP* obj, int value);
void btDbvt_sStkNP_setNode(btDbvt_sStkNP* obj, const btDbvtNode* value);
void btDbvt_sStkNP_delete(btDbvt_sStkNP* obj);
btDbvt_sStkNPS* btDbvt_sStkNPS_new();
btDbvt_sStkNPS* btDbvt_sStkNPS_new2(const btDbvtNode* n, unsigned int m, btScalar v);
int btDbvt_sStkNPS_getMask(btDbvt_sStkNPS* obj);
const btDbvtNode* btDbvt_sStkNPS_getNode(btDbvt_sStkNPS* obj);
btScalar btDbvt_sStkNPS_getValue(btDbvt_sStkNPS* obj);
void btDbvt_sStkNPS_setMask(btDbvt_sStkNPS* obj, int value);
void btDbvt_sStkNPS_setNode(btDbvt_sStkNPS* obj, const btDbvtNode* value);
void btDbvt_sStkNPS_setValue(btDbvt_sStkNPS* obj, btScalar value);
void btDbvt_sStkNPS_delete(btDbvt_sStkNPS* obj);
btDbvt* btDbvt_new();
int btDbvt_allocate(btAlignedIntArray* ifree, btAlignedStkNpsArray* stock, const btDbvt_sStkNPS* value);
void btDbvt_benchmark();
void btDbvt_clear(btDbvt* obj);
void btDbvt_clone(btDbvt* obj, btDbvt* dest);
void btDbvt_clone2(btDbvt* obj, btDbvt* dest, btDbvt_IClone* iclone);
void btDbvt_collideKDOP(const btDbvtNode* root, const btVector3* normals, const btScalar* offsets, int count, const btDbvt_ICollide* policy);
void btDbvt_collideOCL(const btDbvtNode* root, const btVector3* normals, const btScalar* offsets, const btScalar* sortaxis, int count, const btDbvt_ICollide* policy);
void btDbvt_collideOCL2(const btDbvtNode* root, const btVector3* normals, const btScalar* offsets, const btScalar* sortaxis, int count, const btDbvt_ICollide* policy, bool fullsort);
void btDbvt_collideTT(btDbvt* obj, const btDbvtNode* root0, const btDbvtNode* root1, const btDbvt_ICollide* policy);
void btDbvt_collideTTpersistentStack(btDbvt* obj, const btDbvtNode* root0, const btDbvtNode* root1, const btDbvt_ICollide* policy);
void btDbvt_collideTU(const btDbvtNode* root, const btDbvt_ICollide* policy);
void btDbvt_collideTV(btDbvt* obj, const btDbvtNode* root, const btDbvtVolume* volume, const btDbvt_ICollide* policy);
int btDbvt_countLeaves(const btDbvtNode* node);
bool btDbvt_empty(btDbvt* obj);
void btDbvt_enumLeaves(const btDbvtNode* root, const btDbvt_ICollide* policy);
void btDbvt_enumNodes(const btDbvtNode* root, const btDbvt_ICollide* policy);
void btDbvt_extractLeaves(const btDbvtNode* node, btAlignedDbvtNodeArray* leaves);
btDbvtNode* btDbvt_getFree(btDbvt* obj);
int btDbvt_getLeaves(btDbvt* obj);
int btDbvt_getLkhd(btDbvt* obj);
unsigned int btDbvt_getOpath(btDbvt* obj);
btAlignedDbvtNodeArray* btDbvt_getRayTestStack(btDbvt* obj);
btDbvtNode* btDbvt_getRoot(btDbvt* obj);
btAlignedStkNNArray* btDbvt_getStkStack(btDbvt* obj);
btDbvtNode* btDbvt_insert(btDbvt* obj, const btDbvtVolume* box, void* data);
int btDbvt_maxdepth(const btDbvtNode* node);
int btDbvt_nearest(const int* i, const btDbvt_sStkNPS* a, btScalar v, int l, int h);
void btDbvt_optimizeBottomUp(btDbvt* obj);
void btDbvt_optimizeIncremental(btDbvt* obj, int passes);
void btDbvt_optimizeTopDown(btDbvt* obj);
void btDbvt_optimizeTopDown2(btDbvt* obj, int bu_treshold);
void btDbvt_rayTest(const btDbvtNode* root, const btScalar* rayFrom, const btScalar* rayTo, const btDbvt_ICollide* policy);
void btDbvt_rayTestInternal(btDbvt* obj, const btDbvtNode* root, const btScalar* rayFrom, const btScalar* rayTo, const btScalar* rayDirectionInverse, unsigned int* signs, btScalar lambda_max, const btScalar* aabbMin, const btScalar* aabbMax, const btDbvt_ICollide* policy);
void btDbvt_remove(btDbvt* obj, btDbvtNode* leaf);
void btDbvt_setFree(btDbvt* obj, btDbvtNode* value);
void btDbvt_setLeaves(btDbvt* obj, int value);
void btDbvt_setLkhd(btDbvt* obj, int value);
void btDbvt_setOpath(btDbvt* obj, unsigned int value);
void btDbvt_setRoot(btDbvt* obj, btDbvtNode* value);
void btDbvt_update(btDbvt* obj, btDbvtNode* leaf, btDbvtVolume* volume);
void btDbvt_update2(btDbvt* obj, btDbvtNode* leaf);
void btDbvt_update3(btDbvt* obj, btDbvtNode* leaf, int lookahead);
bool btDbvt_update4(btDbvt* obj, btDbvtNode* leaf, btDbvtVolume* volume, btScalar margin);
bool btDbvt_update5(btDbvt* obj, btDbvtNode* leaf, btDbvtVolume* volume, const btScalar* velocity);
bool btDbvt_update6(btDbvt* obj, btDbvtNode* leaf, btDbvtVolume* volume, const btScalar* velocity, btScalar margin);
void btDbvt_write(btDbvt* obj, btDbvt_IWriter* iwriter);
void btDbvt_delete(btDbvt* obj);
btDefaultCollisionConstructionInfo* btDefaultCollisionConstructionInfo_new();
btPoolAllocator* btDefaultCollisionConstructionInfo_getCollisionAlgorithmPool(btDefaultCollisionConstructionInfo* obj);
int btDefaultCollisionConstructionInfo_getCustomCollisionAlgorithmMaxElementSize(btDefaultCollisionConstructionInfo* obj);
int btDefaultCollisionConstructionInfo_getDefaultMaxCollisionAlgorithmPoolSize(btDefaultCollisionConstructionInfo* obj);
int btDefaultCollisionConstructionInfo_getDefaultMaxPersistentManifoldPoolSize(btDefaultCollisionConstructionInfo* obj);
btPoolAllocator* btDefaultCollisionConstructionInfo_getPersistentManifoldPool(btDefaultCollisionConstructionInfo* obj);
int btDefaultCollisionConstructionInfo_getUseEpaPenetrationAlgorithm(btDefaultCollisionConstructionInfo* obj);
void btDefaultCollisionConstructionInfo_setCollisionAlgorithmPool(btDefaultCollisionConstructionInfo* obj, btPoolAllocator* value);
void btDefaultCollisionConstructionInfo_setCustomCollisionAlgorithmMaxElementSize(btDefaultCollisionConstructionInfo* obj, int value);
void btDefaultCollisionConstructionInfo_setDefaultMaxCollisionAlgorithmPoolSize(btDefaultCollisionConstructionInfo* obj, int value);
void btDefaultCollisionConstructionInfo_setDefaultMaxPersistentManifoldPoolSize(btDefaultCollisionConstructionInfo* obj, int value);
void btDefaultCollisionConstructionInfo_setPersistentManifoldPool(btDefaultCollisionConstructionInfo* obj, btPoolAllocator* value);
void btDefaultCollisionConstructionInfo_setUseEpaPenetrationAlgorithm(btDefaultCollisionConstructionInfo* obj, int value);
void btDefaultCollisionConstructionInfo_delete(btDefaultCollisionConstructionInfo* obj);
btDefaultCollisionConfiguration* btDefaultCollisionConfiguration_new();
btDefaultCollisionConfiguration* btDefaultCollisionConfiguration_new2(const btDefaultCollisionConstructionInfo* constructionInfo);
btVoronoiSimplexSolver* btDefaultCollisionConfiguration_getSimplexSolver(btDefaultCollisionConfiguration* obj);
void btDefaultCollisionConfiguration_setConvexConvexMultipointIterations(btDefaultCollisionConfiguration* obj);
void btDefaultCollisionConfiguration_setConvexConvexMultipointIterations2(btDefaultCollisionConfiguration* obj, int numPerturbationIterations);
void btDefaultCollisionConfiguration_setConvexConvexMultipointIterations3(btDefaultCollisionConfiguration* obj, int numPerturbationIterations, int minimumPointsPerturbationThreshold);
void btDefaultCollisionConfiguration_setPlaneConvexMultipointIterations(btDefaultCollisionConfiguration* obj);
void btDefaultCollisionConfiguration_setPlaneConvexMultipointIterations2(btDefaultCollisionConfiguration* obj, int numPerturbationIterations);
void btDefaultCollisionConfiguration_setPlaneConvexMultipointIterations3(btDefaultCollisionConfiguration* obj, int numPerturbationIterations, int minimumPointsPerturbationThreshold);
btDefaultMotionState* btDefaultMotionState_new();
btDefaultMotionState* btDefaultMotionState_new2(const btScalar* startTrans);
btDefaultMotionState* btDefaultMotionState_new3(const btScalar* startTrans, const btScalar* centerOfMassOffset);
void btDefaultMotionState_getCenterOfMassOffset(btDefaultMotionState* obj, btScalar* value);
void btDefaultMotionState_getGraphicsWorldTrans(btDefaultMotionState* obj, btScalar* value);
void btDefaultMotionState_getStartWorldTrans(btDefaultMotionState* obj, btScalar* value);
void* btDefaultMotionState_getUserPointer(btDefaultMotionState* obj);
void btDefaultMotionState_setCenterOfMassOffset(btDefaultMotionState* obj, const btScalar* value);
void btDefaultMotionState_setGraphicsWorldTrans(btDefaultMotionState* obj, const btScalar* value);
void btDefaultMotionState_setStartWorldTrans(btDefaultMotionState* obj, const btScalar* value);
void btDefaultMotionState_setUserPointer(btDefaultMotionState* obj, void* value);
btDefaultSoftBodySolver* btDefaultSoftBodySolver_new();
void btDefaultSoftBodySolver_copySoftBodyToVertexBuffer(btDefaultSoftBodySolver* obj, const btSoftBody* softBody, btVertexBufferDescriptor* vertexBuffer);
btDiscreteCollisionDetectorInterface_ClosestPointInput* btDiscreteCollisionDetectorInterface_ClosestPointInput_new();
btScalar btDiscreteCollisionDetectorInterface_ClosestPointInput_getMaximumDistanceSquared(btDiscreteCollisionDetectorInterface_ClosestPointInput* obj);
void btDiscreteCollisionDetectorInterface_ClosestPointInput_getTransformA(btDiscreteCollisionDetectorInterface_ClosestPointInput* obj, btScalar* value);
void btDiscreteCollisionDetectorInterface_ClosestPointInput_getTransformB(btDiscreteCollisionDetectorInterface_ClosestPointInput* obj, btScalar* value);
void btDiscreteCollisionDetectorInterface_ClosestPointInput_setMaximumDistanceSquared(btDiscreteCollisionDetectorInterface_ClosestPointInput* obj, btScalar value);
void btDiscreteCollisionDetectorInterface_ClosestPointInput_setTransformA(btDiscreteCollisionDetectorInterface_ClosestPointInput* obj, const btScalar* value);
void btDiscreteCollisionDetectorInterface_ClosestPointInput_setTransformB(btDiscreteCollisionDetectorInterface_ClosestPointInput* obj, const btScalar* value);
void btDiscreteCollisionDetectorInterface_ClosestPointInput_delete(btDiscreteCollisionDetectorInterface_ClosestPointInput* obj);
void btDiscreteCollisionDetectorInterface_Result_addContactPoint(btDiscreteCollisionDetectorInterface_Result* obj, const btScalar* normalOnBInWorld, const btScalar* pointInWorld, btScalar depth);
void btDiscreteCollisionDetectorInterface_Result_setShapeIdentifiersA(btDiscreteCollisionDetectorInterface_Result* obj, int partId0, int index0);
void btDiscreteCollisionDetectorInterface_Result_setShapeIdentifiersB(btDiscreteCollisionDetectorInterface_Result* obj, int partId1, int index1);
void btDiscreteCollisionDetectorInterface_Result_delete(btDiscreteCollisionDetectorInterface_Result* obj);
void btDiscreteCollisionDetectorInterface_getClosestPoints(btDiscreteCollisionDetectorInterface* obj, const btDiscreteCollisionDetectorInterface_ClosestPointInput* input, btDiscreteCollisionDetectorInterface_Result* output, btIDebugDraw* debugDraw);
void btDiscreteCollisionDetectorInterface_getClosestPoints2(btDiscreteCollisionDetectorInterface* obj, const btDiscreteCollisionDetectorInterface_ClosestPointInput* input, btDiscreteCollisionDetectorInterface_Result* output, btIDebugDraw* debugDraw, bool swapResults);
void btDiscreteCollisionDetectorInterface_delete(btDiscreteCollisionDetectorInterface* obj);
btStorageResult* btStorageResult_new();
void btStorageResult_getClosestPointInB(btStorageResult* obj, btScalar* value);
btScalar btStorageResult_getDistance(btStorageResult* obj);
void btStorageResult_getNormalOnSurfaceB(btStorageResult* obj, btScalar* value);
void btStorageResult_setClosestPointInB(btStorageResult* obj, const btScalar* value);
void btStorageResult_setDistance(btStorageResult* obj, btScalar value);
void btStorageResult_setNormalOnSurfaceB(btStorageResult* obj, const btScalar* value);
btDiscreteDynamicsWorld* btDiscreteDynamicsWorld_new(btDispatcher* dispatcher, btBroadphaseInterface* pairCache, btConstraintSolver* constraintSolver, btCollisionConfiguration* collisionConfiguration);
void btDiscreteDynamicsWorld_applyGravity(btDiscreteDynamicsWorld* obj);
void btDiscreteDynamicsWorld_debugDrawConstraint(btDiscreteDynamicsWorld* obj, btTypedConstraint* constraint);
bool btDiscreteDynamicsWorld_getApplySpeculativeContactRestitution(btDiscreteDynamicsWorld* obj);
btCollisionWorld* btDiscreteDynamicsWorld_getCollisionWorld(btDiscreteDynamicsWorld* obj);
bool btDiscreteDynamicsWorld_getLatencyMotionStateInterpolation(btDiscreteDynamicsWorld* obj);
btSimulationIslandManager* btDiscreteDynamicsWorld_getSimulationIslandManager(btDiscreteDynamicsWorld* obj);
bool btDiscreteDynamicsWorld_getSynchronizeAllMotionStates(btDiscreteDynamicsWorld* obj);
void btDiscreteDynamicsWorld_setApplySpeculativeContactRestitution(btDiscreteDynamicsWorld* obj, bool enable);
void btDiscreteDynamicsWorld_setLatencyMotionStateInterpolation(btDiscreteDynamicsWorld* obj, bool latencyInterpolation);
void btDiscreteDynamicsWorld_setNumTasks(btDiscreteDynamicsWorld* obj, int numTasks);
void btDiscreteDynamicsWorld_setSynchronizeAllMotionStates(btDiscreteDynamicsWorld* obj, bool synchronizeAll);
void btDiscreteDynamicsWorld_synchronizeSingleMotionState(btDiscreteDynamicsWorld* obj, btRigidBody* body);
void btDiscreteDynamicsWorld_updateVehicles(btDiscreteDynamicsWorld* obj, btScalar timeStep);
btDispatcherInfo* btDispatcherInfo_new();
btScalar btDispatcherInfo_getAllowedCcdPenetration(btDispatcherInfo* obj);
btScalar btDispatcherInfo_getConvexConservativeDistanceThreshold(btDispatcherInfo* obj);
btIDebugDraw* btDispatcherInfo_getDebugDraw(btDispatcherInfo* obj);
int btDispatcherInfo_getDispatchFunc(btDispatcherInfo* obj);
bool btDispatcherInfo_getEnableSatConvex(btDispatcherInfo* obj);
bool btDispatcherInfo_getEnableSPU(btDispatcherInfo* obj);
int btDispatcherInfo_getStepCount(btDispatcherInfo* obj);
btScalar btDispatcherInfo_getTimeOfImpact(btDispatcherInfo* obj);
btScalar btDispatcherInfo_getTimeStep(btDispatcherInfo* obj);
bool btDispatcherInfo_getUseContinuous(btDispatcherInfo* obj);
bool btDispatcherInfo_getUseConvexConservativeDistanceUtil(btDispatcherInfo* obj);
bool btDispatcherInfo_getUseEpa(btDispatcherInfo* obj);
void btDispatcherInfo_setAllowedCcdPenetration(btDispatcherInfo* obj, btScalar value);
void btDispatcherInfo_setConvexConservativeDistanceThreshold(btDispatcherInfo* obj, btScalar value);
void btDispatcherInfo_setDebugDraw(btDispatcherInfo* obj, btIDebugDraw* value);
void btDispatcherInfo_setDispatchFunc(btDispatcherInfo* obj, int value);
void btDispatcherInfo_setEnableSatConvex(btDispatcherInfo* obj, bool value);
void btDispatcherInfo_setEnableSPU(btDispatcherInfo* obj, bool value);
void btDispatcherInfo_setStepCount(btDispatcherInfo* obj, int value);
void btDispatcherInfo_setTimeOfImpact(btDispatcherInfo* obj, btScalar value);
void btDispatcherInfo_setTimeStep(btDispatcherInfo* obj, btScalar value);
void btDispatcherInfo_setUseContinuous(btDispatcherInfo* obj, bool value);
void btDispatcherInfo_setUseConvexConservativeDistanceUtil(btDispatcherInfo* obj, bool value);
void btDispatcherInfo_setUseEpa(btDispatcherInfo* obj, bool value);
void btDispatcherInfo_delete(btDispatcherInfo* obj);
void* btDispatcher_allocateCollisionAlgorithm(btDispatcher* obj, int size);
void btDispatcher_clearManifold(btDispatcher* obj, btPersistentManifold* manifold);
void btDispatcher_dispatchAllCollisionPairs(btDispatcher* obj, btOverlappingPairCache* pairCache, const btDispatcherInfo* dispatchInfo, btDispatcher* dispatcher);
btCollisionAlgorithm* btDispatcher_findAlgorithm(btDispatcher* obj, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap);
btCollisionAlgorithm* btDispatcher_findAlgorithm2(btDispatcher* obj, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, btPersistentManifold* sharedManifold);
void btDispatcher_freeCollisionAlgorithm(btDispatcher* obj, void* ptr);
btPersistentManifold** btDispatcher_getInternalManifoldPointer(btDispatcher* obj);
btPoolAllocator* btDispatcher_getInternalManifoldPool(btDispatcher* obj);
btPersistentManifold* btDispatcher_getManifoldByIndexInternal(btDispatcher* obj, int index);
btPersistentManifold* btDispatcher_getNewManifold(btDispatcher* obj, const btCollisionObject* b0, const btCollisionObject* b1);
int btDispatcher_getNumManifolds(btDispatcher* obj);
bool btDispatcher_needsCollision(btDispatcher* obj, const btCollisionObject* body0, const btCollisionObject* body1);
bool btDispatcher_needsResponse(btDispatcher* obj, const btCollisionObject* body0, const btCollisionObject* body1);
void btDispatcher_releaseManifold(btDispatcher* obj, btPersistentManifold* manifold);
void btDispatcher_delete(btDispatcher* obj);
void btDynamicsWorld_addAction(btDynamicsWorld* obj, btActionInterface* action);
void btDynamicsWorld_addConstraint(btDynamicsWorld* obj, btTypedConstraint* constraint);
void btDynamicsWorld_addConstraint2(btDynamicsWorld* obj, btTypedConstraint* constraint, bool disableCollisionsBetweenLinkedBodies);
void btDynamicsWorld_addRigidBody(btDynamicsWorld* obj, btRigidBody* body);
void btDynamicsWorld_addRigidBody2(btDynamicsWorld* obj, btRigidBody* body, short group, short mask);
void btDynamicsWorld_clearForces(btDynamicsWorld* obj);
btTypedConstraint* btDynamicsWorld_getConstraint(btDynamicsWorld* obj, int index);
btConstraintSolver* btDynamicsWorld_getConstraintSolver(btDynamicsWorld* obj);
void btDynamicsWorld_getGravity(btDynamicsWorld* obj, btScalar* gravity);
int btDynamicsWorld_getNumConstraints(btDynamicsWorld* obj);
btContactSolverInfo* btDynamicsWorld_getSolverInfo(btDynamicsWorld* obj);
btDynamicsWorldType btDynamicsWorld_getWorldType(btDynamicsWorld* obj);
void* btDynamicsWorld_getWorldUserInfo(btDynamicsWorld* obj);
void btDynamicsWorld_removeAction(btDynamicsWorld* obj, btActionInterface* action);
void btDynamicsWorld_removeConstraint(btDynamicsWorld* obj, btTypedConstraint* constraint);
void btDynamicsWorld_removeRigidBody(btDynamicsWorld* obj, btRigidBody* body);
void btDynamicsWorld_setConstraintSolver(btDynamicsWorld* obj, btConstraintSolver* solver);
void btDynamicsWorld_setGravity(btDynamicsWorld* obj, const btScalar* gravity);
void btDynamicsWorld_setInternalTickCallback(btDynamicsWorld* obj, btInternalTickCallback cb);
void btDynamicsWorld_setInternalTickCallback2(btDynamicsWorld* obj, btInternalTickCallback cb, void* worldUserInfo);
void btDynamicsWorld_setInternalTickCallback3(btDynamicsWorld* obj, btInternalTickCallback cb, void* worldUserInfo, bool isPreTick);
void btDynamicsWorld_setWorldUserInfo(btDynamicsWorld* obj, void* worldUserInfo);
int btDynamicsWorld_stepSimulation(btDynamicsWorld* obj, btScalar timeStep);
int btDynamicsWorld_stepSimulation2(btDynamicsWorld* obj, btScalar timeStep, int maxSubSteps);
int btDynamicsWorld_stepSimulation3(btDynamicsWorld* obj, btScalar timeStep, int maxSubSteps, btScalar fixedTimeStep);
void btDynamicsWorld_synchronizeMotionStates(btDynamicsWorld* obj);
btEmptyAlgorithm_CreateFunc* btEmptyAlgorithm_CreateFunc_new();
btEmptyAlgorithm* btEmptyAlgorithm_new(const btCollisionAlgorithmConstructionInfo* ci);
btEmptyShape* btEmptyShape_new();
btFixedConstraint* btFixedConstraint_new(btRigidBody* rbA, btRigidBody* rbB, const btScalar* frameInA, const btScalar* frameInB);
GIM_PAIR* GIM_PAIR_new();
GIM_PAIR* GIM_PAIR_new2(const GIM_PAIR* p);
GIM_PAIR* GIM_PAIR_new3(int index1, int index2);
int GIM_PAIR_getIndex1(GIM_PAIR* obj);
int GIM_PAIR_getIndex2(GIM_PAIR* obj);
void GIM_PAIR_setIndex1(GIM_PAIR* obj, int value);
void GIM_PAIR_setIndex2(GIM_PAIR* obj, int value);
void GIM_PAIR_delete(GIM_PAIR* obj);
btPairSet* btPairSet_new();
void btPairSet_push_pair(btPairSet* obj, int index1, int index2);
void btPairSet_push_pair_inv(btPairSet* obj, int index1, int index2);
GIM_BVH_DATA* GIM_BVH_DATA_new();
btAABB* GIM_BVH_DATA_getBound(GIM_BVH_DATA* obj);
int GIM_BVH_DATA_getData(GIM_BVH_DATA* obj);
void GIM_BVH_DATA_setBound(GIM_BVH_DATA* obj, const btAABB* value);
void GIM_BVH_DATA_setData(GIM_BVH_DATA* obj, int value);
void GIM_BVH_DATA_delete(GIM_BVH_DATA* obj);
GIM_BVH_TREE_NODE* GIM_BVH_TREE_NODE_new();
btAABB* GIM_BVH_TREE_NODE_getBound(GIM_BVH_TREE_NODE* obj);
int GIM_BVH_TREE_NODE_getDataIndex(GIM_BVH_TREE_NODE* obj);
int GIM_BVH_TREE_NODE_getEscapeIndex(GIM_BVH_TREE_NODE* obj);
bool GIM_BVH_TREE_NODE_isLeafNode(GIM_BVH_TREE_NODE* obj);
void GIM_BVH_TREE_NODE_setBound(GIM_BVH_TREE_NODE* obj, const btAABB* value);
void GIM_BVH_TREE_NODE_setDataIndex(GIM_BVH_TREE_NODE* obj, int index);
void GIM_BVH_TREE_NODE_setEscapeIndex(GIM_BVH_TREE_NODE* obj, int index);
void GIM_BVH_TREE_NODE_delete(GIM_BVH_TREE_NODE* obj);
GIM_BVH_DATA_ARRAY* GIM_BVH_DATA_ARRAY_new();
GIM_BVH_TREE_NODE_ARRAY* GIM_BVH_TREE_NODE_ARRAY_new();
btBvhTree* btBvhTree_new();
void btBvhTree_build_tree(btBvhTree* obj, GIM_BVH_DATA_ARRAY* primitive_boxes);
void btBvhTree_clearNodes(btBvhTree* obj);
const GIM_BVH_TREE_NODE* btBvhTree_get_node_pointer(btBvhTree* obj);
const GIM_BVH_TREE_NODE* btBvhTree_get_node_pointer2(btBvhTree* obj, int index);
int btBvhTree_getEscapeNodeIndex(btBvhTree* obj, int nodeindex);
int btBvhTree_getLeftNode(btBvhTree* obj, int nodeindex);
void btBvhTree_getNodeBound(btBvhTree* obj, int nodeindex, btAABB* bound);
int btBvhTree_getNodeCount(btBvhTree* obj);
int btBvhTree_getNodeData(btBvhTree* obj, int nodeindex);
int btBvhTree_getRightNode(btBvhTree* obj, int nodeindex);
bool btBvhTree_isLeafNode(btBvhTree* obj, int nodeindex);
void btBvhTree_setNodeBound(btBvhTree* obj, int nodeindex, const btAABB* bound);
void btBvhTree_delete(btBvhTree* obj);
void btPrimitiveManagerBase_get_primitive_box(btPrimitiveManagerBase* obj, int prim_index, btAABB* primbox);
int btPrimitiveManagerBase_get_primitive_count(btPrimitiveManagerBase* obj);
void btPrimitiveManagerBase_get_primitive_triangle(btPrimitiveManagerBase* obj, int prim_index, btPrimitiveTriangle* triangle);
bool btPrimitiveManagerBase_is_trimesh(btPrimitiveManagerBase* obj);
void btPrimitiveManagerBase_delete(btPrimitiveManagerBase* obj);
btGImpactBvh* btGImpactBvh_new();
btGImpactBvh* btGImpactBvh_new2(btPrimitiveManagerBase* primitive_manager);
bool btGImpactBvh_boxQuery(btGImpactBvh* obj, const btAABB* box, btAlignedIntArray* collided_results);
bool btGImpactBvh_boxQueryTrans(btGImpactBvh* obj, const btAABB* box, const btScalar* transform, btAlignedIntArray* collided_results);
void btGImpactBvh_buildSet(btGImpactBvh* obj);
void btGImpactBvh_find_collision(btGImpactBvh* boxset1, const btScalar* trans1, btGImpactBvh* boxset2, const btScalar* trans2, btPairSet* collision_pairs);
const GIM_BVH_TREE_NODE* btGImpactBvh_get_node_pointer(btGImpactBvh* obj);
const GIM_BVH_TREE_NODE* btGImpactBvh_get_node_pointer2(btGImpactBvh* obj, int index);
int btGImpactBvh_getEscapeNodeIndex(btGImpactBvh* obj, int nodeindex);
btAABB* btGImpactBvh_getGlobalBox(btGImpactBvh* obj);
int btGImpactBvh_getLeftNode(btGImpactBvh* obj, int nodeindex);
void btGImpactBvh_getNodeBound(btGImpactBvh* obj, int nodeindex, btAABB* bound);
int btGImpactBvh_getNodeCount(btGImpactBvh* obj);
int btGImpactBvh_getNodeData(btGImpactBvh* obj, int nodeindex);
void btGImpactBvh_getNodeTriangle(btGImpactBvh* obj, int nodeindex, btPrimitiveTriangle* triangle);
btPrimitiveManagerBase* btGImpactBvh_getPrimitiveManager(btGImpactBvh* obj);
int btGImpactBvh_getRightNode(btGImpactBvh* obj, int nodeindex);
bool btGImpactBvh_hasHierarchy(btGImpactBvh* obj);
bool btGImpactBvh_isLeafNode(btGImpactBvh* obj, int nodeindex);
bool btGImpactBvh_isTrimesh(btGImpactBvh* obj);
bool btGImpactBvh_rayQuery(btGImpactBvh* obj, const btScalar* ray_dir, const btScalar* ray_origin, btAlignedIntArray* collided_results);
void btGImpactBvh_setNodeBound(btGImpactBvh* obj, int nodeindex, const btAABB* bound);
void btGImpactBvh_setPrimitiveManager(btGImpactBvh* obj, btPrimitiveManagerBase* primitive_manager);
void btGImpactBvh_update(btGImpactBvh* obj);
void btGImpactBvh_delete(btGImpactBvh* obj);
btGImpactCollisionAlgorithm_CreateFunc* btGImpactCollisionAlgorithm_CreateFunc_new();
btGImpactCollisionAlgorithm* btGImpactCollisionAlgorithm_new(const btCollisionAlgorithmConstructionInfo* ci, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap);
int btGImpactCollisionAlgorithm_getFace0(btGImpactCollisionAlgorithm* obj);
int btGImpactCollisionAlgorithm_getFace1(btGImpactCollisionAlgorithm* obj);
int btGImpactCollisionAlgorithm_getPart0(btGImpactCollisionAlgorithm* obj);
int btGImpactCollisionAlgorithm_getPart1(btGImpactCollisionAlgorithm* obj);
void btGImpactCollisionAlgorithm_gimpact_vs_compoundshape(btGImpactCollisionAlgorithm* obj, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, const btGImpactShapeInterface* shape0, const btCompoundShape* shape1, bool swapped);
void btGImpactCollisionAlgorithm_gimpact_vs_concave(btGImpactCollisionAlgorithm* obj, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, const btGImpactShapeInterface* shape0, const btConcaveShape* shape1, bool swapped);
void btGImpactCollisionAlgorithm_gimpact_vs_gimpact(btGImpactCollisionAlgorithm* obj, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, const btGImpactShapeInterface* shape0, const btGImpactShapeInterface* shape1);
void btGImpactCollisionAlgorithm_gimpact_vs_shape(btGImpactCollisionAlgorithm* obj, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, const btGImpactShapeInterface* shape0, const btCollisionShape* shape1, bool swapped);
btManifoldResult* btGImpactCollisionAlgorithm_internalGetResultOut(btGImpactCollisionAlgorithm* obj);
void btGImpactCollisionAlgorithm_registerAlgorithm(btCollisionDispatcher* dispatcher);
void btGImpactCollisionAlgorithm_setFace0(btGImpactCollisionAlgorithm* obj, int value);
void btGImpactCollisionAlgorithm_setFace1(btGImpactCollisionAlgorithm* obj, int value);
void btGImpactCollisionAlgorithm_setPart0(btGImpactCollisionAlgorithm* obj, int value);
void btGImpactCollisionAlgorithm_setPart1(btGImpactCollisionAlgorithm* obj, int value);
BT_QUANTIZED_BVH_NODE* BT_QUANTIZED_BVH_NODE_new();
int BT_QUANTIZED_BVH_NODE_getDataIndex(BT_QUANTIZED_BVH_NODE* obj);
int BT_QUANTIZED_BVH_NODE_getEscapeIndex(BT_QUANTIZED_BVH_NODE* obj);
int BT_QUANTIZED_BVH_NODE_getEscapeIndexOrDataIndex(BT_QUANTIZED_BVH_NODE* obj);
unsigned short* BT_QUANTIZED_BVH_NODE_getQuantizedAabbMax(BT_QUANTIZED_BVH_NODE* obj);
unsigned short* BT_QUANTIZED_BVH_NODE_getQuantizedAabbMin(BT_QUANTIZED_BVH_NODE* obj);
bool BT_QUANTIZED_BVH_NODE_isLeafNode(BT_QUANTIZED_BVH_NODE* obj);
void BT_QUANTIZED_BVH_NODE_setDataIndex(BT_QUANTIZED_BVH_NODE* obj, int index);
void BT_QUANTIZED_BVH_NODE_setEscapeIndex(BT_QUANTIZED_BVH_NODE* obj, int index);
void BT_QUANTIZED_BVH_NODE_setEscapeIndexOrDataIndex(BT_QUANTIZED_BVH_NODE* obj, int value);
bool BT_QUANTIZED_BVH_NODE_testQuantizedBoxOverlapp(BT_QUANTIZED_BVH_NODE* obj, unsigned short* quantizedMin, unsigned short* quantizedMax);
void BT_QUANTIZED_BVH_NODE_delete(BT_QUANTIZED_BVH_NODE* obj);
GIM_QUANTIZED_BVH_NODE_ARRAY* GIM_QUANTIZED_BVH_NODE_ARRAY_new();
btQuantizedBvhTree* btQuantizedBvhTree_new();
void btQuantizedBvhTree_build_tree(btQuantizedBvhTree* obj, GIM_BVH_DATA_ARRAY* primitive_boxes);
void btQuantizedBvhTree_clearNodes(btQuantizedBvhTree* obj);
const BT_QUANTIZED_BVH_NODE* btQuantizedBvhTree_get_node_pointer(btQuantizedBvhTree* obj);
const BT_QUANTIZED_BVH_NODE* btQuantizedBvhTree_get_node_pointer2(btQuantizedBvhTree* obj, int index);
int btQuantizedBvhTree_getEscapeNodeIndex(btQuantizedBvhTree* obj, int nodeindex);
int btQuantizedBvhTree_getLeftNode(btQuantizedBvhTree* obj, int nodeindex);
void btQuantizedBvhTree_getNodeBound(btQuantizedBvhTree* obj, int nodeindex, btAABB* bound);
int btQuantizedBvhTree_getNodeCount(btQuantizedBvhTree* obj);
int btQuantizedBvhTree_getNodeData(btQuantizedBvhTree* obj, int nodeindex);
int btQuantizedBvhTree_getRightNode(btQuantizedBvhTree* obj, int nodeindex);
bool btQuantizedBvhTree_isLeafNode(btQuantizedBvhTree* obj, int nodeindex);
void btQuantizedBvhTree_quantizePoint(btQuantizedBvhTree* obj, unsigned short* quantizedpoint, const btScalar* point);
void btQuantizedBvhTree_setNodeBound(btQuantizedBvhTree* obj, int nodeindex, const btAABB* bound);
bool btQuantizedBvhTree_testQuantizedBoxOverlapp(btQuantizedBvhTree* obj, int node_index, unsigned short* quantizedMin, unsigned short* quantizedMax);
void btQuantizedBvhTree_delete(btQuantizedBvhTree* obj);
btGImpactQuantizedBvh* btGImpactQuantizedBvh_new();
btGImpactQuantizedBvh* btGImpactQuantizedBvh_new2(btPrimitiveManagerBase* primitive_manager);
bool btGImpactQuantizedBvh_boxQuery(btGImpactQuantizedBvh* obj, const btAABB* box, btAlignedIntArray* collided_results);
bool btGImpactQuantizedBvh_boxQueryTrans(btGImpactQuantizedBvh* obj, const btAABB* box, const btScalar* transform, btAlignedIntArray* collided_results);
void btGImpactQuantizedBvh_buildSet(btGImpactQuantizedBvh* obj);
void btGImpactQuantizedBvh_find_collision(const btGImpactQuantizedBvh* boxset1, const btScalar* trans1, const btGImpactQuantizedBvh* boxset2, const btScalar* trans2, btPairSet* collision_pairs);
const BT_QUANTIZED_BVH_NODE* btGImpactQuantizedBvh_get_node_pointer(btGImpactQuantizedBvh* obj);
const BT_QUANTIZED_BVH_NODE* btGImpactQuantizedBvh_get_node_pointer2(btGImpactQuantizedBvh* obj, int index);
int btGImpactQuantizedBvh_getEscapeNodeIndex(btGImpactQuantizedBvh* obj, int nodeindex);
btAABB* btGImpactQuantizedBvh_getGlobalBox(btGImpactQuantizedBvh* obj);
int btGImpactQuantizedBvh_getLeftNode(btGImpactQuantizedBvh* obj, int nodeindex);
void btGImpactQuantizedBvh_getNodeBound(btGImpactQuantizedBvh* obj, int nodeindex, btAABB* bound);
int btGImpactQuantizedBvh_getNodeCount(btGImpactQuantizedBvh* obj);
int btGImpactQuantizedBvh_getNodeData(btGImpactQuantizedBvh* obj, int nodeindex);
void btGImpactQuantizedBvh_getNodeTriangle(btGImpactQuantizedBvh* obj, int nodeindex, btPrimitiveTriangle* triangle);
btPrimitiveManagerBase* btGImpactQuantizedBvh_getPrimitiveManager(btGImpactQuantizedBvh* obj);
int btGImpactQuantizedBvh_getRightNode(btGImpactQuantizedBvh* obj, int nodeindex);
bool btGImpactQuantizedBvh_hasHierarchy(btGImpactQuantizedBvh* obj);
bool btGImpactQuantizedBvh_isLeafNode(btGImpactQuantizedBvh* obj, int nodeindex);
bool btGImpactQuantizedBvh_isTrimesh(btGImpactQuantizedBvh* obj);
bool btGImpactQuantizedBvh_rayQuery(btGImpactQuantizedBvh* obj, const btScalar* ray_dir, const btScalar* ray_origin, btAlignedIntArray* collided_results);
void btGImpactQuantizedBvh_setNodeBound(btGImpactQuantizedBvh* obj, int nodeindex, const btAABB* bound);
void btGImpactQuantizedBvh_setPrimitiveManager(btGImpactQuantizedBvh* obj, btPrimitiveManagerBase* primitive_manager);
void btGImpactQuantizedBvh_update(btGImpactQuantizedBvh* obj);
void btGImpactQuantizedBvh_delete(btGImpactQuantizedBvh* obj);
btTetrahedronShapeEx* btTetrahedronShapeEx_new();
void btTetrahedronShapeEx_setVertices(btTetrahedronShapeEx* obj, const btScalar* v0, const btScalar* v1, const btScalar* v2, const btScalar* v3);
bool btGImpactShapeInterface_childrenHasTransform(btGImpactShapeInterface* obj);
const btGImpactBoxSet* btGImpactShapeInterface_getBoxSet(btGImpactShapeInterface* obj);
void btGImpactShapeInterface_getBulletTetrahedron(btGImpactShapeInterface* obj, int prim_index, btTetrahedronShapeEx* tetrahedron);
void btGImpactShapeInterface_getBulletTriangle(btGImpactShapeInterface* obj, int prim_index, btTriangleShapeEx* triangle);
void btGImpactShapeInterface_getChildAabb(btGImpactShapeInterface* obj, int child_index, const btScalar* t, btScalar* aabbMin, btScalar* aabbMax);
btCollisionShape* btGImpactShapeInterface_getChildShape(btGImpactShapeInterface* obj, int index);
void btGImpactShapeInterface_getChildTransform(btGImpactShapeInterface* obj, int index, btScalar* value);
eGIMPACT_SHAPE_TYPE btGImpactShapeInterface_getGImpactShapeType(btGImpactShapeInterface* obj);
const btAABB* btGImpactShapeInterface_getLocalBox(btGImpactShapeInterface* obj);
int btGImpactShapeInterface_getNumChildShapes(btGImpactShapeInterface* obj);
const btPrimitiveManagerBase* btGImpactShapeInterface_getPrimitiveManager(btGImpactShapeInterface* obj);
void btGImpactShapeInterface_getPrimitiveTriangle(btGImpactShapeInterface* obj, int index, btPrimitiveTriangle* triangle);
bool btGImpactShapeInterface_hasBoxSet(btGImpactShapeInterface* obj);
void btGImpactShapeInterface_lockChildShapes(btGImpactShapeInterface* obj);
bool btGImpactShapeInterface_needsRetrieveTetrahedrons(btGImpactShapeInterface* obj);
bool btGImpactShapeInterface_needsRetrieveTriangles(btGImpactShapeInterface* obj);
void btGImpactShapeInterface_postUpdate(btGImpactShapeInterface* obj);
void btGImpactShapeInterface_processAllTrianglesRay(btGImpactShapeInterface* obj, btTriangleCallback* __unnamed0, const btScalar* __unnamed1, const btScalar* __unnamed2);
void btGImpactShapeInterface_rayTest(btGImpactShapeInterface* obj, const btScalar* rayFrom, const btScalar* rayTo, btCollisionWorld_RayResultCallback* resultCallback);
void btGImpactShapeInterface_setChildTransform(btGImpactShapeInterface* obj, int index, const btScalar* transform);
void btGImpactShapeInterface_unlockChildShapes(btGImpactShapeInterface* obj);
void btGImpactShapeInterface_updateBound(btGImpactShapeInterface* obj);
btGImpactCompoundShape_CompoundPrimitiveManager* btGImpactCompoundShape_CompoundPrimitiveManager_new(const btGImpactCompoundShape_CompoundPrimitiveManager* compound);
btGImpactCompoundShape_CompoundPrimitiveManager* btGImpactCompoundShape_CompoundPrimitiveManager_new2(btGImpactCompoundShape* compoundShape);
btGImpactCompoundShape_CompoundPrimitiveManager* btGImpactCompoundShape_CompoundPrimitiveManager_new3();
btGImpactCompoundShape* btGImpactCompoundShape_CompoundPrimitiveManager_getCompoundShape(btGImpactCompoundShape_CompoundPrimitiveManager* obj);
void btGImpactCompoundShape_CompoundPrimitiveManager_setCompoundShape(btGImpactCompoundShape_CompoundPrimitiveManager* obj, btGImpactCompoundShape* value);
btGImpactCompoundShape* btGImpactCompoundShape_new();
btGImpactCompoundShape* btGImpactCompoundShape_new2(bool children_has_transform);
void btGImpactCompoundShape_addChildShape(btGImpactCompoundShape* obj, const btScalar* localTransform, btCollisionShape* shape);
void btGImpactCompoundShape_addChildShape2(btGImpactCompoundShape* obj, btCollisionShape* shape);
btGImpactCompoundShape_CompoundPrimitiveManager* btGImpactCompoundShape_getCompoundPrimitiveManager(btGImpactCompoundShape* obj);
btGImpactMeshShapePart_TrimeshPrimitiveManager* btGImpactMeshShapePart_TrimeshPrimitiveManager_new(btStridingMeshInterface* meshInterface, int part);
btGImpactMeshShapePart_TrimeshPrimitiveManager* btGImpactMeshShapePart_TrimeshPrimitiveManager_new2(const btGImpactMeshShapePart_TrimeshPrimitiveManager* manager);
btGImpactMeshShapePart_TrimeshPrimitiveManager* btGImpactMeshShapePart_TrimeshPrimitiveManager_new3();
void btGImpactMeshShapePart_TrimeshPrimitiveManager_get_bullet_triangle(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj, int prim_index, btTriangleShapeEx* triangle);
void btGImpactMeshShapePart_TrimeshPrimitiveManager_get_indices(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj, int face_index, unsigned int* i0, unsigned int* i1, unsigned int* i2);
void btGImpactMeshShapePart_TrimeshPrimitiveManager_get_vertex(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj, unsigned int vertex_index, btScalar* vertex);
int btGImpactMeshShapePart_TrimeshPrimitiveManager_get_vertex_count(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj);
const unsigned char* btGImpactMeshShapePart_TrimeshPrimitiveManager_getIndexbase(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj);
int btGImpactMeshShapePart_TrimeshPrimitiveManager_getIndexstride(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj);
PHY_ScalarType btGImpactMeshShapePart_TrimeshPrimitiveManager_getIndicestype(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj);
int btGImpactMeshShapePart_TrimeshPrimitiveManager_getLock_count(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj);
btScalar btGImpactMeshShapePart_TrimeshPrimitiveManager_getMargin(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj);
btStridingMeshInterface* btGImpactMeshShapePart_TrimeshPrimitiveManager_getMeshInterface(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj);
int btGImpactMeshShapePart_TrimeshPrimitiveManager_getNumfaces(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj);
int btGImpactMeshShapePart_TrimeshPrimitiveManager_getNumverts(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj);
int btGImpactMeshShapePart_TrimeshPrimitiveManager_getPart(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj);
void btGImpactMeshShapePart_TrimeshPrimitiveManager_getScale(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj, btScalar* value);
int btGImpactMeshShapePart_TrimeshPrimitiveManager_getStride(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj);
PHY_ScalarType btGImpactMeshShapePart_TrimeshPrimitiveManager_getType(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj);
const unsigned char* btGImpactMeshShapePart_TrimeshPrimitiveManager_getVertexbase(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj);
void btGImpactMeshShapePart_TrimeshPrimitiveManager_lock(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj);
void btGImpactMeshShapePart_TrimeshPrimitiveManager_setIndexbase(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj, const unsigned char* value);
void btGImpactMeshShapePart_TrimeshPrimitiveManager_setIndexstride(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj, int value);
void btGImpactMeshShapePart_TrimeshPrimitiveManager_setIndicestype(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj, PHY_ScalarType value);
void btGImpactMeshShapePart_TrimeshPrimitiveManager_setLock_count(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj, int value);
void btGImpactMeshShapePart_TrimeshPrimitiveManager_setMargin(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj, btScalar value);
void btGImpactMeshShapePart_TrimeshPrimitiveManager_setMeshInterface(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj, btStridingMeshInterface* value);
void btGImpactMeshShapePart_TrimeshPrimitiveManager_setNumfaces(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj, int value);
void btGImpactMeshShapePart_TrimeshPrimitiveManager_setNumverts(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj, int value);
void btGImpactMeshShapePart_TrimeshPrimitiveManager_setPart(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj, int value);
void btGImpactMeshShapePart_TrimeshPrimitiveManager_setScale(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj, const btScalar* value);
void btGImpactMeshShapePart_TrimeshPrimitiveManager_setStride(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj, int value);
void btGImpactMeshShapePart_TrimeshPrimitiveManager_setType(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj, PHY_ScalarType value);
void btGImpactMeshShapePart_TrimeshPrimitiveManager_setVertexbase(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj, const unsigned char* value);
void btGImpactMeshShapePart_TrimeshPrimitiveManager_unlock(btGImpactMeshShapePart_TrimeshPrimitiveManager* obj);
btGImpactMeshShapePart* btGImpactMeshShapePart_new();
btGImpactMeshShapePart* btGImpactMeshShapePart_new2(btStridingMeshInterface* meshInterface, int part);
int btGImpactMeshShapePart_getPart(btGImpactMeshShapePart* obj);
btGImpactMeshShapePart_TrimeshPrimitiveManager* btGImpactMeshShapePart_getTrimeshPrimitiveManager(btGImpactMeshShapePart* obj);
void btGImpactMeshShapePart_getVertex(btGImpactMeshShapePart* obj, int vertex_index, btScalar* vertex);
int btGImpactMeshShapePart_getVertexCount(btGImpactMeshShapePart* obj);
btGImpactMeshShape* btGImpactMeshShape_new(btStridingMeshInterface* meshInterface);
btStridingMeshInterface* btGImpactMeshShape_getMeshInterface(btGImpactMeshShape* obj);
btGImpactMeshShapePart* btGImpactMeshShape_getMeshPart(btGImpactMeshShape* obj, int index);
int btGImpactMeshShape_getMeshPartCount(btGImpactMeshShape* obj);
btGearConstraint* btGearConstraint_new(btRigidBody* rbA, btRigidBody* rbB, const btScalar* axisInA, const btScalar* axisInB);
btGearConstraint* btGearConstraint_new2(btRigidBody* rbA, btRigidBody* rbB, const btScalar* axisInA, const btScalar* axisInB, btScalar ratio);
void btGearConstraint_getAxisA(btGearConstraint* obj, btScalar* axisA);
void btGearConstraint_getAxisB(btGearConstraint* obj, btScalar* axisB);
btScalar btGearConstraint_getRatio(btGearConstraint* obj);
void btGearConstraint_setAxisA(btGearConstraint* obj, btScalar* axisA);
void btGearConstraint_setAxisB(btGearConstraint* obj, btScalar* axisB);
void btGearConstraint_setRatio(btGearConstraint* obj, btScalar ratio);
btRotationalLimitMotor* btRotationalLimitMotor_new();
btRotationalLimitMotor* btRotationalLimitMotor_new2(const btRotationalLimitMotor* limot);
btScalar btRotationalLimitMotor_getAccumulatedImpulse(btRotationalLimitMotor* obj);
btScalar btRotationalLimitMotor_getBounce(btRotationalLimitMotor* obj);
int btRotationalLimitMotor_getCurrentLimit(btRotationalLimitMotor* obj);
btScalar btRotationalLimitMotor_getCurrentLimitError(btRotationalLimitMotor* obj);
btScalar btRotationalLimitMotor_getCurrentPosition(btRotationalLimitMotor* obj);
btScalar btRotationalLimitMotor_getDamping(btRotationalLimitMotor* obj);
bool btRotationalLimitMotor_getEnableMotor(btRotationalLimitMotor* obj);
btScalar btRotationalLimitMotor_getHiLimit(btRotationalLimitMotor* obj);
btScalar btRotationalLimitMotor_getLimitSoftness(btRotationalLimitMotor* obj);
btScalar btRotationalLimitMotor_getLoLimit(btRotationalLimitMotor* obj);
btScalar btRotationalLimitMotor_getMaxLimitForce(btRotationalLimitMotor* obj);
btScalar btRotationalLimitMotor_getMaxMotorForce(btRotationalLimitMotor* obj);
btScalar btRotationalLimitMotor_getNormalCFM(btRotationalLimitMotor* obj);
btScalar btRotationalLimitMotor_getStopCFM(btRotationalLimitMotor* obj);
btScalar btRotationalLimitMotor_getStopERP(btRotationalLimitMotor* obj);
btScalar btRotationalLimitMotor_getTargetVelocity(btRotationalLimitMotor* obj);
bool btRotationalLimitMotor_isLimited(btRotationalLimitMotor* obj);
bool btRotationalLimitMotor_needApplyTorques(btRotationalLimitMotor* obj);
void btRotationalLimitMotor_setAccumulatedImpulse(btRotationalLimitMotor* obj, btScalar value);
void btRotationalLimitMotor_setBounce(btRotationalLimitMotor* obj, btScalar value);
void btRotationalLimitMotor_setCurrentLimit(btRotationalLimitMotor* obj, int value);
void btRotationalLimitMotor_setCurrentLimitError(btRotationalLimitMotor* obj, btScalar value);
void btRotationalLimitMotor_setCurrentPosition(btRotationalLimitMotor* obj, btScalar value);
void btRotationalLimitMotor_setDamping(btRotationalLimitMotor* obj, btScalar value);
void btRotationalLimitMotor_setEnableMotor(btRotationalLimitMotor* obj, bool value);
void btRotationalLimitMotor_setHiLimit(btRotationalLimitMotor* obj, btScalar value);
void btRotationalLimitMotor_setLimitSoftness(btRotationalLimitMotor* obj, btScalar value);
void btRotationalLimitMotor_setLoLimit(btRotationalLimitMotor* obj, btScalar value);
void btRotationalLimitMotor_setMaxLimitForce(btRotationalLimitMotor* obj, btScalar value);
void btRotationalLimitMotor_setMaxMotorForce(btRotationalLimitMotor* obj, btScalar value);
void btRotationalLimitMotor_setNormalCFM(btRotationalLimitMotor* obj, btScalar value);
void btRotationalLimitMotor_setStopCFM(btRotationalLimitMotor* obj, btScalar value);
void btRotationalLimitMotor_setStopERP(btRotationalLimitMotor* obj, btScalar value);
void btRotationalLimitMotor_setTargetVelocity(btRotationalLimitMotor* obj, btScalar value);
btScalar btRotationalLimitMotor_solveAngularLimits(btRotationalLimitMotor* obj, btScalar timeStep, btScalar* axis, btScalar jacDiagABInv, btRigidBody* body0, btRigidBody* body1);
int btRotationalLimitMotor_testLimitValue(btRotationalLimitMotor* obj, btScalar test_value);
void btRotationalLimitMotor_delete(btRotationalLimitMotor* obj);
btTranslationalLimitMotor* btTranslationalLimitMotor_new();
btTranslationalLimitMotor* btTranslationalLimitMotor_new2(const btTranslationalLimitMotor* other);
void btTranslationalLimitMotor_getAccumulatedImpulse(btTranslationalLimitMotor* obj, btScalar* value);
int* btTranslationalLimitMotor_getCurrentLimit(btTranslationalLimitMotor* obj);
void btTranslationalLimitMotor_getCurrentLimitError(btTranslationalLimitMotor* obj, btScalar* value);
void btTranslationalLimitMotor_getCurrentLinearDiff(btTranslationalLimitMotor* obj, btScalar* value);
btScalar btTranslationalLimitMotor_getDamping(btTranslationalLimitMotor* obj);
bool* btTranslationalLimitMotor_getEnableMotor(btTranslationalLimitMotor* obj);
btScalar btTranslationalLimitMotor_getLimitSoftness(btTranslationalLimitMotor* obj);
void btTranslationalLimitMotor_getLowerLimit(btTranslationalLimitMotor* obj, btScalar* value);
void btTranslationalLimitMotor_getMaxMotorForce(btTranslationalLimitMotor* obj, btScalar* value);
void btTranslationalLimitMotor_getNormalCFM(btTranslationalLimitMotor* obj, btScalar* value);
btScalar btTranslationalLimitMotor_getRestitution(btTranslationalLimitMotor* obj);
void btTranslationalLimitMotor_getStopCFM(btTranslationalLimitMotor* obj, btScalar* value);
void btTranslationalLimitMotor_getStopERP(btTranslationalLimitMotor* obj, btScalar* value);
void btTranslationalLimitMotor_getTargetVelocity(btTranslationalLimitMotor* obj, btScalar* value);
void btTranslationalLimitMotor_getUpperLimit(btTranslationalLimitMotor* obj, btScalar* value);
bool btTranslationalLimitMotor_isLimited(btTranslationalLimitMotor* obj, int limitIndex);
bool btTranslationalLimitMotor_needApplyForce(btTranslationalLimitMotor* obj, int limitIndex);
void btTranslationalLimitMotor_setAccumulatedImpulse(btTranslationalLimitMotor* obj, const btScalar* value);
void btTranslationalLimitMotor_setCurrentLimitError(btTranslationalLimitMotor* obj, const btScalar* value);
void btTranslationalLimitMotor_setCurrentLinearDiff(btTranslationalLimitMotor* obj, const btScalar* value);
void btTranslationalLimitMotor_setDamping(btTranslationalLimitMotor* obj, btScalar value);
void btTranslationalLimitMotor_setLimitSoftness(btTranslationalLimitMotor* obj, btScalar value);
void btTranslationalLimitMotor_setLowerLimit(btTranslationalLimitMotor* obj, const btScalar* value);
void btTranslationalLimitMotor_setMaxMotorForce(btTranslationalLimitMotor* obj, const btScalar* value);
void btTranslationalLimitMotor_setNormalCFM(btTranslationalLimitMotor* obj, const btScalar* value);
void btTranslationalLimitMotor_setRestitution(btTranslationalLimitMotor* obj, btScalar value);
void btTranslationalLimitMotor_setStopCFM(btTranslationalLimitMotor* obj, const btScalar* value);
void btTranslationalLimitMotor_setStopERP(btTranslationalLimitMotor* obj, const btScalar* value);
void btTranslationalLimitMotor_setTargetVelocity(btTranslationalLimitMotor* obj, const btScalar* value);
void btTranslationalLimitMotor_setUpperLimit(btTranslationalLimitMotor* obj, const btScalar* value);
btScalar btTranslationalLimitMotor_solveLinearAxis(btTranslationalLimitMotor* obj, btScalar timeStep, btScalar jacDiagABInv, btRigidBody* body1, const btScalar* pointInA, btRigidBody* body2, const btScalar* pointInB, int limit_index, const btScalar* axis_normal_on_a, const btScalar* anchorPos);
int btTranslationalLimitMotor_testLimitValue(btTranslationalLimitMotor* obj, int limitIndex, btScalar test_value);
void btTranslationalLimitMotor_delete(btTranslationalLimitMotor* obj);
btGeneric6DofConstraint* btGeneric6DofConstraint_new(btRigidBody* rbA, btRigidBody* rbB, const btScalar* frameInA, const btScalar* frameInB, bool useLinearReferenceFrameA);
btGeneric6DofConstraint* btGeneric6DofConstraint_new2(btRigidBody* rbB, const btScalar* frameInB, bool useLinearReferenceFrameB);
void btGeneric6DofConstraint_calcAnchorPos(btGeneric6DofConstraint* obj);
void btGeneric6DofConstraint_calculateTransforms(btGeneric6DofConstraint* obj, const btScalar* transA, const btScalar* transB);
void btGeneric6DofConstraint_calculateTransforms2(btGeneric6DofConstraint* obj);
int btGeneric6DofConstraint_get_limit_motor_info2(btGeneric6DofConstraint* obj, btRotationalLimitMotor* limot, const btScalar* transA, const btScalar* transB, const btScalar* linVelA, const btScalar* linVelB, const btScalar* angVelA, const btScalar* angVelB, btTypedConstraint_btConstraintInfo2* info, int row, btScalar* ax1, int rotational);
int btGeneric6DofConstraint_get_limit_motor_info22(btGeneric6DofConstraint* obj, btRotationalLimitMotor* limot, const btScalar* transA, const btScalar* transB, const btScalar* linVelA, const btScalar* linVelB, const btScalar* angVelA, const btScalar* angVelB, btTypedConstraint_btConstraintInfo2* info, int row, btScalar* ax1, int rotational, int rotAllowed);
btScalar btGeneric6DofConstraint_getAngle(btGeneric6DofConstraint* obj, int axis_index);
void btGeneric6DofConstraint_getAngularLowerLimit(btGeneric6DofConstraint* obj, btScalar* angularLower);
void btGeneric6DofConstraint_getAngularUpperLimit(btGeneric6DofConstraint* obj, btScalar* angularUpper);
void btGeneric6DofConstraint_getAxis(btGeneric6DofConstraint* obj, int axis_index, btScalar* value);
void btGeneric6DofConstraint_getCalculatedTransformA(btGeneric6DofConstraint* obj, btScalar* value);
void btGeneric6DofConstraint_getCalculatedTransformB(btGeneric6DofConstraint* obj, btScalar* value);
void btGeneric6DofConstraint_getFrameOffsetA(btGeneric6DofConstraint* obj, btScalar* value);
void btGeneric6DofConstraint_getFrameOffsetB(btGeneric6DofConstraint* obj, btScalar* value);
void btGeneric6DofConstraint_getInfo1NonVirtual(btGeneric6DofConstraint* obj, btTypedConstraint_btConstraintInfo1* info);
void btGeneric6DofConstraint_getInfo2NonVirtual(btGeneric6DofConstraint* obj, btTypedConstraint_btConstraintInfo2* info, const btScalar* transA, const btScalar* transB, const btScalar* linVelA, const btScalar* linVelB, const btScalar* angVelA, const btScalar* angVelB);
void btGeneric6DofConstraint_getLinearLowerLimit(btGeneric6DofConstraint* obj, btScalar* linearLower);
void btGeneric6DofConstraint_getLinearUpperLimit(btGeneric6DofConstraint* obj, btScalar* linearUpper);
btScalar btGeneric6DofConstraint_getRelativePivotPosition(btGeneric6DofConstraint* obj, int axis_index);
btRotationalLimitMotor* btGeneric6DofConstraint_getRotationalLimitMotor(btGeneric6DofConstraint* obj, int index);
btTranslationalLimitMotor* btGeneric6DofConstraint_getTranslationalLimitMotor(btGeneric6DofConstraint* obj);
bool btGeneric6DofConstraint_getUseFrameOffset(btGeneric6DofConstraint* obj);
bool btGeneric6DofConstraint_getUseSolveConstraintObsolete(btGeneric6DofConstraint* obj);
bool btGeneric6DofConstraint_isLimited(btGeneric6DofConstraint* obj, int limitIndex);
void btGeneric6DofConstraint_setAngularLowerLimit(btGeneric6DofConstraint* obj, const btScalar* angularLower);
void btGeneric6DofConstraint_setAngularUpperLimit(btGeneric6DofConstraint* obj, const btScalar* angularUpper);
void btGeneric6DofConstraint_setAxis(btGeneric6DofConstraint* obj, const btScalar* axis1, const btScalar* axis2);
void btGeneric6DofConstraint_setFrames(btGeneric6DofConstraint* obj, const btScalar* frameA, const btScalar* frameB);
void btGeneric6DofConstraint_setLimit(btGeneric6DofConstraint* obj, int axis, btScalar lo, btScalar hi);
void btGeneric6DofConstraint_setLinearLowerLimit(btGeneric6DofConstraint* obj, const btScalar* linearLower);
void btGeneric6DofConstraint_setLinearUpperLimit(btGeneric6DofConstraint* obj, const btScalar* linearUpper);
void btGeneric6DofConstraint_setUseFrameOffset(btGeneric6DofConstraint* obj, bool frameOffsetOnOff);
void btGeneric6DofConstraint_setUseSolveConstraintObsolete(btGeneric6DofConstraint* obj, bool value);
bool btGeneric6DofConstraint_testAngularLimitMotor(btGeneric6DofConstraint* obj, int axis_index);
void btGeneric6DofConstraint_updateRHS(btGeneric6DofConstraint* obj, btScalar timeStep);
btRotationalLimitMotor2* btRotationalLimitMotor2_new();
btRotationalLimitMotor2* btRotationalLimitMotor2_new2(const btRotationalLimitMotor2* limot);
btScalar btRotationalLimitMotor2_getBounce(btRotationalLimitMotor2* obj);
int btRotationalLimitMotor2_getCurrentLimit(btRotationalLimitMotor2* obj);
btScalar btRotationalLimitMotor2_getCurrentLimitError(btRotationalLimitMotor2* obj);
btScalar btRotationalLimitMotor2_getCurrentLimitErrorHi(btRotationalLimitMotor2* obj);
btScalar btRotationalLimitMotor2_getCurrentPosition(btRotationalLimitMotor2* obj);
bool btRotationalLimitMotor2_getEnableMotor(btRotationalLimitMotor2* obj);
bool btRotationalLimitMotor2_getEnableSpring(btRotationalLimitMotor2* obj);
btScalar btRotationalLimitMotor2_getEquilibriumPoint(btRotationalLimitMotor2* obj);
btScalar btRotationalLimitMotor2_getHiLimit(btRotationalLimitMotor2* obj);
btScalar btRotationalLimitMotor2_getLoLimit(btRotationalLimitMotor2* obj);
btScalar btRotationalLimitMotor2_getMaxMotorForce(btRotationalLimitMotor2* obj);
btScalar btRotationalLimitMotor2_getMotorCFM(btRotationalLimitMotor2* obj);
btScalar btRotationalLimitMotor2_getMotorERP(btRotationalLimitMotor2* obj);
bool btRotationalLimitMotor2_getServoMotor(btRotationalLimitMotor2* obj);
btScalar btRotationalLimitMotor2_getServoTarget(btRotationalLimitMotor2* obj);
btScalar btRotationalLimitMotor2_getSpringDamping(btRotationalLimitMotor2* obj);
btScalar btRotationalLimitMotor2_getSpringStiffness(btRotationalLimitMotor2* obj);
btScalar btRotationalLimitMotor2_getStopCFM(btRotationalLimitMotor2* obj);
btScalar btRotationalLimitMotor2_getStopERP(btRotationalLimitMotor2* obj);
btScalar btRotationalLimitMotor2_getTargetVelocity(btRotationalLimitMotor2* obj);
bool btRotationalLimitMotor2_isLimited(btRotationalLimitMotor2* obj);
void btRotationalLimitMotor2_setBounce(btRotationalLimitMotor2* obj, btScalar value);
void btRotationalLimitMotor2_setCurrentLimit(btRotationalLimitMotor2* obj, int value);
void btRotationalLimitMotor2_setCurrentLimitError(btRotationalLimitMotor2* obj, btScalar value);
void btRotationalLimitMotor2_setCurrentLimitErrorHi(btRotationalLimitMotor2* obj, btScalar value);
void btRotationalLimitMotor2_setCurrentPosition(btRotationalLimitMotor2* obj, btScalar value);
void btRotationalLimitMotor2_setEnableMotor(btRotationalLimitMotor2* obj, bool value);
void btRotationalLimitMotor2_setEnableSpring(btRotationalLimitMotor2* obj, bool value);
void btRotationalLimitMotor2_setEquilibriumPoint(btRotationalLimitMotor2* obj, btScalar value);
void btRotationalLimitMotor2_setHiLimit(btRotationalLimitMotor2* obj, btScalar value);
void btRotationalLimitMotor2_setLoLimit(btRotationalLimitMotor2* obj, btScalar value);
void btRotationalLimitMotor2_setMaxMotorForce(btRotationalLimitMotor2* obj, btScalar value);
void btRotationalLimitMotor2_setMotorCFM(btRotationalLimitMotor2* obj, btScalar value);
void btRotationalLimitMotor2_setMotorERP(btRotationalLimitMotor2* obj, btScalar value);
void btRotationalLimitMotor2_setServoMotor(btRotationalLimitMotor2* obj, bool value);
void btRotationalLimitMotor2_setServoTarget(btRotationalLimitMotor2* obj, btScalar value);
void btRotationalLimitMotor2_setSpringDamping(btRotationalLimitMotor2* obj, btScalar value);
void btRotationalLimitMotor2_setSpringStiffness(btRotationalLimitMotor2* obj, btScalar value);
void btRotationalLimitMotor2_setStopCFM(btRotationalLimitMotor2* obj, btScalar value);
void btRotationalLimitMotor2_setStopERP(btRotationalLimitMotor2* obj, btScalar value);
void btRotationalLimitMotor2_setTargetVelocity(btRotationalLimitMotor2* obj, btScalar value);
void btRotationalLimitMotor2_testLimitValue(btRotationalLimitMotor2* obj, btScalar test_value);
void btRotationalLimitMotor2_delete(btRotationalLimitMotor2* obj);
btTranslationalLimitMotor2* btTranslationalLimitMotor2_new();
btTranslationalLimitMotor2* btTranslationalLimitMotor2_new2(const btTranslationalLimitMotor2* other);
void btTranslationalLimitMotor2_getBounce(btTranslationalLimitMotor2* obj, btScalar* value);
int* btTranslationalLimitMotor2_getCurrentLimit(btTranslationalLimitMotor2* obj);
void btTranslationalLimitMotor2_getCurrentLimitError(btTranslationalLimitMotor2* obj, btScalar* value);
void btTranslationalLimitMotor2_getCurrentLimitErrorHi(btTranslationalLimitMotor2* obj, btScalar* value);
void btTranslationalLimitMotor2_getCurrentLinearDiff(btTranslationalLimitMotor2* obj, btScalar* value);
bool* btTranslationalLimitMotor2_getEnableMotor(btTranslationalLimitMotor2* obj);
bool* btTranslationalLimitMotor2_getEnableSpring(btTranslationalLimitMotor2* obj);
void btTranslationalLimitMotor2_getEquilibriumPoint(btTranslationalLimitMotor2* obj, btScalar* value);
void btTranslationalLimitMotor2_getLowerLimit(btTranslationalLimitMotor2* obj, btScalar* value);
void btTranslationalLimitMotor2_getMaxMotorForce(btTranslationalLimitMotor2* obj, btScalar* value);
void btTranslationalLimitMotor2_getMotorCFM(btTranslationalLimitMotor2* obj, btScalar* value);
void btTranslationalLimitMotor2_getMotorERP(btTranslationalLimitMotor2* obj, btScalar* value);
bool* btTranslationalLimitMotor2_getServoMotor(btTranslationalLimitMotor2* obj);
void btTranslationalLimitMotor2_getServoTarget(btTranslationalLimitMotor2* obj, btScalar* value);
void btTranslationalLimitMotor2_getSpringDamping(btTranslationalLimitMotor2* obj, btScalar* value);
void btTranslationalLimitMotor2_getSpringStiffness(btTranslationalLimitMotor2* obj, btScalar* value);
void btTranslationalLimitMotor2_getStopCFM(btTranslationalLimitMotor2* obj, btScalar* value);
void btTranslationalLimitMotor2_getStopERP(btTranslationalLimitMotor2* obj, btScalar* value);
void btTranslationalLimitMotor2_getTargetVelocity(btTranslationalLimitMotor2* obj, btScalar* value);
void btTranslationalLimitMotor2_getUpperLimit(btTranslationalLimitMotor2* obj, btScalar* value);
bool btTranslationalLimitMotor2_isLimited(btTranslationalLimitMotor2* obj, int limitIndex);
void btTranslationalLimitMotor2_setBounce(btTranslationalLimitMotor2* obj, const btScalar* value);
void btTranslationalLimitMotor2_setCurrentLimitError(btTranslationalLimitMotor2* obj, const btScalar* value);
void btTranslationalLimitMotor2_setCurrentLimitErrorHi(btTranslationalLimitMotor2* obj, const btScalar* value);
void btTranslationalLimitMotor2_setCurrentLinearDiff(btTranslationalLimitMotor2* obj, const btScalar* value);
void btTranslationalLimitMotor2_setEquilibriumPoint(btTranslationalLimitMotor2* obj, const btScalar* value);
void btTranslationalLimitMotor2_setLowerLimit(btTranslationalLimitMotor2* obj, const btScalar* value);
void btTranslationalLimitMotor2_setMaxMotorForce(btTranslationalLimitMotor2* obj, const btScalar* value);
void btTranslationalLimitMotor2_setMotorCFM(btTranslationalLimitMotor2* obj, const btScalar* value);
void btTranslationalLimitMotor2_setMotorERP(btTranslationalLimitMotor2* obj, const btScalar* value);
void btTranslationalLimitMotor2_setServoTarget(btTranslationalLimitMotor2* obj, const btScalar* value);
void btTranslationalLimitMotor2_setSpringDamping(btTranslationalLimitMotor2* obj, const btScalar* value);
void btTranslationalLimitMotor2_setSpringStiffness(btTranslationalLimitMotor2* obj, const btScalar* value);
void btTranslationalLimitMotor2_setStopCFM(btTranslationalLimitMotor2* obj, const btScalar* value);
void btTranslationalLimitMotor2_setStopERP(btTranslationalLimitMotor2* obj, const btScalar* value);
void btTranslationalLimitMotor2_setTargetVelocity(btTranslationalLimitMotor2* obj, const btScalar* value);
void btTranslationalLimitMotor2_setUpperLimit(btTranslationalLimitMotor2* obj, const btScalar* value);
void btTranslationalLimitMotor2_testLimitValue(btTranslationalLimitMotor2* obj, int limitIndex, btScalar test_value);
void btTranslationalLimitMotor2_delete(btTranslationalLimitMotor2* obj);
btGeneric6DofSpring2Constraint* btGeneric6DofSpring2Constraint_new(btRigidBody* rbA, btRigidBody* rbB, const btScalar* frameInA, const btScalar* frameInB);
btGeneric6DofSpring2Constraint* btGeneric6DofSpring2Constraint_new2(btRigidBody* rbA, btRigidBody* rbB, const btScalar* frameInA, const btScalar* frameInB, RotateOrder rotOrder);
btGeneric6DofSpring2Constraint* btGeneric6DofSpring2Constraint_new3(btRigidBody* rbB, const btScalar* frameInB);
btGeneric6DofSpring2Constraint* btGeneric6DofSpring2Constraint_new4(btRigidBody* rbB, const btScalar* frameInB, RotateOrder rotOrder);
void btGeneric6DofSpring2Constraint_calculateTransforms(btGeneric6DofSpring2Constraint* obj, const btScalar* transA, const btScalar* transB);
void btGeneric6DofSpring2Constraint_calculateTransforms2(btGeneric6DofSpring2Constraint* obj);
void btGeneric6DofSpring2Constraint_enableMotor(btGeneric6DofSpring2Constraint* obj, int index, bool onOff);
void btGeneric6DofSpring2Constraint_enableSpring(btGeneric6DofSpring2Constraint* obj, int index, bool onOff);
btScalar btGeneric6DofSpring2Constraint_getAngle(btGeneric6DofSpring2Constraint* obj, int axis_index);
void btGeneric6DofSpring2Constraint_getAngularLowerLimit(btGeneric6DofSpring2Constraint* obj, btScalar* angularLower);
void btGeneric6DofSpring2Constraint_getAngularLowerLimitReversed(btGeneric6DofSpring2Constraint* obj, btScalar* angularLower);
void btGeneric6DofSpring2Constraint_getAngularUpperLimit(btGeneric6DofSpring2Constraint* obj, btScalar* angularUpper);
void btGeneric6DofSpring2Constraint_getAngularUpperLimitReversed(btGeneric6DofSpring2Constraint* obj, btScalar* angularUpper);
void btGeneric6DofSpring2Constraint_getAxis(btGeneric6DofSpring2Constraint* obj, int axis_index, btScalar* value);
void btGeneric6DofSpring2Constraint_getCalculatedTransformA(btGeneric6DofSpring2Constraint* obj, btScalar* value);
void btGeneric6DofSpring2Constraint_getCalculatedTransformB(btGeneric6DofSpring2Constraint* obj, btScalar* value);
void btGeneric6DofSpring2Constraint_getFrameOffsetA(btGeneric6DofSpring2Constraint* obj, btScalar* value);
void btGeneric6DofSpring2Constraint_getFrameOffsetB(btGeneric6DofSpring2Constraint* obj, btScalar* value);
void btGeneric6DofSpring2Constraint_getLinearLowerLimit(btGeneric6DofSpring2Constraint* obj, btScalar* linearLower);
void btGeneric6DofSpring2Constraint_getLinearUpperLimit(btGeneric6DofSpring2Constraint* obj, btScalar* linearUpper);
btScalar btGeneric6DofSpring2Constraint_getRelativePivotPosition(btGeneric6DofSpring2Constraint* obj, int axis_index);
btRotationalLimitMotor2* btGeneric6DofSpring2Constraint_getRotationalLimitMotor(btGeneric6DofSpring2Constraint* obj, int index);
RotateOrder btGeneric6DofSpring2Constraint_getRotationOrder(btGeneric6DofSpring2Constraint* obj);
btTranslationalLimitMotor2* btGeneric6DofSpring2Constraint_getTranslationalLimitMotor(btGeneric6DofSpring2Constraint* obj);
bool btGeneric6DofSpring2Constraint_isLimited(btGeneric6DofSpring2Constraint* obj, int limitIndex);
void btGeneric6DofSpring2Constraint_setAngularLowerLimit(btGeneric6DofSpring2Constraint* obj, const btScalar* angularLower);
void btGeneric6DofSpring2Constraint_setAngularLowerLimitReversed(btGeneric6DofSpring2Constraint* obj, const btScalar* angularLower);
void btGeneric6DofSpring2Constraint_setAngularUpperLimit(btGeneric6DofSpring2Constraint* obj, const btScalar* angularUpper);
void btGeneric6DofSpring2Constraint_setAngularUpperLimitReversed(btGeneric6DofSpring2Constraint* obj, const btScalar* angularUpper);
void btGeneric6DofSpring2Constraint_setAxis(btGeneric6DofSpring2Constraint* obj, const btScalar* axis1, const btScalar* axis2);
void btGeneric6DofSpring2Constraint_setBounce(btGeneric6DofSpring2Constraint* obj, int index, btScalar bounce);
void btGeneric6DofSpring2Constraint_setDamping(btGeneric6DofSpring2Constraint* obj, int index, btScalar damping);
void btGeneric6DofSpring2Constraint_setEquilibriumPoint(btGeneric6DofSpring2Constraint* obj);
void btGeneric6DofSpring2Constraint_setEquilibriumPoint2(btGeneric6DofSpring2Constraint* obj, int index, btScalar val);
void btGeneric6DofSpring2Constraint_setEquilibriumPoint3(btGeneric6DofSpring2Constraint* obj, int index);
void btGeneric6DofSpring2Constraint_setFrames(btGeneric6DofSpring2Constraint* obj, const btScalar* frameA, const btScalar* frameB);
void btGeneric6DofSpring2Constraint_setLimit(btGeneric6DofSpring2Constraint* obj, int axis, btScalar lo, btScalar hi);
void btGeneric6DofSpring2Constraint_setLimitReversed(btGeneric6DofSpring2Constraint* obj, int axis, btScalar lo, btScalar hi);
void btGeneric6DofSpring2Constraint_setLinearLowerLimit(btGeneric6DofSpring2Constraint* obj, const btScalar* linearLower);
void btGeneric6DofSpring2Constraint_setLinearUpperLimit(btGeneric6DofSpring2Constraint* obj, const btScalar* linearUpper);
void btGeneric6DofSpring2Constraint_setMaxMotorForce(btGeneric6DofSpring2Constraint* obj, int index, btScalar force);
void btGeneric6DofSpring2Constraint_setRotationOrder(btGeneric6DofSpring2Constraint* obj, RotateOrder order);
void btGeneric6DofSpring2Constraint_setServo(btGeneric6DofSpring2Constraint* obj, int index, bool onOff);
void btGeneric6DofSpring2Constraint_setServoTarget(btGeneric6DofSpring2Constraint* obj, int index, btScalar target);
void btGeneric6DofSpring2Constraint_setStiffness(btGeneric6DofSpring2Constraint* obj, int index, btScalar stiffness);
void btGeneric6DofSpring2Constraint_setTargetVelocity(btGeneric6DofSpring2Constraint* obj, int index, btScalar velocity);
btGeneric6DofSpringConstraint* btGeneric6DofSpringConstraint_new(btRigidBody* rbA, btRigidBody* rbB, const btScalar* frameInA, const btScalar* frameInB, bool useLinearReferenceFrameA);
btGeneric6DofSpringConstraint* btGeneric6DofSpringConstraint_new2(btRigidBody* rbB, const btScalar* frameInB, bool useLinearReferenceFrameB);
void btGeneric6DofSpringConstraint_enableSpring(btGeneric6DofSpringConstraint* obj, int index, bool onOff);
void btGeneric6DofSpringConstraint_setDamping(btGeneric6DofSpringConstraint* obj, int index, btScalar damping);
void btGeneric6DofSpringConstraint_setEquilibriumPoint(btGeneric6DofSpringConstraint* obj);
void btGeneric6DofSpringConstraint_setEquilibriumPoint2(btGeneric6DofSpringConstraint* obj, int index);
void btGeneric6DofSpringConstraint_setEquilibriumPoint3(btGeneric6DofSpringConstraint* obj, int index, btScalar val);
void btGeneric6DofSpringConstraint_setStiffness(btGeneric6DofSpringConstraint* obj, int index, btScalar stiffness);
bool btGeometryUtil_areVerticesBehindPlane(const btScalar* planeNormal, const btAlignedVector3Array* vertices, btScalar margin);
void btGeometryUtil_getPlaneEquationsFromVertices(btAlignedVector3Array* vertices, btAlignedVector3Array* planeEquationsOut);
void btGeometryUtil_getVerticesFromPlaneEquations(const btAlignedVector3Array* planeEquations, btAlignedVector3Array* verticesOut);
bool btGeometryUtil_isInside(const btAlignedVector3Array* vertices, const btScalar* planeNormal, btScalar margin);
bool btGeometryUtil_isPointInsidePlanes(const btAlignedVector3Array* planeEquations, const btScalar* point, btScalar margin);
btGhostObject* btGhostObject_new();
void btGhostObject_addOverlappingObjectInternal(btGhostObject* obj, btBroadphaseProxy* otherProxy);
void btGhostObject_addOverlappingObjectInternal2(btGhostObject* obj, btBroadphaseProxy* otherProxy, btBroadphaseProxy* thisProxy);
void btGhostObject_convexSweepTest(btGhostObject* obj, const btConvexShape* castShape, const btScalar* convexFromWorld, const btScalar* convexToWorld, btCollisionWorld_ConvexResultCallback* resultCallback);
void btGhostObject_convexSweepTest2(btGhostObject* obj, const btConvexShape* castShape, const btScalar* convexFromWorld, const btScalar* convexToWorld, btCollisionWorld_ConvexResultCallback* resultCallback, btScalar allowedCcdPenetration);
int btGhostObject_getNumOverlappingObjects(btGhostObject* obj);
btCollisionObject* btGhostObject_getOverlappingObject(btGhostObject* obj, int index);
btAlignedCollisionObjectArray* btGhostObject_getOverlappingPairs(btGhostObject* obj);
void btGhostObject_rayTest(btGhostObject* obj, const btScalar* rayFromWorld, const btScalar* rayToWorld, btCollisionWorld_RayResultCallback* resultCallback);
void btGhostObject_removeOverlappingObjectInternal(btGhostObject* obj, btBroadphaseProxy* otherProxy, btDispatcher* dispatcher);
void btGhostObject_removeOverlappingObjectInternal2(btGhostObject* obj, btBroadphaseProxy* otherProxy, btDispatcher* dispatcher, btBroadphaseProxy* thisProxy);
btGhostObject* btGhostObject_upcast(btCollisionObject* colObj);
btPairCachingGhostObject* btPairCachingGhostObject_new();
btHashedOverlappingPairCache* btPairCachingGhostObject_getOverlappingPairCache(btPairCachingGhostObject* obj);
btGhostPairCallback* btGhostPairCallback_new();
btGjkConvexCast* btGjkConvexCast_new(const btConvexShape* convexA, const btConvexShape* convexB, btVoronoiSimplexSolver* simplexSolver);
btGjkEpaPenetrationDepthSolver* btGjkEpaPenetrationDepthSolver_new();
btGjkPairDetector* btGjkPairDetector_new(const btConvexShape* objectA, const btConvexShape* objectB, btVoronoiSimplexSolver* simplexSolver, btConvexPenetrationDepthSolver* penetrationDepthSolver);
btGjkPairDetector* btGjkPairDetector_new2(const btConvexShape* objectA, const btConvexShape* objectB, int shapeTypeA, int shapeTypeB, btScalar marginA, btScalar marginB, btVoronoiSimplexSolver* simplexSolver, btConvexPenetrationDepthSolver* penetrationDepthSolver);
void btGjkPairDetector_getCachedSeparatingAxis(btGjkPairDetector* obj, btScalar* value);
btScalar btGjkPairDetector_getCachedSeparatingDistance(btGjkPairDetector* obj);
int btGjkPairDetector_getCatchDegeneracies(btGjkPairDetector* obj);
void btGjkPairDetector_getClosestPointsNonVirtual(btGjkPairDetector* obj, const btDiscreteCollisionDetectorInterface_ClosestPointInput* input, btDiscreteCollisionDetectorInterface_Result* output, btIDebugDraw* debugDraw);
int btGjkPairDetector_getCurIter(btGjkPairDetector* obj);
int btGjkPairDetector_getDegenerateSimplex(btGjkPairDetector* obj);
int btGjkPairDetector_getFixContactNormalDirection(btGjkPairDetector* obj);
int btGjkPairDetector_getLastUsedMethod(btGjkPairDetector* obj);
void btGjkPairDetector_setCachedSeparatingAxis(btGjkPairDetector* obj, const btScalar* seperatingAxis);
void btGjkPairDetector_setCatchDegeneracies(btGjkPairDetector* obj, int value);
void btGjkPairDetector_setCurIter(btGjkPairDetector* obj, int value);
void btGjkPairDetector_setDegenerateSimplex(btGjkPairDetector* obj, int value);
void btGjkPairDetector_setFixContactNormalDirection(btGjkPairDetector* obj, int value);
void btGjkPairDetector_setIgnoreMargin(btGjkPairDetector* obj, bool ignoreMargin);
void btGjkPairDetector_setLastUsedMethod(btGjkPairDetector* obj, int value);
void btGjkPairDetector_setMinkowskiA(btGjkPairDetector* obj, const btConvexShape* minkA);
void btGjkPairDetector_setMinkowskiB(btGjkPairDetector* obj, const btConvexShape* minkB);
void btGjkPairDetector_setPenetrationDepthSolver(btGjkPairDetector* obj, btConvexPenetrationDepthSolver* penetrationDepthSolver);
btHeightfieldTerrainShape* btHeightfieldTerrainShape_new(int heightStickWidth, int heightStickLength, const void* heightfieldData, btScalar heightScale, btScalar minHeight, btScalar maxHeight, int upAxis, PHY_ScalarType heightDataType, bool flipQuadEdges);
btHeightfieldTerrainShape* btHeightfieldTerrainShape_new2(int heightStickWidth, int heightStickLength, const void* heightfieldData, btScalar maxHeight, int upAxis, bool useFloatData, bool flipQuadEdges);
void btHeightfieldTerrainShape_setUseDiamondSubdivision(btHeightfieldTerrainShape* obj);
void btHeightfieldTerrainShape_setUseDiamondSubdivision2(btHeightfieldTerrainShape* obj, bool useDiamondSubdivision);
void btHeightfieldTerrainShape_setUseZigzagSubdivision(btHeightfieldTerrainShape* obj);
void btHeightfieldTerrainShape_setUseZigzagSubdivision2(btHeightfieldTerrainShape* obj, bool useZigzagSubdivision);
btHinge2Constraint* btHinge2Constraint_new(btRigidBody* rbA, btRigidBody* rbB, btScalar* anchor, btScalar* axis1, btScalar* axis2);
void btHinge2Constraint_getAnchor(btHinge2Constraint* obj, btScalar* value);
void btHinge2Constraint_getAnchor2(btHinge2Constraint* obj, btScalar* value);
btScalar btHinge2Constraint_getAngle1(btHinge2Constraint* obj);
btScalar btHinge2Constraint_getAngle2(btHinge2Constraint* obj);
void btHinge2Constraint_getAxis1(btHinge2Constraint* obj, btScalar* value);
void btHinge2Constraint_getAxis2(btHinge2Constraint* obj, btScalar* value);
void btHinge2Constraint_setLowerLimit(btHinge2Constraint* obj, btScalar ang1min);
void btHinge2Constraint_setUpperLimit(btHinge2Constraint* obj, btScalar ang1max);
btHingeConstraint* btHingeConstraint_new(btRigidBody* rbA, btRigidBody* rbB, const btScalar* pivotInA, const btScalar* pivotInB, const btScalar* axisInA, const btScalar* axisInB);
btHingeConstraint* btHingeConstraint_new2(btRigidBody* rbA, btRigidBody* rbB, const btScalar* pivotInA, const btScalar* pivotInB, const btScalar* axisInA, const btScalar* axisInB, bool useReferenceFrameA);
btHingeConstraint* btHingeConstraint_new3(btRigidBody* rbA, const btScalar* pivotInA, const btScalar* axisInA);
btHingeConstraint* btHingeConstraint_new4(btRigidBody* rbA, const btScalar* pivotInA, const btScalar* axisInA, bool useReferenceFrameA);
btHingeConstraint* btHingeConstraint_new5(btRigidBody* rbA, btRigidBody* rbB, const btScalar* rbAFrame, const btScalar* rbBFrame);
btHingeConstraint* btHingeConstraint_new6(btRigidBody* rbA, btRigidBody* rbB, const btScalar* rbAFrame, const btScalar* rbBFrame, bool useReferenceFrameA);
btHingeConstraint* btHingeConstraint_new7(btRigidBody* rbA, const btScalar* rbAFrame);
btHingeConstraint* btHingeConstraint_new8(btRigidBody* rbA, const btScalar* rbAFrame, bool useReferenceFrameA);
void btHingeConstraint_enableAngularMotor(btHingeConstraint* obj, bool enableMotor, btScalar targetVelocity, btScalar maxMotorImpulse);
void btHingeConstraint_enableMotor(btHingeConstraint* obj, bool enableMotor);
void btHingeConstraint_getAFrame(btHingeConstraint* obj, btScalar* value);
bool btHingeConstraint_getAngularOnly(btHingeConstraint* obj);
void btHingeConstraint_getBFrame(btHingeConstraint* obj, btScalar* value);
bool btHingeConstraint_getEnableAngularMotor(btHingeConstraint* obj);
void btHingeConstraint_getFrameOffsetA(btHingeConstraint* obj, btScalar* value);
void btHingeConstraint_getFrameOffsetB(btHingeConstraint* obj, btScalar* value);
btScalar btHingeConstraint_getHingeAngle(btHingeConstraint* obj, const btScalar* transA, const btScalar* transB);
btScalar btHingeConstraint_getHingeAngle2(btHingeConstraint* obj);
void btHingeConstraint_getInfo1NonVirtual(btHingeConstraint* obj, btTypedConstraint_btConstraintInfo1* info);
void btHingeConstraint_getInfo2Internal(btHingeConstraint* obj, btTypedConstraint_btConstraintInfo2* info, const btScalar* transA, const btScalar* transB, const btScalar* angVelA, const btScalar* angVelB);
void btHingeConstraint_getInfo2InternalUsingFrameOffset(btHingeConstraint* obj, btTypedConstraint_btConstraintInfo2* info, const btScalar* transA, const btScalar* transB, const btScalar* angVelA, const btScalar* angVelB);
void btHingeConstraint_getInfo2NonVirtual(btHingeConstraint* obj, btTypedConstraint_btConstraintInfo2* info, const btScalar* transA, const btScalar* transB, const btScalar* angVelA, const btScalar* angVelB);
btScalar btHingeConstraint_getLimitSign(btHingeConstraint* obj);
btScalar btHingeConstraint_getLowerLimit(btHingeConstraint* obj);
btScalar btHingeConstraint_getMaxMotorImpulse(btHingeConstraint* obj);
btScalar btHingeConstraint_getMotorTargetVelosity(btHingeConstraint* obj);
int btHingeConstraint_getSolveLimit(btHingeConstraint* obj);
btScalar btHingeConstraint_getUpperLimit(btHingeConstraint* obj);
bool btHingeConstraint_getUseFrameOffset(btHingeConstraint* obj);
bool btHingeConstraint_hasLimit(btHingeConstraint* obj);
void btHingeConstraint_setAngularOnly(btHingeConstraint* obj, bool angularOnly);
void btHingeConstraint_setAxis(btHingeConstraint* obj, btScalar* axisInA);
void btHingeConstraint_setFrames(btHingeConstraint* obj, const btScalar* frameA, const btScalar* frameB);
void btHingeConstraint_setLimit(btHingeConstraint* obj, btScalar low, btScalar high);
void btHingeConstraint_setLimit2(btHingeConstraint* obj, btScalar low, btScalar high, btScalar _softness);
void btHingeConstraint_setLimit3(btHingeConstraint* obj, btScalar low, btScalar high, btScalar _softness, btScalar _biasFactor);
void btHingeConstraint_setLimit4(btHingeConstraint* obj, btScalar low, btScalar high, btScalar _softness, btScalar _biasFactor, btScalar _relaxationFactor);
void btHingeConstraint_setMaxMotorImpulse(btHingeConstraint* obj, btScalar maxMotorImpulse);
void btHingeConstraint_setMotorTarget(btHingeConstraint* obj, btScalar targetAngle, btScalar dt);
void btHingeConstraint_setMotorTarget2(btHingeConstraint* obj, const btScalar* qAinB, btScalar dt);
void btHingeConstraint_setUseFrameOffset(btHingeConstraint* obj, bool frameOffsetOnOff);
void btHingeConstraint_testLimit(btHingeConstraint* obj, const btScalar* transA, const btScalar* transB);
void btHingeConstraint_updateRHS(btHingeConstraint* obj, btScalar timeStep);
btHingeAccumulatedAngleConstraint* btHingeAccumulatedAngleConstraint_new(btRigidBody* rbA, btRigidBody* rbB, const btScalar* pivotInA, const btScalar* pivotInB, const btScalar* axisInA, const btScalar* axisInB);
btHingeAccumulatedAngleConstraint* btHingeAccumulatedAngleConstraint_new2(btRigidBody* rbA, btRigidBody* rbB, const btScalar* pivotInA, const btScalar* pivotInB, const btScalar* axisInA, const btScalar* axisInB, bool useReferenceFrameA);
btHingeAccumulatedAngleConstraint* btHingeAccumulatedAngleConstraint_new3(btRigidBody* rbA, const btScalar* pivotInA, const btScalar* axisInA);
btHingeAccumulatedAngleConstraint* btHingeAccumulatedAngleConstraint_new4(btRigidBody* rbA, const btScalar* pivotInA, const btScalar* axisInA, bool useReferenceFrameA);
btHingeAccumulatedAngleConstraint* btHingeAccumulatedAngleConstraint_new5(btRigidBody* rbA, btRigidBody* rbB, const btScalar* rbAFrame, const btScalar* rbBFrame);
btHingeAccumulatedAngleConstraint* btHingeAccumulatedAngleConstraint_new6(btRigidBody* rbA, btRigidBody* rbB, const btScalar* rbAFrame, const btScalar* rbBFrame, bool useReferenceFrameA);
btHingeAccumulatedAngleConstraint* btHingeAccumulatedAngleConstraint_new7(btRigidBody* rbA, const btScalar* rbAFrame);
btHingeAccumulatedAngleConstraint* btHingeAccumulatedAngleConstraint_new8(btRigidBody* rbA, const btScalar* rbAFrame, bool useReferenceFrameA);
btScalar btHingeAccumulatedAngleConstraint_getAccumulatedHingeAngle(btHingeAccumulatedAngleConstraint* obj);
void btHingeAccumulatedAngleConstraint_setAccumulatedHingeAngle(btHingeAccumulatedAngleConstraint* obj, btScalar accAngle);
void* btIDebugDrawWrapper_getGCHandle(btIDebugDrawWrapper* obj);
void btIDebugDraw_delete(btIDebugDraw* obj);
btKinematicCharacterController* btKinematicCharacterController_new(btPairCachingGhostObject* ghostObject, btConvexShape* convexShape, btScalar stepHeight);
btKinematicCharacterController* btKinematicCharacterController_new2(btPairCachingGhostObject* ghostObject, btConvexShape* convexShape, btScalar stepHeight, int upAxis);
btPairCachingGhostObject* btKinematicCharacterController_getGhostObject(btKinematicCharacterController* obj);
btScalar btKinematicCharacterController_getGravity(btKinematicCharacterController* obj);
btScalar btKinematicCharacterController_getMaxSlope(btKinematicCharacterController* obj);
void btKinematicCharacterController_setFallSpeed(btKinematicCharacterController* obj, btScalar fallSpeed);
void btKinematicCharacterController_setGravity(btKinematicCharacterController* obj, btScalar gravity);
void btKinematicCharacterController_setJumpSpeed(btKinematicCharacterController* obj, btScalar jumpSpeed);
void btKinematicCharacterController_setMaxJumpHeight(btKinematicCharacterController* obj, btScalar maxJumpHeight);
void btKinematicCharacterController_setMaxSlope(btKinematicCharacterController* obj, btScalar slopeRadians);
void btKinematicCharacterController_setUpAxis(btKinematicCharacterController* obj, int axis);
void btKinematicCharacterController_setUseGhostSweepTest(btKinematicCharacterController* obj, bool useGhostObjectSweepTest);
btLemkeSolver* btLemkeSolver_new();
int btLemkeSolver_getDebugLevel(btLemkeSolver* obj);
int btLemkeSolver_getMaxLoops(btLemkeSolver* obj);
btScalar btLemkeSolver_getMaxValue(btLemkeSolver* obj);
bool btLemkeSolver_getUseLoHighBounds(btLemkeSolver* obj);
void btLemkeSolver_setDebugLevel(btLemkeSolver* obj, int value);
void btLemkeSolver_setMaxLoops(btLemkeSolver* obj, int value);
void btLemkeSolver_setMaxValue(btLemkeSolver* obj, btScalar value);
void btLemkeSolver_setUseLoHighBounds(btLemkeSolver* obj, bool value);
bool btMLCPSolverInterface_solveMLCP(btMLCPSolverInterface* obj, const btMatrixXf* A, const btVectorXf* b, btVectorXf* x, const btVectorXf* lo, const btVectorXf* hi, const btAlignedIntArray* limitDependency, int numIterations);
bool btMLCPSolverInterface_solveMLCP2(btMLCPSolverInterface* obj, const btMatrixXf* A, const btVectorXf* b, btVectorXf* x, const btVectorXf* lo, const btVectorXf* hi, const btAlignedIntArray* limitDependency, int numIterations, bool useSparsity);
void btMLCPSolverInterface_delete(btMLCPSolverInterface* obj);
btMLCPSolver* btMLCPSolver_new(btMLCPSolverInterface* solver);
btScalar btMLCPSolver_getCfm(btMLCPSolver* obj);
int btMLCPSolver_getNumFallbacks(btMLCPSolver* obj);
void btMLCPSolver_setCfm(btMLCPSolver* obj, btScalar cfm);
void btMLCPSolver_setMLCPSolver(btMLCPSolver* obj, btMLCPSolverInterface* solver);
void btMLCPSolver_setNumFallbacks(btMLCPSolver* obj, int num);
btConstraintRow* btConstraintRow_new();
btScalar btConstraintRow_getAccumImpulse(btConstraintRow* obj);
btScalar btConstraintRow_getJacDiagInv(btConstraintRow* obj);
btScalar btConstraintRow_getLowerLimit(btConstraintRow* obj);
void btConstraintRow_getNormal(btConstraintRow* obj, btScalar* value);
btScalar btConstraintRow_getRhs(btConstraintRow* obj);
btScalar btConstraintRow_getUpperLimit(btConstraintRow* obj);
void btConstraintRow_setAccumImpulse(btConstraintRow* obj, btScalar value);
void btConstraintRow_setJacDiagInv(btConstraintRow* obj, btScalar value);
void btConstraintRow_setLowerLimit(btConstraintRow* obj, btScalar value);
void btConstraintRow_setNormal(btConstraintRow* obj, btScalar* value);
void btConstraintRow_setRhs(btConstraintRow* obj, btScalar value);
void btConstraintRow_setUpperLimit(btConstraintRow* obj, btScalar value);
void btConstraintRow_delete(btConstraintRow* obj);
btManifoldPoint* btManifoldPoint_new();
btManifoldPoint* btManifoldPoint_new2(const btScalar* pointA, const btScalar* pointB, const btScalar* normal, btScalar distance);
btScalar btManifoldPoint_getAppliedImpulse(btManifoldPoint* obj);
btScalar btManifoldPoint_getAppliedImpulseLateral1(btManifoldPoint* obj);
btScalar btManifoldPoint_getAppliedImpulseLateral2(btManifoldPoint* obj);
btScalar btManifoldPoint_getCombinedFriction(btManifoldPoint* obj);
btScalar btManifoldPoint_getCombinedRestitution(btManifoldPoint* obj);
btScalar btManifoldPoint_getCombinedRollingFriction(btManifoldPoint* obj);
btScalar btManifoldPoint_getContactCFM1(btManifoldPoint* obj);
btScalar btManifoldPoint_getContactCFM2(btManifoldPoint* obj);
btScalar btManifoldPoint_getContactMotion1(btManifoldPoint* obj);
btScalar btManifoldPoint_getContactMotion2(btManifoldPoint* obj);
btScalar btManifoldPoint_getDistance(btManifoldPoint* obj);
btScalar btManifoldPoint_getDistance1(btManifoldPoint* obj);
int btManifoldPoint_getIndex0(btManifoldPoint* obj);
int btManifoldPoint_getIndex1(btManifoldPoint* obj);
void btManifoldPoint_getLateralFrictionDir1(btManifoldPoint* obj, btScalar* value);
void btManifoldPoint_getLateralFrictionDir2(btManifoldPoint* obj, btScalar* value);
bool btManifoldPoint_getLateralFrictionInitialized(btManifoldPoint* obj);
int btManifoldPoint_getLifeTime(btManifoldPoint* obj);
void btManifoldPoint_getLocalPointA(btManifoldPoint* obj, btScalar* value);
void btManifoldPoint_getLocalPointB(btManifoldPoint* obj, btScalar* value);
void btManifoldPoint_getNormalWorldOnB(btManifoldPoint* obj, btScalar* value);
int btManifoldPoint_getPartId0(btManifoldPoint* obj);
int btManifoldPoint_getPartId1(btManifoldPoint* obj);
void btManifoldPoint_getPositionWorldOnA(btManifoldPoint* obj, btScalar* value);
void btManifoldPoint_getPositionWorldOnB(btManifoldPoint* obj, btScalar* value);
void* btManifoldPoint_getUserPersistentData(btManifoldPoint* obj);
void btManifoldPoint_setAppliedImpulse(btManifoldPoint* obj, btScalar value);
void btManifoldPoint_setAppliedImpulseLateral1(btManifoldPoint* obj, btScalar value);
void btManifoldPoint_setAppliedImpulseLateral2(btManifoldPoint* obj, btScalar value);
void btManifoldPoint_setCombinedFriction(btManifoldPoint* obj, btScalar value);
void btManifoldPoint_setCombinedRestitution(btManifoldPoint* obj, btScalar value);
void btManifoldPoint_setCombinedRollingFriction(btManifoldPoint* obj, btScalar value);
void btManifoldPoint_setContactCFM1(btManifoldPoint* obj, btScalar value);
void btManifoldPoint_setContactCFM2(btManifoldPoint* obj, btScalar value);
void btManifoldPoint_setContactMotion1(btManifoldPoint* obj, btScalar value);
void btManifoldPoint_setContactMotion2(btManifoldPoint* obj, btScalar value);
void btManifoldPoint_setDistance(btManifoldPoint* obj, btScalar dist);
void btManifoldPoint_setDistance1(btManifoldPoint* obj, btScalar value);
void btManifoldPoint_setIndex0(btManifoldPoint* obj, int value);
void btManifoldPoint_setIndex1(btManifoldPoint* obj, int value);
void btManifoldPoint_setLateralFrictionDir1(btManifoldPoint* obj, const btScalar* value);
void btManifoldPoint_setLateralFrictionDir2(btManifoldPoint* obj, const btScalar* value);
void btManifoldPoint_setLateralFrictionInitialized(btManifoldPoint* obj, bool value);
void btManifoldPoint_setLifeTime(btManifoldPoint* obj, int value);
void btManifoldPoint_setLocalPointA(btManifoldPoint* obj, const btScalar* value);
void btManifoldPoint_setLocalPointB(btManifoldPoint* obj, const btScalar* value);
void btManifoldPoint_setNormalWorldOnB(btManifoldPoint* obj, const btScalar* value);
void btManifoldPoint_setPartId0(btManifoldPoint* obj, int value);
void btManifoldPoint_setPartId1(btManifoldPoint* obj, int value);
void btManifoldPoint_setPositionWorldOnA(btManifoldPoint* obj, const btScalar* value);
void btManifoldPoint_setPositionWorldOnB(btManifoldPoint* obj, const btScalar* value);
void btManifoldPoint_setUserPersistentData(btManifoldPoint* obj, void* value);
void btManifoldPoint_delete(btManifoldPoint* obj);
ContactAddedCallback getGContactAddedCallback();
void setGContactAddedCallback(ContactAddedCallback value);
btManifoldResult* btManifoldResult_new();
btManifoldResult* btManifoldResult_new2(const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap);
btScalar btManifoldResult_calculateCombinedFriction(const btCollisionObject* body0, const btCollisionObject* body1);
btScalar btManifoldResult_calculateCombinedRestitution(const btCollisionObject* body0, const btCollisionObject* body1);
const btCollisionObject* btManifoldResult_getBody0Internal(btManifoldResult* obj);
const btCollisionObjectWrapper* btManifoldResult_getBody0Wrap(btManifoldResult* obj);
const btCollisionObject* btManifoldResult_getBody1Internal(btManifoldResult* obj);
const btCollisionObjectWrapper* btManifoldResult_getBody1Wrap(btManifoldResult* obj);
btPersistentManifold* btManifoldResult_getPersistentManifold(btManifoldResult* obj);
void btManifoldResult_refreshContactPoints(btManifoldResult* obj);
void btManifoldResult_setBody0Wrap(btManifoldResult* obj, const btCollisionObjectWrapper* obj0Wrap);
void btManifoldResult_setBody1Wrap(btManifoldResult* obj, const btCollisionObjectWrapper* obj1Wrap);
void btManifoldResult_setPersistentManifold(btManifoldResult* obj, btPersistentManifold* manifoldPtr);
btMinkowskiPenetrationDepthSolver* btMinkowskiPenetrationDepthSolver_new();
btMinkowskiSumShape* btMinkowskiSumShape_new(const btConvexShape* shapeA, const btConvexShape* shapeB);
const btConvexShape* btMinkowskiSumShape_getShapeA(btMinkowskiSumShape* obj);
const btConvexShape* btMinkowskiSumShape_getShapeB(btMinkowskiSumShape* obj);
void btMinkowskiSumShape_getTransformA(btMinkowskiSumShape* obj, btScalar* transA);
void btMinkowskiSumShape_GetTransformB(btMinkowskiSumShape* obj, btScalar* transB);
void btMinkowskiSumShape_setTransformA(btMinkowskiSumShape* obj, const btScalar* transA);
void btMinkowskiSumShape_setTransformB(btMinkowskiSumShape* obj, const btScalar* transB);
btMotionStateWrapper* btMotionStateWrapper_new(pMotionState_GetWorldTransform getWorldTransformCallback, pMotionState_SetWorldTransform setWorldTransformCallback);
void btMotionState_getWorldTransform(btMotionState* obj, btScalar* worldTrans);
void btMotionState_setWorldTransform(btMotionState* obj, const btScalar* worldTrans);
void btMotionState_delete(btMotionState* obj);
btMultiBodyConstraintSolver* btMultiBodyConstraintSolver_new();
btScalar btMultiBodyConstraintSolver_solveGroupCacheFriendlyFinish(btMultiBodyConstraintSolver* obj, btCollisionObject** bodies, int numBodies, const btContactSolverInfo* infoGlobal);
void btMultiBodyConstraintSolver_solveMultiBodyGroup(btMultiBodyConstraintSolver* obj, btCollisionObject** bodies, int numBodies, btPersistentManifold** manifold, int numManifolds, btTypedConstraint** constraints, int numConstraints, btMultiBodyConstraint** multiBodyConstraints, int numMultiBodyConstraints, const btContactSolverInfo* info, btIDebugDraw* debugDrawer, btDispatcher* dispatcher);
void btMultiBodyConstraint_createConstraintRows(btMultiBodyConstraint* obj, btMultiBodyConstraintArray* constraintRows, btMultiBodyJacobianData* data, const btContactSolverInfo* infoGlobal);
void btMultiBodyConstraint_debugDraw(btMultiBodyConstraint* obj, btIDebugDraw* drawer);
int btMultiBodyConstraint_getIslandIdA(btMultiBodyConstraint* obj);
int btMultiBodyConstraint_getIslandIdB(btMultiBodyConstraint* obj);
btScalar btMultiBodyConstraint_getMaxAppliedImpulse(btMultiBodyConstraint* obj);
btMultiBody* btMultiBodyConstraint_getMultiBodyA(btMultiBodyConstraint* obj);
btMultiBody* btMultiBodyConstraint_getMultiBodyB(btMultiBodyConstraint* obj);
int btMultiBodyConstraint_getNumRows(btMultiBodyConstraint* obj);
btScalar btMultiBodyConstraint_getPosition(btMultiBodyConstraint* obj, int row);
bool btMultiBodyConstraint_isUnilateral(btMultiBodyConstraint* obj);
btScalar* btMultiBodyConstraint_jacobianA(btMultiBodyConstraint* obj, int row);
btScalar* btMultiBodyConstraint_jacobianB(btMultiBodyConstraint* obj, int row);
void btMultiBodyConstraint_setMaxAppliedImpulse(btMultiBodyConstraint* obj, btScalar maxImp);
void btMultiBodyConstraint_setPosition(btMultiBodyConstraint* obj, int row, btScalar pos);
void btMultiBodyConstraint_delete(btMultiBodyConstraint* obj);
btMultiBodyDynamicsWorld* btMultiBodyDynamicsWorld_new(btDispatcher* dispatcher, btBroadphaseInterface* pairCache, btMultiBodyConstraintSolver* constraintSolver, btCollisionConfiguration* collisionConfiguration);
void btMultiBodyDynamicsWorld_addMultiBody(btMultiBodyDynamicsWorld* obj, btMultiBody* body);
void btMultiBodyDynamicsWorld_addMultiBody2(btMultiBodyDynamicsWorld* obj, btMultiBody* body, short group);
void btMultiBodyDynamicsWorld_addMultiBody3(btMultiBodyDynamicsWorld* obj, btMultiBody* body, short group, short mask);
void btMultiBodyDynamicsWorld_addMultiBodyConstraint(btMultiBodyDynamicsWorld* obj, btMultiBodyConstraint* constraint);
void btMultiBodyDynamicsWorld_debugDrawMultiBodyConstraint(btMultiBodyDynamicsWorld* obj, btMultiBodyConstraint* constraint);
void btMultiBodyDynamicsWorld_integrateTransforms(btMultiBodyDynamicsWorld* obj, btScalar timeStep);
void btMultiBodyDynamicsWorld_removeMultiBody(btMultiBodyDynamicsWorld* obj, btMultiBody* body);
void btMultiBodyDynamicsWorld_removeMultiBodyConstraint(btMultiBodyDynamicsWorld* obj, btMultiBodyConstraint* constraint);
btMultiBodyJointLimitConstraint* btMultiBodyJointLimitConstraint_new(btMultiBody* body, int link, btScalar lower, btScalar upper);
btMultiBodyJointMotor* btMultiBodyJointMotor_new(btMultiBody* body, int link, btScalar desiredVelocity, btScalar maxMotorImpulse);
btMultiBodyJointMotor* btMultiBodyJointMotor_new2(btMultiBody* body, int link, int linkDoF, btScalar desiredVelocity, btScalar maxMotorImpulse);
void btMultiBodyJointMotor_setVelocityTarget(btMultiBodyJointMotor* obj, btScalar velTarget);
btMultiBodyLinkCollider* btMultiBodyLinkCollider_new(btMultiBody* multiBody, int link);
int btMultiBodyLinkCollider_getLink(btMultiBodyLinkCollider* obj);
btMultiBody* btMultiBodyLinkCollider_getMultiBody(btMultiBodyLinkCollider* obj);
void btMultiBodyLinkCollider_setLink(btMultiBodyLinkCollider* obj, int value);
void btMultiBodyLinkCollider_setMultiBody(btMultiBodyLinkCollider* obj, btMultiBody* value);
btMultiBodyLinkCollider* btMultiBodyLinkCollider_upcast(btCollisionObject* colObj);
btMultibodyLink* btMultibodyLink_new();
btSpatialMotionVector* btMultibodyLink_getAbsFrameLocVelocity(btMultibodyLink* obj);
btSpatialMotionVector* btMultibodyLink_getAbsFrameTotVelocity(btMultibodyLink* obj);
void btMultibodyLink_getAppliedForce(btMultibodyLink* obj, btScalar* value);
void btMultibodyLink_getAppliedTorque(btMultibodyLink* obj, btScalar* value);
btSpatialMotionVector* btMultibodyLink_getAxes(btMultibodyLink* obj);
void btMultibodyLink_getAxisBottom(btMultibodyLink* obj, int dof, btScalar* value);
void btMultibodyLink_getAxisTop(btMultibodyLink* obj, int dof, btScalar* value);
void btMultibodyLink_getCachedRotParentToThis(btMultibodyLink* obj, btScalar* value);
void btMultibodyLink_getCachedRVector(btMultibodyLink* obj, btScalar* value);
int btMultibodyLink_getCfgOffset(btMultibodyLink* obj);
btMultiBodyLinkCollider* btMultibodyLink_getCollider(btMultibodyLink* obj);
int btMultibodyLink_getDofCount(btMultibodyLink* obj);
int btMultibodyLink_getDofOffset(btMultibodyLink* obj);
void btMultibodyLink_getDVector(btMultibodyLink* obj, btScalar* value);
void btMultibodyLink_getEVector(btMultibodyLink* obj, btScalar* value);
int btMultibodyLink_getFlags(btMultibodyLink* obj);
void btMultibodyLink_getInertiaLocal(btMultibodyLink* obj, btScalar* value);
btScalar* btMultibodyLink_getJointPos(btMultibodyLink* obj);
btScalar* btMultibodyLink_getJointTorque(btMultibodyLink* obj);
eFeatherstoneJointType btMultibodyLink_getJointType(btMultibodyLink* obj);
btScalar btMultibodyLink_getMass(btMultibodyLink* obj);
int btMultibodyLink_getParent(btMultibodyLink* obj);
int btMultibodyLink_getPosVarCount(btMultibodyLink* obj);
void btMultibodyLink_getZeroRotParentToThis(btMultibodyLink* obj, btScalar* value);
void btMultibodyLink_setAbsFrameLocVelocity(btMultibodyLink* obj, const btSpatialMotionVector* value);
void btMultibodyLink_setAbsFrameTotVelocity(btMultibodyLink* obj, const btSpatialMotionVector* value);
void btMultibodyLink_setAppliedForce(btMultibodyLink* obj, const btScalar* value);
void btMultibodyLink_setAppliedTorque(btMultibodyLink* obj, const btScalar* value);
void btMultibodyLink_setAxisBottom(btMultibodyLink* obj, int dof, const btScalar* x, const btScalar* y, const btScalar* z);
void btMultibodyLink_setAxisBottom2(btMultibodyLink* obj, int dof, const btScalar* axis);
void btMultibodyLink_setAxisTop(btMultibodyLink* obj, int dof, const btScalar* axis);
void btMultibodyLink_setAxisTop2(btMultibodyLink* obj, int dof, const btScalar* x, const btScalar* y, const btScalar* z);
void btMultibodyLink_setCachedRotParentToThis(btMultibodyLink* obj, const btScalar* value);
void btMultibodyLink_setCachedRVector(btMultibodyLink* obj, const btScalar* value);
void btMultibodyLink_setCfgOffset(btMultibodyLink* obj, int value);
void btMultibodyLink_setCollider(btMultibodyLink* obj, btMultiBodyLinkCollider* value);
void btMultibodyLink_setDofCount(btMultibodyLink* obj, int value);
void btMultibodyLink_setDofOffset(btMultibodyLink* obj, int value);
void btMultibodyLink_setDVector(btMultibodyLink* obj, const btScalar* value);
void btMultibodyLink_setEVector(btMultibodyLink* obj, const btScalar* value);
void btMultibodyLink_setFlags(btMultibodyLink* obj, int value);
void btMultibodyLink_setInertiaLocal(btMultibodyLink* obj, const btScalar* value);
void btMultibodyLink_setJointType(btMultibodyLink* obj, eFeatherstoneJointType value);
void btMultibodyLink_setMass(btMultibodyLink* obj, btScalar value);
void btMultibodyLink_setParent(btMultibodyLink* obj, int value);
void btMultibodyLink_setPosVarCount(btMultibodyLink* obj, int value);
void btMultibodyLink_setZeroRotParentToThis(btMultibodyLink* obj, const btScalar* value);
void btMultibodyLink_updateCache(btMultibodyLink* obj);
void btMultibodyLink_updateCacheMultiDof(btMultibodyLink* obj);
void btMultibodyLink_updateCacheMultiDof2(btMultibodyLink* obj, btScalar* pq);
void btMultibodyLink_delete(btMultibodyLink* obj);
btMultiBodyPoint2Point* btMultiBodyPoint2Point_new(btMultiBody* body, int link, btRigidBody* bodyB, const btScalar* pivotInA, const btScalar* pivotInB);
btMultiBodyPoint2Point* btMultiBodyPoint2Point_new2(btMultiBody* bodyA, int linkA, btMultiBody* bodyB, int linkB, const btScalar* pivotInA, const btScalar* pivotInB);
void btMultiBodyPoint2Point_getPivotInB(btMultiBodyPoint2Point* obj, btScalar* pivotInB);
void btMultiBodyPoint2Point_setPivotInB(btMultiBodyPoint2Point* obj, const btScalar* pivotInB);
btMultiBodySolverConstraint* btMultiBodySolverConstraint_new();
void btMultiBodySolverConstraint_getAngularComponentA(btMultiBodySolverConstraint* obj, btScalar* value);
void btMultiBodySolverConstraint_getAngularComponentB(btMultiBodySolverConstraint* obj, btScalar* value);
btScalar btMultiBodySolverConstraint_getAppliedImpulse(btMultiBodySolverConstraint* obj);
btScalar btMultiBodySolverConstraint_getAppliedPushImpulse(btMultiBodySolverConstraint* obj);
btScalar btMultiBodySolverConstraint_getCfm(btMultiBodySolverConstraint* obj);
void btMultiBodySolverConstraint_getContactNormal1(btMultiBodySolverConstraint* obj, btScalar* value);
void btMultiBodySolverConstraint_getContactNormal2(btMultiBodySolverConstraint* obj, btScalar* value);
int btMultiBodySolverConstraint_getDeltaVelAindex(btMultiBodySolverConstraint* obj);
int btMultiBodySolverConstraint_getDeltaVelBindex(btMultiBodySolverConstraint* obj);
btScalar btMultiBodySolverConstraint_getFriction(btMultiBodySolverConstraint* obj);
int btMultiBodySolverConstraint_getFrictionIndex(btMultiBodySolverConstraint* obj);
int btMultiBodySolverConstraint_getJacAindex(btMultiBodySolverConstraint* obj);
int btMultiBodySolverConstraint_getJacBindex(btMultiBodySolverConstraint* obj);
btScalar btMultiBodySolverConstraint_getJacDiagABInv(btMultiBodySolverConstraint* obj);
int btMultiBodySolverConstraint_getLinkA(btMultiBodySolverConstraint* obj);
int btMultiBodySolverConstraint_getLinkB(btMultiBodySolverConstraint* obj);
btScalar btMultiBodySolverConstraint_getLowerLimit(btMultiBodySolverConstraint* obj);
btMultiBody* btMultiBodySolverConstraint_getMultiBodyA(btMultiBodySolverConstraint* obj);
btMultiBody* btMultiBodySolverConstraint_getMultiBodyB(btMultiBodySolverConstraint* obj);
void* btMultiBodySolverConstraint_getOriginalContactPoint(btMultiBodySolverConstraint* obj);
int btMultiBodySolverConstraint_getOverrideNumSolverIterations(btMultiBodySolverConstraint* obj);
void btMultiBodySolverConstraint_getRelpos1CrossNormal(btMultiBodySolverConstraint* obj, btScalar* value);
void btMultiBodySolverConstraint_getRelpos2CrossNormal(btMultiBodySolverConstraint* obj, btScalar* value);
btScalar btMultiBodySolverConstraint_getRhs(btMultiBodySolverConstraint* obj);
btScalar btMultiBodySolverConstraint_getRhsPenetration(btMultiBodySolverConstraint* obj);
int btMultiBodySolverConstraint_getSolverBodyIdA(btMultiBodySolverConstraint* obj);
int btMultiBodySolverConstraint_getSolverBodyIdB(btMultiBodySolverConstraint* obj);
btScalar btMultiBodySolverConstraint_getUnusedPadding4(btMultiBodySolverConstraint* obj);
btScalar btMultiBodySolverConstraint_getUpperLimit(btMultiBodySolverConstraint* obj);
void btMultiBodySolverConstraint_setAngularComponentA(btMultiBodySolverConstraint* obj, const btScalar* value);
void btMultiBodySolverConstraint_setAngularComponentB(btMultiBodySolverConstraint* obj, const btScalar* value);
void btMultiBodySolverConstraint_setAppliedImpulse(btMultiBodySolverConstraint* obj, btScalar value);
void btMultiBodySolverConstraint_setAppliedPushImpulse(btMultiBodySolverConstraint* obj, btScalar value);
void btMultiBodySolverConstraint_setCfm(btMultiBodySolverConstraint* obj, btScalar value);
void btMultiBodySolverConstraint_setContactNormal1(btMultiBodySolverConstraint* obj, const btScalar* value);
void btMultiBodySolverConstraint_setContactNormal2(btMultiBodySolverConstraint* obj, const btScalar* value);
void btMultiBodySolverConstraint_setDeltaVelAindex(btMultiBodySolverConstraint* obj, int value);
void btMultiBodySolverConstraint_setDeltaVelBindex(btMultiBodySolverConstraint* obj, int value);
void btMultiBodySolverConstraint_setFriction(btMultiBodySolverConstraint* obj, btScalar value);
void btMultiBodySolverConstraint_setFrictionIndex(btMultiBodySolverConstraint* obj, int value);
void btMultiBodySolverConstraint_setJacAindex(btMultiBodySolverConstraint* obj, int value);
void btMultiBodySolverConstraint_setJacBindex(btMultiBodySolverConstraint* obj, int value);
void btMultiBodySolverConstraint_setJacDiagABInv(btMultiBodySolverConstraint* obj, btScalar value);
void btMultiBodySolverConstraint_setLinkA(btMultiBodySolverConstraint* obj, int value);
void btMultiBodySolverConstraint_setLinkB(btMultiBodySolverConstraint* obj, int value);
void btMultiBodySolverConstraint_setLowerLimit(btMultiBodySolverConstraint* obj, btScalar value);
void btMultiBodySolverConstraint_setMultiBodyA(btMultiBodySolverConstraint* obj, btMultiBody* value);
void btMultiBodySolverConstraint_setMultiBodyB(btMultiBodySolverConstraint* obj, btMultiBody* value);
void btMultiBodySolverConstraint_setOriginalContactPoint(btMultiBodySolverConstraint* obj, void* value);
void btMultiBodySolverConstraint_setOverrideNumSolverIterations(btMultiBodySolverConstraint* obj, int value);
void btMultiBodySolverConstraint_setRelpos1CrossNormal(btMultiBodySolverConstraint* obj, const btScalar* value);
void btMultiBodySolverConstraint_setRelpos2CrossNormal(btMultiBodySolverConstraint* obj, const btScalar* value);
void btMultiBodySolverConstraint_setRhs(btMultiBodySolverConstraint* obj, btScalar value);
void btMultiBodySolverConstraint_setRhsPenetration(btMultiBodySolverConstraint* obj, btScalar value);
void btMultiBodySolverConstraint_setSolverBodyIdA(btMultiBodySolverConstraint* obj, int value);
void btMultiBodySolverConstraint_setSolverBodyIdB(btMultiBodySolverConstraint* obj, int value);
void btMultiBodySolverConstraint_setUnusedPadding4(btMultiBodySolverConstraint* obj, btScalar value);
void btMultiBodySolverConstraint_setUpperLimit(btMultiBodySolverConstraint* obj, btScalar value);
void btMultiBodySolverConstraint_delete(btMultiBodySolverConstraint* obj);
btMultiBody* btMultiBody_new(int n_links, btScalar mass, const btScalar* inertia, bool fixedBase, bool canSleep);
btMultiBody* btMultiBody_new2(int n_links, btScalar mass, const btScalar* inertia, bool fixedBase, bool canSleep, bool multiDof);
void btMultiBody_addBaseForce(btMultiBody* obj, const btScalar* f);
void btMultiBody_addBaseTorque(btMultiBody* obj, const btScalar* t);
void btMultiBody_addJointTorque(btMultiBody* obj, int i, btScalar Q);
void btMultiBody_addJointTorqueMultiDof(btMultiBody* obj, int i, const btScalar* Q);
void btMultiBody_addJointTorqueMultiDof2(btMultiBody* obj, int i, int dof, btScalar Q);
void btMultiBody_addLinkForce(btMultiBody* obj, int i, const btScalar* f);
void btMultiBody_addLinkTorque(btMultiBody* obj, int i, const btScalar* t);
void btMultiBody_applyDeltaVee(btMultiBody* obj, const btScalar* delta_vee, btScalar multiplier);
void btMultiBody_applyDeltaVee2(btMultiBody* obj, const btScalar* delta_vee);
void btMultiBody_applyDeltaVeeMultiDof(btMultiBody* obj, const btScalar* delta_vee, btScalar multiplier);
void btMultiBody_calcAccelerationDeltas(btMultiBody* obj, const btScalar* force, btScalar* output, btAlignedScalarArray* scratch_r, btAlignedVector3Array* scratch_v);
void btMultiBody_calcAccelerationDeltasMultiDof(btMultiBody* obj, const btScalar* force, btScalar* output, btAlignedScalarArray* scratch_r, btAlignedVector3Array* scratch_v);
void btMultiBody_checkMotionAndSleepIfRequired(btMultiBody* obj, btScalar timestep);
void btMultiBody_clearForcesAndTorques(btMultiBody* obj);
void btMultiBody_clearVelocities(btMultiBody* obj);
void btMultiBody_filConstraintJacobianMultiDof(btMultiBody* obj, int link, const btScalar* contact_point, const btScalar* normal_ang, const btScalar* normal_lin, btScalar* jac, btAlignedScalarArray* scratch_r, btAlignedVector3Array* scratch_v, btAlignedMatrix3x3Array* scratch_m);
void btMultiBody_fillContactJacobian(btMultiBody* obj, int link, const btScalar* contact_point, const btScalar* normal, btScalar* jac, btAlignedScalarArray* scratch_r, btAlignedVector3Array* scratch_v, btAlignedMatrix3x3Array* scratch_m);
void btMultiBody_fillContactJacobianMultiDof(btMultiBody* obj, int link, const btScalar* contact_point, const btScalar* normal, btScalar* jac, btAlignedScalarArray* scratch_r, btAlignedVector3Array* scratch_v, btAlignedMatrix3x3Array* scratch_m);
void btMultiBody_finalizeMultiDof(btMultiBody* obj);
btScalar btMultiBody_getAngularDamping(btMultiBody* obj);
void btMultiBody_getAngularMomentum(btMultiBody* obj, btScalar* value);
btMultiBodyLinkCollider* btMultiBody_getBaseCollider(btMultiBody* obj);
void btMultiBody_getBaseForce(btMultiBody* obj, btScalar* value);
void btMultiBody_getBaseInertia(btMultiBody* obj, btScalar* inertia);
btScalar btMultiBody_getBaseMass(btMultiBody* obj);
void btMultiBody_getBaseOmega(btMultiBody* obj, btScalar* omega);
void btMultiBody_getBasePos(btMultiBody* obj, btScalar* pos);
void btMultiBody_getBaseTorque(btMultiBody* obj, btScalar* value);
void btMultiBody_getBaseVel(btMultiBody* obj, btScalar* vel);
bool btMultiBody_getCanSleep(btMultiBody* obj);
int btMultiBody_getCompanionId(btMultiBody* obj);
btScalar btMultiBody_getJointPos(btMultiBody* obj, int i);
btScalar* btMultiBody_getJointPosMultiDof(btMultiBody* obj, int i);
btScalar btMultiBody_getJointTorque(btMultiBody* obj, int i);
btScalar* btMultiBody_getJointTorqueMultiDof(btMultiBody* obj, int i);
btScalar btMultiBody_getJointVel(btMultiBody* obj, int i);
btScalar* btMultiBody_getJointVelMultiDof(btMultiBody* obj, int i);
btScalar btMultiBody_getKineticEnergy(btMultiBody* obj);
btScalar btMultiBody_getLinearDamping(btMultiBody* obj);
btMultibodyLink* btMultiBody_getLink(btMultiBody* obj, int index);
void btMultiBody_getLinkForce(btMultiBody* obj, int i, btScalar* value);
void btMultiBody_getLinkInertia(btMultiBody* obj, int i, btScalar* value);
btScalar btMultiBody_getLinkMass(btMultiBody* obj, int i);
void btMultiBody_getLinkTorque(btMultiBody* obj, int i, btScalar* value);
btScalar btMultiBody_getMaxAppliedImpulse(btMultiBody* obj);
btScalar btMultiBody_getMaxCoordinateVelocity(btMultiBody* obj);
int btMultiBody_getNumDofs(btMultiBody* obj);
int btMultiBody_getNumLinks(btMultiBody* obj);
int btMultiBody_getNumPosVars(btMultiBody* obj);
int btMultiBody_getParent(btMultiBody* obj, int link_num);
void btMultiBody_getParentToLocalRot(btMultiBody* obj, int i, btScalar* value);
void btMultiBody_getRVector(btMultiBody* obj, int i, btScalar* value);
bool btMultiBody_getUseGyroTerm(btMultiBody* obj);
const btScalar* btMultiBody_getVelocityVector(btMultiBody* obj);
void btMultiBody_getWorldToBaseRot(btMultiBody* obj, btScalar* rot);
void btMultiBody_goToSleep(btMultiBody* obj);
bool btMultiBody_hasFixedBase(btMultiBody* obj);
bool btMultiBody_hasSelfCollision(btMultiBody* obj);
bool btMultiBody_isAwake(btMultiBody* obj);
bool btMultiBody_isMultiDof(btMultiBody* obj);
bool btMultiBody_isPosUpdated(btMultiBody* obj);
bool btMultiBody_isUsingGlobalVelocities(btMultiBody* obj);
bool btMultiBody_isUsingRK4Integration(btMultiBody* obj);
void btMultiBody_localDirToWorld(btMultiBody* obj, int i, const btScalar* vec, btScalar* value);
void btMultiBody_localPosToWorld(btMultiBody* obj, int i, const btScalar* vec, btScalar* value);
void btMultiBody_setAngularDamping(btMultiBody* obj, btScalar damp);
void btMultiBody_setBaseCollider(btMultiBody* obj, btMultiBodyLinkCollider* collider);
void btMultiBody_setBaseInertia(btMultiBody* obj, const btScalar* inertia);
void btMultiBody_setBaseMass(btMultiBody* obj, btScalar mass);
void btMultiBody_setBaseOmega(btMultiBody* obj, const btScalar* omega);
void btMultiBody_setBasePos(btMultiBody* obj, const btScalar* pos);
void btMultiBody_setBaseVel(btMultiBody* obj, const btScalar* vel);
void btMultiBody_setCanSleep(btMultiBody* obj, bool canSleep);
void btMultiBody_setCompanionId(btMultiBody* obj, int id);
void btMultiBody_setHasSelfCollision(btMultiBody* obj, bool hasSelfCollision);
void btMultiBody_setJointPos(btMultiBody* obj, int i, btScalar q);
void btMultiBody_setJointPosMultiDof(btMultiBody* obj, int i, btScalar* q);
void btMultiBody_setJointVel(btMultiBody* obj, int i, btScalar qdot);
void btMultiBody_setJointVelMultiDof(btMultiBody* obj, int i, btScalar* qdot);
void btMultiBody_setLinearDamping(btMultiBody* obj, btScalar damp);
void btMultiBody_setMaxAppliedImpulse(btMultiBody* obj, btScalar maxImp);
void btMultiBody_setMaxCoordinateVelocity(btMultiBody* obj, btScalar maxVel);
void btMultiBody_setNumLinks(btMultiBody* obj, int numLinks);
void btMultiBody_setPosUpdated(btMultiBody* obj, bool updated);
void btMultiBody_setupFixed(btMultiBody* obj, int linkIndex, btScalar mass, const btScalar* inertia, int parent, const btScalar* rotParentToThis, const btScalar* parentComToThisPivotOffset, const btScalar* thisPivotToThisComOffset, bool disableParentCollision);
void btMultiBody_setupPlanar(btMultiBody* obj, int i, btScalar mass, const btScalar* inertia, int parent, const btScalar* rotParentToThis, const btScalar* rotationAxis, const btScalar* parentComToThisComOffset);
void btMultiBody_setupPlanar2(btMultiBody* obj, int i, btScalar mass, const btScalar* inertia, int parent, const btScalar* rotParentToThis, const btScalar* rotationAxis, const btScalar* parentComToThisComOffset, bool disableParentCollision);
void btMultiBody_setupPrismatic(btMultiBody* obj, int i, btScalar mass, const btScalar* inertia, int parent, const btScalar* rotParentToThis, const btScalar* jointAxis, const btScalar* parentComToThisComOffset, const btScalar* thisPivotToThisComOffset, bool disableParentCollision);
void btMultiBody_setupRevolute(btMultiBody* obj, int linkIndex, btScalar mass, const btScalar* inertia, int parentIndex, const btScalar* rotParentToThis, const btScalar* jointAxis, const btScalar* parentComToThisPivotOffset, const btScalar* thisPivotToThisComOffset);
void btMultiBody_setupRevolute2(btMultiBody* obj, int linkIndex, btScalar mass, const btScalar* inertia, int parentIndex, const btScalar* rotParentToThis, const btScalar* jointAxis, const btScalar* parentComToThisPivotOffset, const btScalar* thisPivotToThisComOffset, bool disableParentCollision);
void btMultiBody_setupSpherical(btMultiBody* obj, int linkIndex, btScalar mass, const btScalar* inertia, int parent, const btScalar* rotParentToThis, const btScalar* parentComToThisPivotOffset, const btScalar* thisPivotToThisComOffset);
void btMultiBody_setupSpherical2(btMultiBody* obj, int linkIndex, btScalar mass, const btScalar* inertia, int parent, const btScalar* rotParentToThis, const btScalar* parentComToThisPivotOffset, const btScalar* thisPivotToThisComOffset, bool disableParentCollision);
void btMultiBody_setUseGyroTerm(btMultiBody* obj, bool useGyro);
void btMultiBody_setWorldToBaseRot(btMultiBody* obj, const btScalar* rot);
void btMultiBody_stepPositions(btMultiBody* obj, btScalar dt);
void btMultiBody_stepPositionsMultiDof(btMultiBody* obj, btScalar dt);
void btMultiBody_stepPositionsMultiDof2(btMultiBody* obj, btScalar dt, btScalar* pq);
void btMultiBody_stepPositionsMultiDof3(btMultiBody* obj, btScalar dt, btScalar* pq, btScalar* pqd);
void btMultiBody_stepVelocities(btMultiBody* obj, btScalar dt, btAlignedScalarArray* scratch_r, btAlignedVector3Array* scratch_v, btAlignedMatrix3x3Array* scratch_m);
void btMultiBody_stepVelocitiesMultiDof(btMultiBody* obj, btScalar dt, btAlignedScalarArray* scratch_r, btAlignedVector3Array* scratch_v, btAlignedMatrix3x3Array* scratch_m);
void btMultiBody_useGlobalVelocities(btMultiBody* obj, bool use);
void btMultiBody_useRK4Integration(btMultiBody* obj, bool use);
void btMultiBody_wakeUp(btMultiBody* obj);
void btMultiBody_worldDirToLocal(btMultiBody* obj, int i, const btScalar* vec, btScalar* value);
void btMultiBody_worldPosToLocal(btMultiBody* obj, int i, const btScalar* vec, btScalar* value);
void btMultiBody_delete(btMultiBody* obj);
btMultiSphereShape* btMultiSphereShape_new(const btScalar* positions, const btScalar* radi, int numSpheres);
btMultiSphereShape* btMultiSphereShape_new2(const btVector3* positions, const btScalar* radi, int numSpheres);
int btMultiSphereShape_getSphereCount(btMultiSphereShape* obj);
void btMultiSphereShape_getSpherePosition(btMultiSphereShape* obj, int index, btScalar* value);
btScalar btMultiSphereShape_getSphereRadius(btMultiSphereShape* obj, int index);
btPositionAndRadius* btPositionAndRadius_new();
void btPositionAndRadius_getPos(btPositionAndRadius* obj, btScalar* value);
float btPositionAndRadius_getRadius(btPositionAndRadius* obj);
void btPositionAndRadius_setPos(btPositionAndRadius* obj, const btScalar* value);
void btPositionAndRadius_setRadius(btPositionAndRadius* obj, float value);
void btPositionAndRadius_delete(btPositionAndRadius* obj);
btMultimaterialTriangleMeshShape* btMultimaterialTriangleMeshShape_new(btStridingMeshInterface* meshInterface, bool useQuantizedAabbCompression);
btMultimaterialTriangleMeshShape* btMultimaterialTriangleMeshShape_new2(btStridingMeshInterface* meshInterface, bool useQuantizedAabbCompression, bool buildBvh);
btMultimaterialTriangleMeshShape* btMultimaterialTriangleMeshShape_new3(btStridingMeshInterface* meshInterface, bool useQuantizedAabbCompression, const btScalar* bvhAabbMin, const btScalar* bvhAabbMax);
btMultimaterialTriangleMeshShape* btMultimaterialTriangleMeshShape_new4(btStridingMeshInterface* meshInterface, bool useQuantizedAabbCompression, const btScalar* bvhAabbMin, const btScalar* bvhAabbMax, bool buildBvh);
const btMaterial* btMultimaterialTriangleMeshShape_getMaterialProperties(btMultimaterialTriangleMeshShape* obj, int partID, int triIndex);
btNNCGConstraintSolver* btNNCGConstraintSolver_new();
bool btNNCGConstraintSolver_getOnlyForNoneContact(btNNCGConstraintSolver* obj);
void btNNCGConstraintSolver_setOnlyForNoneContact(btNNCGConstraintSolver* obj, bool value);
btOptimizedBvh* btOptimizedBvh_new();
void btOptimizedBvh_build(btOptimizedBvh* obj, btStridingMeshInterface* triangles, bool useQuantizedAabbCompression, const btScalar* bvhAabbMin, const btScalar* bvhAabbMax);
btOptimizedBvh* btOptimizedBvh_deSerializeInPlace(void* i_alignedDataBuffer, unsigned int i_dataBufferSize, bool i_swapEndian);
void btOptimizedBvh_refit(btOptimizedBvh* obj, btStridingMeshInterface* triangles, const btScalar* aabbMin, const btScalar* aabbMax);
void btOptimizedBvh_refitPartial(btOptimizedBvh* obj, btStridingMeshInterface* triangles, const btScalar* aabbMin, const btScalar* aabbMax);
bool btOptimizedBvh_serializeInPlace(btOptimizedBvh* obj, void* o_alignedDataBuffer, unsigned int i_dataBufferSize, bool i_swapEndian);
void btOptimizedBvh_updateBvhNodes(btOptimizedBvh* obj, btStridingMeshInterface* meshInterface, int firstNode, int endNode, int index);
bool btOverlapCallback_processOverlap(btOverlapCallback* obj, btBroadphasePair* pair);
void btOverlapCallback_delete(btOverlapCallback* obj);
bool btOverlapFilterCallback_needBroadphaseCollision(btOverlapFilterCallback* obj, btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1);
void btOverlapFilterCallback_delete(btOverlapFilterCallback* obj);
void btOverlappingPairCache_cleanOverlappingPair(btOverlappingPairCache* obj, btBroadphasePair* pair, btDispatcher* dispatcher);
void btOverlappingPairCache_cleanProxyFromPairs(btOverlappingPairCache* obj, btBroadphaseProxy* proxy, btDispatcher* dispatcher);
btBroadphasePair* btOverlappingPairCache_findPair(btOverlappingPairCache* obj, btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1);
int btOverlappingPairCache_getNumOverlappingPairs(btOverlappingPairCache* obj);
btAlignedBroadphasePairArray* btOverlappingPairCache_getOverlappingPairArray(btOverlappingPairCache* obj);
btBroadphasePair* btOverlappingPairCache_getOverlappingPairArrayPtr(btOverlappingPairCache* obj);
bool btOverlappingPairCache_hasDeferredRemoval(btOverlappingPairCache* obj);
void btOverlappingPairCache_processAllOverlappingPairs(btOverlappingPairCache* obj, btOverlapCallback* __unnamed0, btDispatcher* dispatcher);
void btOverlappingPairCache_setInternalGhostPairCallback(btOverlappingPairCache* obj, btOverlappingPairCallback* ghostPairCallback);
void btOverlappingPairCache_setOverlapFilterCallback(btOverlappingPairCache* obj, btOverlapFilterCallback* callback);
void btOverlappingPairCache_sortOverlappingPairs(btOverlappingPairCache* obj, btDispatcher* dispatcher);
btHashedOverlappingPairCache* btHashedOverlappingPairCache_new();
int btHashedOverlappingPairCache_GetCount(btHashedOverlappingPairCache* obj);
btOverlapFilterCallback* btHashedOverlappingPairCache_getOverlapFilterCallback(btHashedOverlappingPairCache* obj);
bool btHashedOverlappingPairCache_needsBroadphaseCollision(btHashedOverlappingPairCache* obj, btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1);
btSortedOverlappingPairCache* btSortedOverlappingPairCache_new();
btOverlapFilterCallback* btSortedOverlappingPairCache_getOverlapFilterCallback(btSortedOverlappingPairCache* obj);
bool btSortedOverlappingPairCache_needsBroadphaseCollision(btSortedOverlappingPairCache* obj, btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1);
btNullPairCache* btNullPairCache_new();
btBroadphasePair* btOverlappingPairCallback_addOverlappingPair(btOverlappingPairCallback* obj, btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1);
void* btOverlappingPairCallback_removeOverlappingPair(btOverlappingPairCallback* obj, btBroadphaseProxy* proxy0, btBroadphaseProxy* proxy1, btDispatcher* dispatcher);
void btOverlappingPairCallback_removeOverlappingPairsContainingProxy(btOverlappingPairCallback* obj, btBroadphaseProxy* proxy0, btDispatcher* dispatcher);
void btOverlappingPairCallback_delete(btOverlappingPairCallback* obj);
btPersistentManifold* btPersistentManifold_new();
btPersistentManifold* btPersistentManifold_new2(const btCollisionObject* body0, const btCollisionObject* body1, int __unnamed2, btScalar contactBreakingThreshold, btScalar contactProcessingThreshold);
int btPersistentManifold_addManifoldPoint(btPersistentManifold* obj, const btManifoldPoint* newPoint);
int btPersistentManifold_addManifoldPoint2(btPersistentManifold* obj, const btManifoldPoint* newPoint, bool isPredictive);
void btPersistentManifold_clearManifold(btPersistentManifold* obj);
void btPersistentManifold_clearUserCache(btPersistentManifold* obj, btManifoldPoint* pt);
const btCollisionObject* btPersistentManifold_getBody0(btPersistentManifold* obj);
const btCollisionObject* btPersistentManifold_getBody1(btPersistentManifold* obj);
int btPersistentManifold_getCacheEntry(btPersistentManifold* obj, const btManifoldPoint* newPoint);
int btPersistentManifold_getCompanionIdA(btPersistentManifold* obj);
int btPersistentManifold_getCompanionIdB(btPersistentManifold* obj);
btScalar btPersistentManifold_getContactBreakingThreshold(btPersistentManifold* obj);
btManifoldPoint* btPersistentManifold_getContactPoint(btPersistentManifold* obj, int index);
btScalar btPersistentManifold_getContactProcessingThreshold(btPersistentManifold* obj);
int btPersistentManifold_getIndex1a(btPersistentManifold* obj);
int btPersistentManifold_getNumContacts(btPersistentManifold* obj);
void btPersistentManifold_refreshContactPoints(btPersistentManifold* obj, const btScalar* trA, const btScalar* trB);
void btPersistentManifold_removeContactPoint(btPersistentManifold* obj, int index);
void btPersistentManifold_replaceContactPoint(btPersistentManifold* obj, const btManifoldPoint* newPoint, int insertIndex);
void btPersistentManifold_setBodies(btPersistentManifold* obj, const btCollisionObject* body0, const btCollisionObject* body1);
void btPersistentManifold_setCompanionIdA(btPersistentManifold* obj, int value);
void btPersistentManifold_setCompanionIdB(btPersistentManifold* obj, int value);
void btPersistentManifold_setContactBreakingThreshold(btPersistentManifold* obj, btScalar contactBreakingThreshold);
void btPersistentManifold_setContactProcessingThreshold(btPersistentManifold* obj, btScalar contactProcessingThreshold);
void btPersistentManifold_setIndex1a(btPersistentManifold* obj, int value);
void btPersistentManifold_setNumContacts(btPersistentManifold* obj, int cachedPoints);
bool btPersistentManifold_validContactDistance(btPersistentManifold* obj, const btManifoldPoint* pt);
btConstraintSetting* btConstraintSetting_new();
btScalar btConstraintSetting_getDamping(btConstraintSetting* obj);
btScalar btConstraintSetting_getImpulseClamp(btConstraintSetting* obj);
btScalar btConstraintSetting_getTau(btConstraintSetting* obj);
void btConstraintSetting_setDamping(btConstraintSetting* obj, btScalar value);
void btConstraintSetting_setImpulseClamp(btConstraintSetting* obj, btScalar value);
void btConstraintSetting_setTau(btConstraintSetting* obj, btScalar value);
void btConstraintSetting_delete(btConstraintSetting* obj);
btPoint2PointConstraint* btPoint2PointConstraint_new(btRigidBody* rbA, btRigidBody* rbB, const btScalar* pivotInA, const btScalar* pivotInB);
btPoint2PointConstraint* btPoint2PointConstraint_new2(btRigidBody* rbA, const btScalar* pivotInA);
void btPoint2PointConstraint_getInfo1NonVirtual(btPoint2PointConstraint* obj, btTypedConstraint_btConstraintInfo1* info);
void btPoint2PointConstraint_getInfo2NonVirtual(btPoint2PointConstraint* obj, btTypedConstraint_btConstraintInfo2* info, const btScalar* body0_trans, const btScalar* body1_trans);
void btPoint2PointConstraint_getPivotInA(btPoint2PointConstraint* obj, btScalar* value);
void btPoint2PointConstraint_getPivotInB(btPoint2PointConstraint* obj, btScalar* value);
btConstraintSetting* btPoint2PointConstraint_getSetting(btPoint2PointConstraint* obj);
bool btPoint2PointConstraint_getUseSolveConstraintObsolete(btPoint2PointConstraint* obj);
void btPoint2PointConstraint_setPivotA(btPoint2PointConstraint* obj, const btScalar* pivotA);
void btPoint2PointConstraint_setPivotB(btPoint2PointConstraint* obj, const btScalar* pivotB);
void btPoint2PointConstraint_setUseSolveConstraintObsolete(btPoint2PointConstraint* obj, bool value);
void btPoint2PointConstraint_updateRHS(btPoint2PointConstraint* obj, btScalar timeStep);
btPointCollector* btPointCollector_new();
btScalar btPointCollector_getDistance(btPointCollector* obj);
bool btPointCollector_getHasResult(btPointCollector* obj);
void btPointCollector_getNormalOnBInWorld(btPointCollector* obj, btScalar* value);
void btPointCollector_getPointInWorld(btPointCollector* obj, btScalar* value);
void btPointCollector_setDistance(btPointCollector* obj, btScalar value);
void btPointCollector_setHasResult(btPointCollector* obj, bool value);
void btPointCollector_setNormalOnBInWorld(btPointCollector* obj, const btScalar* value);
void btPointCollector_setPointInWorld(btPointCollector* obj, const btScalar* value);
btPolarDecomposition* btPolarDecomposition_new();
btPolarDecomposition* btPolarDecomposition_new2(btScalar tolerance);
btPolarDecomposition* btPolarDecomposition_new3(btScalar tolerance, unsigned int maxIterations);
unsigned int btPolarDecomposition_decompose(btPolarDecomposition* obj, const btScalar* a, btScalar* u, btScalar* h);
unsigned int btPolarDecomposition_maxIterations(btPolarDecomposition* obj);
void btPolarDecomposition_delete(btPolarDecomposition* obj);
const btConvexPolyhedron* btPolyhedralConvexShape_getConvexPolyhedron(btPolyhedralConvexShape* obj);
void btPolyhedralConvexShape_getEdge(btPolyhedralConvexShape* obj, int i, btScalar* pa, btScalar* pb);
int btPolyhedralConvexShape_getNumEdges(btPolyhedralConvexShape* obj);
int btPolyhedralConvexShape_getNumPlanes(btPolyhedralConvexShape* obj);
int btPolyhedralConvexShape_getNumVertices(btPolyhedralConvexShape* obj);
void btPolyhedralConvexShape_getPlane(btPolyhedralConvexShape* obj, btScalar* planeNormal, btScalar* planeSupport, int i);
void btPolyhedralConvexShape_getVertex(btPolyhedralConvexShape* obj, int i, btScalar* vtx);
bool btPolyhedralConvexShape_initializePolyhedralFeatures(btPolyhedralConvexShape* obj);
bool btPolyhedralConvexShape_initializePolyhedralFeatures2(btPolyhedralConvexShape* obj, int shiftVerticesByMargin);
bool btPolyhedralConvexShape_isInside(btPolyhedralConvexShape* obj, const btScalar* pt, btScalar tolerance);
void btPolyhedralConvexAabbCachingShape_getNonvirtualAabb(btPolyhedralConvexAabbCachingShape* obj, const btScalar* trans, btScalar* aabbMin, btScalar* aabbMax, btScalar margin);
void btPolyhedralConvexAabbCachingShape_recalcLocalAabb(btPolyhedralConvexAabbCachingShape* obj);
btQuantizedBvhNode* btQuantizedBvhNode_new();
int btQuantizedBvhNode_getEscapeIndex(btQuantizedBvhNode* obj);
int btQuantizedBvhNode_getEscapeIndexOrTriangleIndex(btQuantizedBvhNode* obj);
int btQuantizedBvhNode_getPartId(btQuantizedBvhNode* obj);
unsigned short* btQuantizedBvhNode_getQuantizedAabbMax(btQuantizedBvhNode* obj);
unsigned short* btQuantizedBvhNode_getQuantizedAabbMin(btQuantizedBvhNode* obj);
int btQuantizedBvhNode_getTriangleIndex(btQuantizedBvhNode* obj);
bool btQuantizedBvhNode_isLeafNode(btQuantizedBvhNode* obj);
void btQuantizedBvhNode_setEscapeIndexOrTriangleIndex(btQuantizedBvhNode* obj, int value);
void btQuantizedBvhNode_delete(btQuantizedBvhNode* obj);
btOptimizedBvhNode* btOptimizedBvhNode_new();
void btOptimizedBvhNode_getAabbMaxOrg(btOptimizedBvhNode* obj, btScalar* value);
void btOptimizedBvhNode_getAabbMinOrg(btOptimizedBvhNode* obj, btScalar* value);
int btOptimizedBvhNode_getEscapeIndex(btOptimizedBvhNode* obj);
char* btOptimizedBvhNode_getPadding(btOptimizedBvhNode* obj);
int btOptimizedBvhNode_getSubPart(btOptimizedBvhNode* obj);
int btOptimizedBvhNode_getTriangleIndex(btOptimizedBvhNode* obj);
void btOptimizedBvhNode_setAabbMaxOrg(btOptimizedBvhNode* obj, const btScalar* value);
void btOptimizedBvhNode_setAabbMinOrg(btOptimizedBvhNode* obj, const btScalar* value);
void btOptimizedBvhNode_setEscapeIndex(btOptimizedBvhNode* obj, int value);
void btOptimizedBvhNode_setSubPart(btOptimizedBvhNode* obj, int value);
void btOptimizedBvhNode_setTriangleIndex(btOptimizedBvhNode* obj, int value);
void btOptimizedBvhNode_delete(btOptimizedBvhNode* obj);
void btNodeOverlapCallback_processNode(btNodeOverlapCallback* obj, int subPart, int triangleIndex);
void btNodeOverlapCallback_delete(btNodeOverlapCallback* obj);
btQuantizedBvh* btQuantizedBvh_new();
void btQuantizedBvh_buildInternal(btQuantizedBvh* obj);
unsigned int btQuantizedBvh_calculateSerializeBufferSize(btQuantizedBvh* obj);
int btQuantizedBvh_calculateSerializeBufferSizeNew(btQuantizedBvh* obj);
void btQuantizedBvh_deSerializeDouble(btQuantizedBvh* obj, btQuantizedBvhDoubleData* quantizedBvhDoubleData);
void btQuantizedBvh_deSerializeFloat(btQuantizedBvh* obj, btQuantizedBvhFloatData* quantizedBvhFloatData);
btQuantizedBvh* btQuantizedBvh_deSerializeInPlace(void* i_alignedDataBuffer, unsigned int i_dataBufferSize, bool i_swapEndian);
unsigned int btQuantizedBvh_getAlignmentSerializationPadding();
QuantizedNodeArray* btQuantizedBvh_getLeafNodeArray(btQuantizedBvh* obj);
QuantizedNodeArray* btQuantizedBvh_getQuantizedNodeArray(btQuantizedBvh* obj);
BvhSubtreeInfoArray* btQuantizedBvh_getSubtreeInfoArray(btQuantizedBvh* obj);
bool btQuantizedBvh_isQuantized(btQuantizedBvh* obj);
void btQuantizedBvh_quantize(btQuantizedBvh* obj, unsigned short* out, const btScalar* point, int isMax);
void btQuantizedBvh_quantizeWithClamp(btQuantizedBvh* obj, unsigned short* out, const btScalar* point2, int isMax);
void btQuantizedBvh_reportAabbOverlappingNodex(btQuantizedBvh* obj, btNodeOverlapCallback* nodeCallback, const btScalar* aabbMin, const btScalar* aabbMax);
void btQuantizedBvh_reportBoxCastOverlappingNodex(btQuantizedBvh* obj, btNodeOverlapCallback* nodeCallback, const btScalar* raySource, const btScalar* rayTarget, const btScalar* aabbMin, const btScalar* aabbMax);
void btQuantizedBvh_reportRayOverlappingNodex(btQuantizedBvh* obj, btNodeOverlapCallback* nodeCallback, const btScalar* raySource, const btScalar* rayTarget);
bool btQuantizedBvh_serialize(btQuantizedBvh* obj, void* o_alignedDataBuffer, unsigned int i_dataBufferSize, bool i_swapEndian);
const char* btQuantizedBvh_serialize2(btQuantizedBvh* obj, void* dataBuffer, btSerializer* serializer);
void btQuantizedBvh_setQuantizationValues(btQuantizedBvh* obj, const btScalar* bvhAabbMin, const btScalar* bvhAabbMax);
void btQuantizedBvh_setQuantizationValues2(btQuantizedBvh* obj, const btScalar* bvhAabbMin, const btScalar* bvhAabbMax, btScalar quantizationMargin);
void btQuantizedBvh_setTraversalMode(btQuantizedBvh* obj, btQuantizedBvh_btTraversalMode traversalMode);
void btQuantizedBvh_unQuantize(btQuantizedBvh* obj, const unsigned short* vecIn, btScalar* value);
void btQuantizedBvh_delete(btQuantizedBvh* obj);
btRaycastVehicle_btVehicleTuning* btRaycastVehicle_btVehicleTuning_new();
btScalar btRaycastVehicle_btVehicleTuning_getFrictionSlip(btRaycastVehicle_btVehicleTuning* obj);
btScalar btRaycastVehicle_btVehicleTuning_getMaxSuspensionForce(btRaycastVehicle_btVehicleTuning* obj);
btScalar btRaycastVehicle_btVehicleTuning_getMaxSuspensionTravelCm(btRaycastVehicle_btVehicleTuning* obj);
btScalar btRaycastVehicle_btVehicleTuning_getSuspensionCompression(btRaycastVehicle_btVehicleTuning* obj);
btScalar btRaycastVehicle_btVehicleTuning_getSuspensionDamping(btRaycastVehicle_btVehicleTuning* obj);
btScalar btRaycastVehicle_btVehicleTuning_getSuspensionStiffness(btRaycastVehicle_btVehicleTuning* obj);
void btRaycastVehicle_btVehicleTuning_setFrictionSlip(btRaycastVehicle_btVehicleTuning* obj, btScalar value);
void btRaycastVehicle_btVehicleTuning_setMaxSuspensionForce(btRaycastVehicle_btVehicleTuning* obj, btScalar value);
void btRaycastVehicle_btVehicleTuning_setMaxSuspensionTravelCm(btRaycastVehicle_btVehicleTuning* obj, btScalar value);
void btRaycastVehicle_btVehicleTuning_setSuspensionCompression(btRaycastVehicle_btVehicleTuning* obj, btScalar value);
void btRaycastVehicle_btVehicleTuning_setSuspensionDamping(btRaycastVehicle_btVehicleTuning* obj, btScalar value);
void btRaycastVehicle_btVehicleTuning_setSuspensionStiffness(btRaycastVehicle_btVehicleTuning* obj, btScalar value);
void btRaycastVehicle_btVehicleTuning_delete(btRaycastVehicle_btVehicleTuning* obj);
btRaycastVehicle* btRaycastVehicle_new(const btRaycastVehicle_btVehicleTuning* tuning, btRigidBody* chassis, btVehicleRaycaster* raycaster);
btWheelInfo* btRaycastVehicle_addWheel(btRaycastVehicle* obj, const btScalar* connectionPointCS0, const btScalar* wheelDirectionCS0, const btScalar* wheelAxleCS, btScalar suspensionRestLength, btScalar wheelRadius, const btRaycastVehicle_btVehicleTuning* tuning, bool isFrontWheel);
void btRaycastVehicle_applyEngineForce(btRaycastVehicle* obj, btScalar force, int wheel);
void btRaycastVehicle_getChassisWorldTransform(btRaycastVehicle* obj, btScalar* value);
btScalar btRaycastVehicle_getCurrentSpeedKmHour(btRaycastVehicle* obj);
int btRaycastVehicle_getForwardAxis(btRaycastVehicle* obj);
void btRaycastVehicle_getForwardVector(btRaycastVehicle* obj, btScalar* value);
int btRaycastVehicle_getNumWheels(btRaycastVehicle* obj);
int btRaycastVehicle_getRightAxis(btRaycastVehicle* obj);
btRigidBody* btRaycastVehicle_getRigidBody(btRaycastVehicle* obj);
btScalar btRaycastVehicle_getSteeringValue(btRaycastVehicle* obj, int wheel);
int btRaycastVehicle_getUpAxis(btRaycastVehicle* obj);
int btRaycastVehicle_getUserConstraintId(btRaycastVehicle* obj);
int btRaycastVehicle_getUserConstraintType(btRaycastVehicle* obj);
btWheelInfo* btRaycastVehicle_getWheelInfo(btRaycastVehicle* obj, int index);
btAlignedWheelInfoArray* btRaycastVehicle_getWheelInfo2(btRaycastVehicle* obj);
void btRaycastVehicle_getWheelTransformWS(btRaycastVehicle* obj, int wheelIndex, btScalar* value);
btScalar btRaycastVehicle_rayCast(btRaycastVehicle* obj, btWheelInfo* wheel);
void btRaycastVehicle_resetSuspension(btRaycastVehicle* obj);
void btRaycastVehicle_setBrake(btRaycastVehicle* obj, btScalar brake, int wheelIndex);
void btRaycastVehicle_setCoordinateSystem(btRaycastVehicle* obj, int rightIndex, int upIndex, int forwardIndex);
void btRaycastVehicle_setPitchControl(btRaycastVehicle* obj, btScalar pitch);
void btRaycastVehicle_setSteeringValue(btRaycastVehicle* obj, btScalar steering, int wheel);
void btRaycastVehicle_setUserConstraintId(btRaycastVehicle* obj, int uid);
void btRaycastVehicle_setUserConstraintType(btRaycastVehicle* obj, int userConstraintType);
void btRaycastVehicle_updateFriction(btRaycastVehicle* obj, btScalar timeStep);
void btRaycastVehicle_updateSuspension(btRaycastVehicle* obj, btScalar deltaTime);
void btRaycastVehicle_updateVehicle(btRaycastVehicle* obj, btScalar step);
void btRaycastVehicle_updateWheelTransform(btRaycastVehicle* obj, int wheelIndex);
void btRaycastVehicle_updateWheelTransform2(btRaycastVehicle* obj, int wheelIndex, bool interpolatedTransform);
void btRaycastVehicle_updateWheelTransformsWS(btRaycastVehicle* obj, btWheelInfo* wheel);
void btRaycastVehicle_updateWheelTransformsWS2(btRaycastVehicle* obj, btWheelInfo* wheel, bool interpolatedTransform);
btDefaultVehicleRaycaster* btDefaultVehicleRaycaster_new(btDynamicsWorld* world);
btRigidBody_btRigidBodyConstructionInfo* btRigidBody_btRigidBodyConstructionInfo_new(btScalar mass, btMotionState* motionState, btCollisionShape* collisionShape);
btRigidBody_btRigidBodyConstructionInfo* btRigidBody_btRigidBodyConstructionInfo_new2(btScalar mass, btMotionState* motionState, btCollisionShape* collisionShape, const btScalar* localInertia);
btScalar btRigidBody_btRigidBodyConstructionInfo_getAdditionalAngularDampingFactor(btRigidBody_btRigidBodyConstructionInfo* obj);
btScalar btRigidBody_btRigidBodyConstructionInfo_getAdditionalAngularDampingThresholdSqr(btRigidBody_btRigidBodyConstructionInfo* obj);
bool btRigidBody_btRigidBodyConstructionInfo_getAdditionalDamping(btRigidBody_btRigidBodyConstructionInfo* obj);
btScalar btRigidBody_btRigidBodyConstructionInfo_getAdditionalDampingFactor(btRigidBody_btRigidBodyConstructionInfo* obj);
btScalar btRigidBody_btRigidBodyConstructionInfo_getAdditionalLinearDampingThresholdSqr(btRigidBody_btRigidBodyConstructionInfo* obj);
btScalar btRigidBody_btRigidBodyConstructionInfo_getAngularDamping(btRigidBody_btRigidBodyConstructionInfo* obj);
btScalar btRigidBody_btRigidBodyConstructionInfo_getAngularSleepingThreshold(btRigidBody_btRigidBodyConstructionInfo* obj);
btCollisionShape* btRigidBody_btRigidBodyConstructionInfo_getCollisionShape(btRigidBody_btRigidBodyConstructionInfo* obj);
btScalar btRigidBody_btRigidBodyConstructionInfo_getFriction(btRigidBody_btRigidBodyConstructionInfo* obj);
btScalar btRigidBody_btRigidBodyConstructionInfo_getLinearDamping(btRigidBody_btRigidBodyConstructionInfo* obj);
btScalar btRigidBody_btRigidBodyConstructionInfo_getLinearSleepingThreshold(btRigidBody_btRigidBodyConstructionInfo* obj);
void btRigidBody_btRigidBodyConstructionInfo_getLocalInertia(btRigidBody_btRigidBodyConstructionInfo* obj, btScalar* value);
btScalar btRigidBody_btRigidBodyConstructionInfo_getMass(btRigidBody_btRigidBodyConstructionInfo* obj);
btMotionState* btRigidBody_btRigidBodyConstructionInfo_getMotionState(btRigidBody_btRigidBodyConstructionInfo* obj);
btScalar btRigidBody_btRigidBodyConstructionInfo_getRestitution(btRigidBody_btRigidBodyConstructionInfo* obj);
btScalar btRigidBody_btRigidBodyConstructionInfo_getRollingFriction(btRigidBody_btRigidBodyConstructionInfo* obj);
void btRigidBody_btRigidBodyConstructionInfo_getStartWorldTransform(btRigidBody_btRigidBodyConstructionInfo* obj, btScalar* value);
void btRigidBody_btRigidBodyConstructionInfo_setAdditionalAngularDampingFactor(btRigidBody_btRigidBodyConstructionInfo* obj, btScalar value);
void btRigidBody_btRigidBodyConstructionInfo_setAdditionalAngularDampingThresholdSqr(btRigidBody_btRigidBodyConstructionInfo* obj, btScalar value);
void btRigidBody_btRigidBodyConstructionInfo_setAdditionalDamping(btRigidBody_btRigidBodyConstructionInfo* obj, bool value);
void btRigidBody_btRigidBodyConstructionInfo_setAdditionalDampingFactor(btRigidBody_btRigidBodyConstructionInfo* obj, btScalar value);
void btRigidBody_btRigidBodyConstructionInfo_setAdditionalLinearDampingThresholdSqr(btRigidBody_btRigidBodyConstructionInfo* obj, btScalar value);
void btRigidBody_btRigidBodyConstructionInfo_setAngularDamping(btRigidBody_btRigidBodyConstructionInfo* obj, btScalar value);
void btRigidBody_btRigidBodyConstructionInfo_setAngularSleepingThreshold(btRigidBody_btRigidBodyConstructionInfo* obj, btScalar value);
void btRigidBody_btRigidBodyConstructionInfo_setCollisionShape(btRigidBody_btRigidBodyConstructionInfo* obj, btCollisionShape* value);
void btRigidBody_btRigidBodyConstructionInfo_setFriction(btRigidBody_btRigidBodyConstructionInfo* obj, btScalar value);
void btRigidBody_btRigidBodyConstructionInfo_setLinearDamping(btRigidBody_btRigidBodyConstructionInfo* obj, btScalar value);
void btRigidBody_btRigidBodyConstructionInfo_setLinearSleepingThreshold(btRigidBody_btRigidBodyConstructionInfo* obj, btScalar value);
void btRigidBody_btRigidBodyConstructionInfo_setLocalInertia(btRigidBody_btRigidBodyConstructionInfo* obj, const btScalar* value);
void btRigidBody_btRigidBodyConstructionInfo_setMass(btRigidBody_btRigidBodyConstructionInfo* obj, btScalar value);
void btRigidBody_btRigidBodyConstructionInfo_setMotionState(btRigidBody_btRigidBodyConstructionInfo* obj, btMotionState* value);
void btRigidBody_btRigidBodyConstructionInfo_setRestitution(btRigidBody_btRigidBodyConstructionInfo* obj, btScalar value);
void btRigidBody_btRigidBodyConstructionInfo_setRollingFriction(btRigidBody_btRigidBodyConstructionInfo* obj, btScalar value);
void btRigidBody_btRigidBodyConstructionInfo_setStartWorldTransform(btRigidBody_btRigidBodyConstructionInfo* obj, const btScalar* value);
void btRigidBody_btRigidBodyConstructionInfo_delete(btRigidBody_btRigidBodyConstructionInfo* obj);
btRigidBody* btRigidBody_new(const btRigidBody_btRigidBodyConstructionInfo* constructionInfo);
btRigidBody* btRigidBody_new2(btScalar mass, btMotionState* motionState, btCollisionShape* collisionShape);
btRigidBody* btRigidBody_new3(btScalar mass, btMotionState* motionState, btCollisionShape* collisionShape, const btScalar* localInertia);
void btRigidBody_addConstraintRef(btRigidBody* obj, btTypedConstraint* c);
void btRigidBody_applyCentralForce(btRigidBody* obj, const btScalar* force);
void btRigidBody_applyCentralImpulse(btRigidBody* obj, const btScalar* impulse);
void btRigidBody_applyDamping(btRigidBody* obj, btScalar timeStep);
void btRigidBody_applyForce(btRigidBody* obj, const btScalar* force, const btScalar* rel_pos);
void btRigidBody_applyGravity(btRigidBody* obj);
void btRigidBody_applyImpulse(btRigidBody* obj, const btScalar* impulse, const btScalar* rel_pos);
void btRigidBody_applyTorque(btRigidBody* obj, const btScalar* torque);
void btRigidBody_applyTorqueImpulse(btRigidBody* obj, const btScalar* torque);
void btRigidBody_clearForces(btRigidBody* obj);
btScalar btRigidBody_computeAngularImpulseDenominator(btRigidBody* obj, const btScalar* axis);
void btRigidBody_computeGyroscopicForceExplicit(btRigidBody* obj, btScalar maxGyroscopicForce, btScalar* value);
void btRigidBody_computeGyroscopicImpulseImplicit_Body(btRigidBody* obj, btScalar step, btScalar* value);
void btRigidBody_computeGyroscopicImpulseImplicit_World(btRigidBody* obj, btScalar dt, btScalar* value);
btScalar btRigidBody_computeImpulseDenominator(btRigidBody* obj, const btScalar* pos, const btScalar* normal);
void btRigidBody_getAabb(btRigidBody* obj, btScalar* aabbMin, btScalar* aabbMax);
btScalar btRigidBody_getAngularDamping(btRigidBody* obj);
void btRigidBody_getAngularFactor(btRigidBody* obj, btScalar* angFac);
btScalar btRigidBody_getAngularSleepingThreshold(btRigidBody* obj);
void btRigidBody_getAngularVelocity(btRigidBody* obj, btScalar* ang_vel);
btBroadphaseProxy* btRigidBody_getBroadphaseProxy(btRigidBody* obj);
void btRigidBody_getCenterOfMassPosition(btRigidBody* obj, btScalar* value);
void btRigidBody_getCenterOfMassTransform(btRigidBody* obj, btScalar* xform);
btTypedConstraint* btRigidBody_getConstraintRef(btRigidBody* obj, int index);
int btRigidBody_getContactSolverType(btRigidBody* obj);
int btRigidBody_getFlags(btRigidBody* obj);
int btRigidBody_getFrictionSolverType(btRigidBody* obj);
void btRigidBody_getGravity(btRigidBody* obj, btScalar* acceleration);
void btRigidBody_getInvInertiaDiagLocal(btRigidBody* obj, btScalar* diagInvInertia);
void btRigidBody_getInvInertiaTensorWorld(btRigidBody* obj, btScalar* value);
btScalar btRigidBody_getInvMass(btRigidBody* obj);
btScalar btRigidBody_getLinearDamping(btRigidBody* obj);
void btRigidBody_getLinearFactor(btRigidBody* obj, btScalar* linearFactor);
btScalar btRigidBody_getLinearSleepingThreshold(btRigidBody* obj);
void btRigidBody_getLinearVelocity(btRigidBody* obj, btScalar* lin_vel);
void btRigidBody_getLocalInertia(btRigidBody* obj, btScalar* value);
btMotionState* btRigidBody_getMotionState(btRigidBody* obj);
int btRigidBody_getNumConstraintRefs(btRigidBody* obj);
void btRigidBody_getOrientation(btRigidBody* obj, btScalar* value);
void btRigidBody_getTotalForce(btRigidBody* obj, btScalar* value);
void btRigidBody_getTotalTorque(btRigidBody* obj, btScalar* value);
void btRigidBody_getVelocityInLocalPoint(btRigidBody* obj, const btScalar* rel_pos, btScalar* value);
void btRigidBody_integrateVelocities(btRigidBody* obj, btScalar step);
bool btRigidBody_isInWorld(btRigidBody* obj);
void btRigidBody_predictIntegratedTransform(btRigidBody* obj, btScalar step, btScalar* predictedTransform);
void btRigidBody_proceedToTransform(btRigidBody* obj, const btScalar* newTrans);
void btRigidBody_removeConstraintRef(btRigidBody* obj, btTypedConstraint* c);
void btRigidBody_saveKinematicState(btRigidBody* obj, btScalar step);
void btRigidBody_setAngularFactor(btRigidBody* obj, const btScalar* angFac);
void btRigidBody_setAngularFactor2(btRigidBody* obj, btScalar angFac);
void btRigidBody_setAngularVelocity(btRigidBody* obj, const btScalar* ang_vel);
void btRigidBody_setCenterOfMassTransform(btRigidBody* obj, const btScalar* xform);
void btRigidBody_setContactSolverType(btRigidBody* obj, int value);
void btRigidBody_setDamping(btRigidBody* obj, btScalar lin_damping, btScalar ang_damping);
void btRigidBody_setFlags(btRigidBody* obj, int flags);
void btRigidBody_setFrictionSolverType(btRigidBody* obj, int value);
void btRigidBody_setGravity(btRigidBody* obj, const btScalar* acceleration);
void btRigidBody_setInvInertiaDiagLocal(btRigidBody* obj, const btScalar* diagInvInertia);
void btRigidBody_setLinearFactor(btRigidBody* obj, const btScalar* linearFactor);
void btRigidBody_setLinearVelocity(btRigidBody* obj, const btScalar* lin_vel);
void btRigidBody_setMassProps(btRigidBody* obj, btScalar mass, const btScalar* inertia);
void btRigidBody_setMotionState(btRigidBody* obj, btMotionState* motionState);
void btRigidBody_setNewBroadphaseProxy(btRigidBody* obj, btBroadphaseProxy* broadphaseProxy);
void btRigidBody_setSleepingThresholds(btRigidBody* obj, btScalar linear, btScalar angular);
void btRigidBody_translate(btRigidBody* obj, const btScalar* v);
btRigidBody* btRigidBody_upcast(btCollisionObject* colObj);
void btRigidBody_updateDeactivation(btRigidBody* obj, btScalar timeStep);
void btRigidBody_updateInertiaTensor(btRigidBody* obj);
bool btRigidBody_wantsSleeping(btRigidBody* obj);
btScaledBvhTriangleMeshShape* btScaledBvhTriangleMeshShape_new(btBvhTriangleMeshShape* childShape, const btScalar* localScaling);
btBvhTriangleMeshShape* btScaledBvhTriangleMeshShape_getChildShape(btScaledBvhTriangleMeshShape* obj);
btSequentialImpulseConstraintSolver* btSequentialImpulseConstraintSolver_new();
unsigned long btSequentialImpulseConstraintSolver_btRand2(btSequentialImpulseConstraintSolver* obj);
int btSequentialImpulseConstraintSolver_btRandInt2(btSequentialImpulseConstraintSolver* obj, int n);
unsigned long btSequentialImpulseConstraintSolver_getRandSeed(btSequentialImpulseConstraintSolver* obj);
void btSequentialImpulseConstraintSolver_setRandSeed(btSequentialImpulseConstraintSolver* obj, unsigned long seed);
btChunk* btChunk_new();
int btChunk_getChunkCode(btChunk* obj);
int btChunk_getDna_nr(btChunk* obj);
int btChunk_getLength(btChunk* obj);
int btChunk_getNumber(btChunk* obj);
void* btChunk_getOldPtr(btChunk* obj);
void btChunk_setChunkCode(btChunk* obj, int value);
void btChunk_setDna_nr(btChunk* obj, int value);
void btChunk_setLength(btChunk* obj, int value);
void btChunk_setNumber(btChunk* obj, int value);
void btChunk_setOldPtr(btChunk* obj, void* value);
void btChunk_delete(btChunk* obj);
void btSerializer_delete(btSerializer* obj);
btDefaultSerializer* btDefaultSerializer_new();
btDefaultSerializer* btDefaultSerializer_new2(int totalSize);
unsigned char* btDefaultSerializer_internalAlloc(btDefaultSerializer* obj, size_t size);
void btDefaultSerializer_writeHeader(btDefaultSerializer* obj, unsigned char* buffer);
btShapeHull* btShapeHull_new(const btConvexShape* shape);
bool btShapeHull_buildHull(btShapeHull* obj, btScalar margin);
const unsigned int* btShapeHull_getIndexPointer(btShapeHull* obj);
const btVector3* btShapeHull_getVertexPointer(btShapeHull* obj);
int btShapeHull_numIndices(btShapeHull* obj);
int btShapeHull_numTriangles(btShapeHull* obj);
int btShapeHull_numVertices(btShapeHull* obj);
void btShapeHull_delete(btShapeHull* obj);
void btSimulationIslandManager_IslandCallback_delete(btSimulationIslandManager_IslandCallback* obj);
btSimulationIslandManager* btSimulationIslandManager_new();
void btSimulationIslandManager_buildAndProcessIslands(btSimulationIslandManager* obj, btDispatcher* dispatcher, btCollisionWorld* collisionWorld, btSimulationIslandManager_IslandCallback* callback);
void btSimulationIslandManager_buildIslands(btSimulationIslandManager* obj, btDispatcher* dispatcher, btCollisionWorld* colWorld);
void btSimulationIslandManager_findUnions(btSimulationIslandManager* obj, btDispatcher* dispatcher, btCollisionWorld* colWorld);
bool btSimulationIslandManager_getSplitIslands(btSimulationIslandManager* obj);
btUnionFind* btSimulationIslandManager_getUnionFind(btSimulationIslandManager* obj);
void btSimulationIslandManager_initUnionFind(btSimulationIslandManager* obj, int n);
void btSimulationIslandManager_setSplitIslands(btSimulationIslandManager* obj, bool doSplitIslands);
void btSimulationIslandManager_storeIslandActivationState(btSimulationIslandManager* obj, btCollisionWorld* world);
void btSimulationIslandManager_updateActivationState(btSimulationIslandManager* obj, btCollisionWorld* colWorld, btDispatcher* dispatcher);
void btSimulationIslandManager_delete(btSimulationIslandManager* obj);
btSliderConstraint* btSliderConstraint_new(btRigidBody* rbA, btRigidBody* rbB, const btScalar* frameInA, const btScalar* frameInB, bool useLinearReferenceFrameA);
btSliderConstraint* btSliderConstraint_new2(btRigidBody* rbB, const btScalar* frameInB, bool useLinearReferenceFrameA);
void btSliderConstraint_calculateTransforms(btSliderConstraint* obj, const btScalar* transA, const btScalar* transB);
void btSliderConstraint_getAncorInA(btSliderConstraint* obj, btScalar* value);
void btSliderConstraint_getAncorInB(btSliderConstraint* obj, btScalar* value);
btScalar btSliderConstraint_getAngDepth(btSliderConstraint* obj);
btScalar btSliderConstraint_getAngularPos(btSliderConstraint* obj);
void btSliderConstraint_getCalculatedTransformA(btSliderConstraint* obj, btScalar* value);
void btSliderConstraint_getCalculatedTransformB(btSliderConstraint* obj, btScalar* value);
btScalar btSliderConstraint_getDampingDirAng(btSliderConstraint* obj);
btScalar btSliderConstraint_getDampingDirLin(btSliderConstraint* obj);
btScalar btSliderConstraint_getDampingLimAng(btSliderConstraint* obj);
btScalar btSliderConstraint_getDampingLimLin(btSliderConstraint* obj);
btScalar btSliderConstraint_getDampingOrthoAng(btSliderConstraint* obj);
btScalar btSliderConstraint_getDampingOrthoLin(btSliderConstraint* obj);
void btSliderConstraint_getFrameOffsetA(btSliderConstraint* obj, btScalar* value);
void btSliderConstraint_getFrameOffsetB(btSliderConstraint* obj, btScalar* value);
void btSliderConstraint_getInfo1NonVirtual(btSliderConstraint* obj, btTypedConstraint_btConstraintInfo1* info);
void btSliderConstraint_getInfo2NonVirtual(btSliderConstraint* obj, btTypedConstraint_btConstraintInfo2* info, const btScalar* transA, const btScalar* transB, const btScalar* linVelA, const btScalar* linVelB, btScalar rbAinvMass, btScalar rbBinvMass);
btScalar btSliderConstraint_getLinDepth(btSliderConstraint* obj);
btScalar btSliderConstraint_getLinearPos(btSliderConstraint* obj);
btScalar btSliderConstraint_getLowerAngLimit(btSliderConstraint* obj);
btScalar btSliderConstraint_getLowerLinLimit(btSliderConstraint* obj);
btScalar btSliderConstraint_getMaxAngMotorForce(btSliderConstraint* obj);
btScalar btSliderConstraint_getMaxLinMotorForce(btSliderConstraint* obj);
bool btSliderConstraint_getPoweredAngMotor(btSliderConstraint* obj);
bool btSliderConstraint_getPoweredLinMotor(btSliderConstraint* obj);
btScalar btSliderConstraint_getRestitutionDirAng(btSliderConstraint* obj);
btScalar btSliderConstraint_getRestitutionDirLin(btSliderConstraint* obj);
btScalar btSliderConstraint_getRestitutionLimAng(btSliderConstraint* obj);
btScalar btSliderConstraint_getRestitutionLimLin(btSliderConstraint* obj);
btScalar btSliderConstraint_getRestitutionOrthoAng(btSliderConstraint* obj);
btScalar btSliderConstraint_getRestitutionOrthoLin(btSliderConstraint* obj);
btScalar btSliderConstraint_getSoftnessDirAng(btSliderConstraint* obj);
btScalar btSliderConstraint_getSoftnessDirLin(btSliderConstraint* obj);
btScalar btSliderConstraint_getSoftnessLimAng(btSliderConstraint* obj);
btScalar btSliderConstraint_getSoftnessLimLin(btSliderConstraint* obj);
btScalar btSliderConstraint_getSoftnessOrthoAng(btSliderConstraint* obj);
btScalar btSliderConstraint_getSoftnessOrthoLin(btSliderConstraint* obj);
bool btSliderConstraint_getSolveAngLimit(btSliderConstraint* obj);
bool btSliderConstraint_getSolveLinLimit(btSliderConstraint* obj);
btScalar btSliderConstraint_getTargetAngMotorVelocity(btSliderConstraint* obj);
btScalar btSliderConstraint_getTargetLinMotorVelocity(btSliderConstraint* obj);
btScalar btSliderConstraint_getUpperAngLimit(btSliderConstraint* obj);
btScalar btSliderConstraint_getUpperLinLimit(btSliderConstraint* obj);
bool btSliderConstraint_getUseFrameOffset(btSliderConstraint* obj);
bool btSliderConstraint_getUseLinearReferenceFrameA(btSliderConstraint* obj);
void btSliderConstraint_setDampingDirAng(btSliderConstraint* obj, btScalar dampingDirAng);
void btSliderConstraint_setDampingDirLin(btSliderConstraint* obj, btScalar dampingDirLin);
void btSliderConstraint_setDampingLimAng(btSliderConstraint* obj, btScalar dampingLimAng);
void btSliderConstraint_setDampingLimLin(btSliderConstraint* obj, btScalar dampingLimLin);
void btSliderConstraint_setDampingOrthoAng(btSliderConstraint* obj, btScalar dampingOrthoAng);
void btSliderConstraint_setDampingOrthoLin(btSliderConstraint* obj, btScalar dampingOrthoLin);
void btSliderConstraint_setFrames(btSliderConstraint* obj, const btScalar* frameA, const btScalar* frameB);
void btSliderConstraint_setLowerAngLimit(btSliderConstraint* obj, btScalar lowerLimit);
void btSliderConstraint_setLowerLinLimit(btSliderConstraint* obj, btScalar lowerLimit);
void btSliderConstraint_setMaxAngMotorForce(btSliderConstraint* obj, btScalar maxAngMotorForce);
void btSliderConstraint_setMaxLinMotorForce(btSliderConstraint* obj, btScalar maxLinMotorForce);
void btSliderConstraint_setPoweredAngMotor(btSliderConstraint* obj, bool onOff);
void btSliderConstraint_setPoweredLinMotor(btSliderConstraint* obj, bool onOff);
void btSliderConstraint_setRestitutionDirAng(btSliderConstraint* obj, btScalar restitutionDirAng);
void btSliderConstraint_setRestitutionDirLin(btSliderConstraint* obj, btScalar restitutionDirLin);
void btSliderConstraint_setRestitutionLimAng(btSliderConstraint* obj, btScalar restitutionLimAng);
void btSliderConstraint_setRestitutionLimLin(btSliderConstraint* obj, btScalar restitutionLimLin);
void btSliderConstraint_setRestitutionOrthoAng(btSliderConstraint* obj, btScalar restitutionOrthoAng);
void btSliderConstraint_setRestitutionOrthoLin(btSliderConstraint* obj, btScalar restitutionOrthoLin);
void btSliderConstraint_setSoftnessDirAng(btSliderConstraint* obj, btScalar softnessDirAng);
void btSliderConstraint_setSoftnessDirLin(btSliderConstraint* obj, btScalar softnessDirLin);
void btSliderConstraint_setSoftnessLimAng(btSliderConstraint* obj, btScalar softnessLimAng);
void btSliderConstraint_setSoftnessLimLin(btSliderConstraint* obj, btScalar softnessLimLin);
void btSliderConstraint_setSoftnessOrthoAng(btSliderConstraint* obj, btScalar softnessOrthoAng);
void btSliderConstraint_setSoftnessOrthoLin(btSliderConstraint* obj, btScalar softnessOrthoLin);
void btSliderConstraint_setTargetAngMotorVelocity(btSliderConstraint* obj, btScalar targetAngMotorVelocity);
void btSliderConstraint_setTargetLinMotorVelocity(btSliderConstraint* obj, btScalar targetLinMotorVelocity);
void btSliderConstraint_setUpperAngLimit(btSliderConstraint* obj, btScalar upperLimit);
void btSliderConstraint_setUpperLinLimit(btSliderConstraint* obj, btScalar upperLimit);
void btSliderConstraint_setUseFrameOffset(btSliderConstraint* obj, bool frameOffsetOnOff);
void btSliderConstraint_testAngLimits(btSliderConstraint* obj);
void btSliderConstraint_testLinLimits(btSliderConstraint* obj);
btTriIndex* btTriIndex_new(int partId, int triangleIndex, btCollisionShape* shape);
btCollisionShape* btTriIndex_getChildShape(btTriIndex* obj);
int btTriIndex_getPartId(btTriIndex* obj);
int btTriIndex_getPartIdTriangleIndex(btTriIndex* obj);
int btTriIndex_getTriangleIndex(btTriIndex* obj);
int btTriIndex_getUid(btTriIndex* obj);
void btTriIndex_setChildShape(btTriIndex* obj, btCollisionShape* value);
void btTriIndex_setPartIdTriangleIndex(btTriIndex* obj, int value);
void btTriIndex_delete(btTriIndex* obj);
btSoftBodyTriangleCallback* btSoftBodyTriangleCallback_new(btDispatcher* dispatcher, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, bool isSwapped);
void btSoftBodyTriangleCallback_clearCache(btSoftBodyTriangleCallback* obj);
void btSoftBodyTriangleCallback_getAabbMax(btSoftBodyTriangleCallback* obj, btScalar* value);
void btSoftBodyTriangleCallback_getAabbMin(btSoftBodyTriangleCallback* obj, btScalar* value);
int btSoftBodyTriangleCallback_getTriangleCount(btSoftBodyTriangleCallback* obj);
void btSoftBodyTriangleCallback_setTimeStepAndCounters(btSoftBodyTriangleCallback* obj, btScalar collisionMarginTriangle, const btCollisionObjectWrapper* triObjWrap, const btDispatcherInfo* dispatchInfo, btManifoldResult* resultOut);
void btSoftBodyTriangleCallback_setTriangleCount(btSoftBodyTriangleCallback* obj, int value);
btSoftBodyConcaveCollisionAlgorithm_CreateFunc* btSoftBodyConcaveCollisionAlgorithm_CreateFunc_new();
btSoftBodyConcaveCollisionAlgorithm_SwappedCreateFunc* btSoftBodyConcaveCollisionAlgorithm_SwappedCreateFunc_new();
btSoftBodyConcaveCollisionAlgorithm* btSoftBodyConcaveCollisionAlgorithm_new(const btCollisionAlgorithmConstructionInfo* ci, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, bool isSwapped);
void btSoftBodyConcaveCollisionAlgorithm_clearCache(btSoftBodyConcaveCollisionAlgorithm* obj);
float btSoftBodyHelpers_CalculateUV(int resx, int resy, int ix, int iy, int id);
btSoftBody* btSoftBodyHelpers_CreateEllipsoid(btSoftBodyWorldInfo* worldInfo, const btScalar* center, const btScalar* radius, int res);
btSoftBody* btSoftBodyHelpers_CreateFromConvexHull(btSoftBodyWorldInfo* worldInfo, const btScalar* vertices, int nvertices);
btSoftBody* btSoftBodyHelpers_CreateFromConvexHull2(btSoftBodyWorldInfo* worldInfo, const btScalar* vertices, int nvertices, bool randomizeConstraints);
btSoftBody* btSoftBodyHelpers_CreateFromTetGenData(btSoftBodyWorldInfo* worldInfo, const char* ele, const char* face, const char* node, bool bfacelinks, bool btetralinks, bool bfacesfromtetras);
btSoftBody* btSoftBodyHelpers_CreateFromTriMesh(btSoftBodyWorldInfo* worldInfo, const btScalar* vertices, const int* triangles, int ntriangles);
btSoftBody* btSoftBodyHelpers_CreateFromTriMesh2(btSoftBodyWorldInfo* worldInfo, const btScalar* vertices, const int* triangles, int ntriangles, bool randomizeConstraints);
btSoftBody* btSoftBodyHelpers_CreatePatch(btSoftBodyWorldInfo* worldInfo, const btScalar* corner00, const btScalar* corner10, const btScalar* corner01, const btScalar* corner11, int resx, int resy, int fixeds, bool gendiags);
btSoftBody* btSoftBodyHelpers_CreatePatchUV(btSoftBodyWorldInfo* worldInfo, const btScalar* corner00, const btScalar* corner10, const btScalar* corner01, const btScalar* corner11, int resx, int resy, int fixeds, bool gendiags);
btSoftBody* btSoftBodyHelpers_CreatePatchUV2(btSoftBodyWorldInfo* worldInfo, const btScalar* corner00, const btScalar* corner10, const btScalar* corner01, const btScalar* corner11, int resx, int resy, int fixeds, bool gendiags, float* tex_coords);
btSoftBody* btSoftBodyHelpers_CreateRope(btSoftBodyWorldInfo* worldInfo, const btScalar* from, const btScalar* to, int res, int fixeds);
void btSoftBodyHelpers_Draw(btSoftBody* psb, btIDebugDraw* idraw);
void btSoftBodyHelpers_Draw2(btSoftBody* psb, btIDebugDraw* idraw, int drawflags);
void btSoftBodyHelpers_DrawClusterTree(btSoftBody* psb, btIDebugDraw* idraw);
void btSoftBodyHelpers_DrawClusterTree2(btSoftBody* psb, btIDebugDraw* idraw, int mindepth);
void btSoftBodyHelpers_DrawClusterTree3(btSoftBody* psb, btIDebugDraw* idraw, int mindepth, int maxdepth);
void btSoftBodyHelpers_DrawFaceTree(btSoftBody* psb, btIDebugDraw* idraw);
void btSoftBodyHelpers_DrawFaceTree2(btSoftBody* psb, btIDebugDraw* idraw, int mindepth);
void btSoftBodyHelpers_DrawFaceTree3(btSoftBody* psb, btIDebugDraw* idraw, int mindepth, int maxdepth);
void btSoftBodyHelpers_DrawFrame(btSoftBody* psb, btIDebugDraw* idraw);
void btSoftBodyHelpers_DrawInfos(btSoftBody* psb, btIDebugDraw* idraw, bool masses, bool areas, bool stress);
void btSoftBodyHelpers_DrawNodeTree(btSoftBody* psb, btIDebugDraw* idraw);
void btSoftBodyHelpers_DrawNodeTree2(btSoftBody* psb, btIDebugDraw* idraw, int mindepth);
void btSoftBodyHelpers_DrawNodeTree3(btSoftBody* psb, btIDebugDraw* idraw, int mindepth, int maxdepth);
void btSoftBodyHelpers_ReoptimizeLinkOrder(btSoftBody* psb);
btSoftBodyRigidBodyCollisionConfiguration* btSoftBodyRigidBodyCollisionConfiguration_new();
btSoftBodyRigidBodyCollisionConfiguration* btSoftBodyRigidBodyCollisionConfiguration_new2(const btDefaultCollisionConstructionInfo* constructionInfo);
bool btSoftBodySolver_checkInitialized(btSoftBodySolver* obj);
void btSoftBodySolver_copyBackToSoftBodies(btSoftBodySolver* obj);
void btSoftBodySolver_copyBackToSoftBodies2(btSoftBodySolver* obj, bool bMove);
int btSoftBodySolver_getNumberOfPositionIterations(btSoftBodySolver* obj);
int btSoftBodySolver_getNumberOfVelocityIterations(btSoftBodySolver* obj);
SolverTypes btSoftBodySolver_getSolverType(btSoftBodySolver* obj);
float btSoftBodySolver_getTimeScale(btSoftBodySolver* obj);
void btSoftBodySolver_optimize(btSoftBodySolver* obj, btAlignedObjectArray* softBodies);
void btSoftBodySolver_optimize2(btSoftBodySolver* obj, btAlignedObjectArray* softBodies, bool forceUpdate);
void btSoftBodySolver_predictMotion(btSoftBodySolver* obj, float solverdt);
void btSoftBodySolver_processCollision(btSoftBodySolver* obj, btSoftBody* __unnamed0, const btCollisionObjectWrapper* __unnamed1);
void btSoftBodySolver_processCollision2(btSoftBodySolver* obj, btSoftBody* __unnamed0, btSoftBody* __unnamed1);
void btSoftBodySolver_setNumberOfPositionIterations(btSoftBodySolver* obj, int iterations);
void btSoftBodySolver_setNumberOfVelocityIterations(btSoftBodySolver* obj, int iterations);
void btSoftBodySolver_solveConstraints(btSoftBodySolver* obj, float solverdt);
void btSoftBodySolver_updateSoftBodies(btSoftBodySolver* obj);
void btSoftBodySolver_delete(btSoftBodySolver* obj);
void btSoftBodySolverOutput_copySoftBodyToVertexBuffer(btSoftBodySolverOutput* obj, const btSoftBody* softBody, btVertexBufferDescriptor* vertexBuffer);
void btSoftBodySolverOutput_delete(btSoftBodySolverOutput* obj);
btSoftBodyWorldInfo* btSoftBodyWorldInfo_new();
btScalar btSoftBodyWorldInfo_getAir_density(btSoftBodyWorldInfo* obj);
btBroadphaseInterface* btSoftBodyWorldInfo_getBroadphase(btSoftBodyWorldInfo* obj);
btDispatcher* btSoftBodyWorldInfo_getDispatcher(btSoftBodyWorldInfo* obj);
void btSoftBodyWorldInfo_getGravity(btSoftBodyWorldInfo* obj, btScalar* value);
btScalar btSoftBodyWorldInfo_getMaxDisplacement(btSoftBodyWorldInfo* obj);
btSparseSdf3* btSoftBodyWorldInfo_getSparsesdf(btSoftBodyWorldInfo* obj);
btScalar btSoftBodyWorldInfo_getWater_density(btSoftBodyWorldInfo* obj);
void btSoftBodyWorldInfo_getWater_normal(btSoftBodyWorldInfo* obj, btScalar* value);
btScalar btSoftBodyWorldInfo_getWater_offset(btSoftBodyWorldInfo* obj);
void btSoftBodyWorldInfo_setAir_density(btSoftBodyWorldInfo* obj, btScalar value);
void btSoftBodyWorldInfo_setBroadphase(btSoftBodyWorldInfo* obj, btBroadphaseInterface* value);
void btSoftBodyWorldInfo_setDispatcher(btSoftBodyWorldInfo* obj, btDispatcher* value);
void btSoftBodyWorldInfo_setGravity(btSoftBodyWorldInfo* obj, const btScalar* value);
void btSoftBodyWorldInfo_setMaxDisplacement(btSoftBodyWorldInfo* obj, btScalar value);
void btSoftBodyWorldInfo_setWater_density(btSoftBodyWorldInfo* obj, btScalar value);
void btSoftBodyWorldInfo_setWater_normal(btSoftBodyWorldInfo* obj, const btScalar* value);
void btSoftBodyWorldInfo_setWater_offset(btSoftBodyWorldInfo* obj, btScalar value);
void btSoftBodyWorldInfo_delete(btSoftBodyWorldInfo* obj);
btSoftBody_AJoint_IControl* btSoftBody_AJoint_IControlWrapper_new(pIControl_Prepare PrepareCallback, pIControl_Speed SpeedCallback);
void* btSoftBody_AJoint_IControlWrapper_getWrapperData(btSoftBody_AJoint_IControlWrapper* obj);
void btSoftBody_AJoint_IControlWrapper_setWrapperData(btSoftBody_AJoint_IControlWrapper* obj, void* data);
btSoftBody_AJoint_IControl* btSoftBody_AJoint_IControl_new();
btSoftBody_AJoint_IControl* btSoftBody_AJoint_IControl_Default();
void btSoftBody_AJoint_IControl_Prepare(btSoftBody_AJoint_IControl* obj, btSoftBody_AJoint* __unnamed0);
btScalar btSoftBody_AJoint_IControl_Speed(btSoftBody_AJoint_IControl* obj, btSoftBody_AJoint* __unnamed0, btScalar current);
void btSoftBody_AJoint_IControl_delete(btSoftBody_AJoint_IControl* obj);
btSoftBody_AJoint_Specs* btSoftBody_AJoint_Specs_new();
void btSoftBody_AJoint_Specs_getAxis(btSoftBody_AJoint_Specs* obj, btScalar* value);
btSoftBody_AJoint_IControl* btSoftBody_AJoint_Specs_getIcontrol(btSoftBody_AJoint_Specs* obj);
void btSoftBody_AJoint_Specs_setAxis(btSoftBody_AJoint_Specs* obj, const btScalar* value);
void btSoftBody_AJoint_Specs_setIcontrol(btSoftBody_AJoint_Specs* obj, btSoftBody_AJoint_IControl* value);
btSoftBody_AJoint* btSoftBody_AJoint_new();
btVector3* btSoftBody_AJoint_getAxis(btSoftBody_AJoint* obj);
btSoftBody_AJoint_IControl* btSoftBody_AJoint_getIcontrol(btSoftBody_AJoint* obj);
void btSoftBody_AJoint_setIcontrol(btSoftBody_AJoint* obj, btSoftBody_AJoint_IControl* value);
btSoftBody_Anchor* btSoftBody_Anchor_new();
btRigidBody* btSoftBody_Anchor_getBody(btSoftBody_Anchor* obj);
void btSoftBody_Anchor_getC0(btSoftBody_Anchor* obj, btScalar* value);
void btSoftBody_Anchor_getC1(btSoftBody_Anchor* obj, btScalar* value);
btScalar btSoftBody_Anchor_getC2(btSoftBody_Anchor* obj);
btScalar btSoftBody_Anchor_getInfluence(btSoftBody_Anchor* obj);
void btSoftBody_Anchor_getLocal(btSoftBody_Anchor* obj, btScalar* value);
btSoftBody_Node* btSoftBody_Anchor_getNode(btSoftBody_Anchor* obj);
void btSoftBody_Anchor_setBody(btSoftBody_Anchor* obj, btRigidBody* value);
void btSoftBody_Anchor_setC0(btSoftBody_Anchor* obj, const btScalar* value);
void btSoftBody_Anchor_setC1(btSoftBody_Anchor* obj, const btScalar* value);
void btSoftBody_Anchor_setC2(btSoftBody_Anchor* obj, btScalar value);
void btSoftBody_Anchor_setInfluence(btSoftBody_Anchor* obj, btScalar value);
void btSoftBody_Anchor_setLocal(btSoftBody_Anchor* obj, const btScalar* value);
void btSoftBody_Anchor_setNode(btSoftBody_Anchor* obj, btSoftBody_Node* value);
void btSoftBody_Anchor_delete(btSoftBody_Anchor* obj);
btSoftBody_Body* btSoftBody_Body_new();
btSoftBody_Body* btSoftBody_Body_new2(const btCollisionObject* colObj);
btSoftBody_Body* btSoftBody_Body_new3(btSoftBody_Cluster* p);
void btSoftBody_Body_activate(btSoftBody_Body* obj);
void btSoftBody_Body_angularVelocity(btSoftBody_Body* obj, const btScalar* rpos, btScalar* value);
void btSoftBody_Body_angularVelocity2(btSoftBody_Body* obj, btScalar* value);
void btSoftBody_Body_applyAImpulse(btSoftBody_Body* obj, const btSoftBody_Impulse* impulse);
void btSoftBody_Body_applyDAImpulse(btSoftBody_Body* obj, const btScalar* impulse);
void btSoftBody_Body_applyDCImpulse(btSoftBody_Body* obj, const btScalar* impulse);
void btSoftBody_Body_applyDImpulse(btSoftBody_Body* obj, const btScalar* impulse, const btScalar* rpos);
void btSoftBody_Body_applyImpulse(btSoftBody_Body* obj, const btSoftBody_Impulse* impulse, const btScalar* rpos);
void btSoftBody_Body_applyVAImpulse(btSoftBody_Body* obj, const btScalar* impulse);
void btSoftBody_Body_applyVImpulse(btSoftBody_Body* obj, const btScalar* impulse, const btScalar* rpos);
const btCollisionObject* btSoftBody_Body_getCollisionObject(btSoftBody_Body* obj);
btRigidBody* btSoftBody_Body_getRigid(btSoftBody_Body* obj);
btSoftBody_Cluster* btSoftBody_Body_getSoft(btSoftBody_Body* obj);
btScalar btSoftBody_Body_invMass(btSoftBody_Body* obj);
void btSoftBody_Body_invWorldInertia(btSoftBody_Body* obj, btScalar* value);
void btSoftBody_Body_linearVelocity(btSoftBody_Body* obj, btScalar* value);
void btSoftBody_Body_setCollisionObject(btSoftBody_Body* obj, const btCollisionObject* value);
void btSoftBody_Body_setRigid(btSoftBody_Body* obj, btRigidBody* value);
void btSoftBody_Body_setSoft(btSoftBody_Body* obj, btSoftBody_Cluster* value);
void btSoftBody_Body_velocity(btSoftBody_Body* obj, const btScalar* rpos, btScalar* value);
void btSoftBody_Body_xform(btSoftBody_Body* obj, btScalar* value);
void btSoftBody_Body_delete(btSoftBody_Body* obj);
btSoftBody_CJoint* btSoftBody_CJoint_new();
btScalar btSoftBody_CJoint_getFriction(btSoftBody_CJoint* obj);
int btSoftBody_CJoint_getLife(btSoftBody_CJoint* obj);
int btSoftBody_CJoint_getMaxlife(btSoftBody_CJoint* obj);
void btSoftBody_CJoint_getNormal(btSoftBody_CJoint* obj, btScalar* value);
btVector3* btSoftBody_CJoint_getRpos(btSoftBody_CJoint* obj);
void btSoftBody_CJoint_setFriction(btSoftBody_CJoint* obj, btScalar value);
void btSoftBody_CJoint_setLife(btSoftBody_CJoint* obj, int value);
void btSoftBody_CJoint_setMaxlife(btSoftBody_CJoint* obj, int value);
void btSoftBody_CJoint_setNormal(btSoftBody_CJoint* obj, const btScalar* value);
btSoftBody_Cluster* btSoftBody_Cluster_new();
btScalar btSoftBody_Cluster_getAdamping(btSoftBody_Cluster* obj);
void btSoftBody_Cluster_getAv(btSoftBody_Cluster* obj, btScalar* value);
int btSoftBody_Cluster_getClusterIndex(btSoftBody_Cluster* obj);
bool btSoftBody_Cluster_getCollide(btSoftBody_Cluster* obj);
void btSoftBody_Cluster_getCom(btSoftBody_Cluster* obj, btScalar* value);
bool btSoftBody_Cluster_getContainsAnchor(btSoftBody_Cluster* obj);
btVector3* btSoftBody_Cluster_getDimpulses(btSoftBody_Cluster* obj);
btAlignedVector3Array* btSoftBody_Cluster_getFramerefs(btSoftBody_Cluster* obj);
void btSoftBody_Cluster_getFramexform(btSoftBody_Cluster* obj, btScalar* value);
btScalar btSoftBody_Cluster_getIdmass(btSoftBody_Cluster* obj);
btScalar btSoftBody_Cluster_getImass(btSoftBody_Cluster* obj);
void btSoftBody_Cluster_getInvwi(btSoftBody_Cluster* obj, btScalar* value);
btScalar btSoftBody_Cluster_getLdamping(btSoftBody_Cluster* obj);
btDbvtNode* btSoftBody_Cluster_getLeaf(btSoftBody_Cluster* obj);
void btSoftBody_Cluster_getLocii(btSoftBody_Cluster* obj, btScalar* value);
void btSoftBody_Cluster_getLv(btSoftBody_Cluster* obj, btScalar* value);
btAlignedScalarArray* btSoftBody_Cluster_getMasses(btSoftBody_Cluster* obj);
btScalar btSoftBody_Cluster_getMatching(btSoftBody_Cluster* obj);
btScalar btSoftBody_Cluster_getMaxSelfCollisionImpulse(btSoftBody_Cluster* obj);
btScalar btSoftBody_Cluster_getNdamping(btSoftBody_Cluster* obj);
int btSoftBody_Cluster_getNdimpulses(btSoftBody_Cluster* obj);
btAlignedSoftBodyNodePtrArray* btSoftBody_Cluster_getNodes(btSoftBody_Cluster* obj);
int btSoftBody_Cluster_getNvimpulses(btSoftBody_Cluster* obj);
btScalar btSoftBody_Cluster_getSelfCollisionImpulseFactor(btSoftBody_Cluster* obj);
btVector3* btSoftBody_Cluster_getVimpulses(btSoftBody_Cluster* obj);
void btSoftBody_Cluster_setAdamping(btSoftBody_Cluster* obj, btScalar value);
void btSoftBody_Cluster_setAv(btSoftBody_Cluster* obj, const btScalar* value);
void btSoftBody_Cluster_setClusterIndex(btSoftBody_Cluster* obj, int value);
void btSoftBody_Cluster_setCollide(btSoftBody_Cluster* obj, bool value);
void btSoftBody_Cluster_setCom(btSoftBody_Cluster* obj, const btScalar* value);
void btSoftBody_Cluster_setContainsAnchor(btSoftBody_Cluster* obj, bool value);
void btSoftBody_Cluster_setFramexform(btSoftBody_Cluster* obj, const btScalar* value);
void btSoftBody_Cluster_setIdmass(btSoftBody_Cluster* obj, btScalar value);
void btSoftBody_Cluster_setImass(btSoftBody_Cluster* obj, btScalar value);
void btSoftBody_Cluster_setInvwi(btSoftBody_Cluster* obj, const btScalar* value);
void btSoftBody_Cluster_setLdamping(btSoftBody_Cluster* obj, btScalar value);
void btSoftBody_Cluster_setLeaf(btSoftBody_Cluster* obj, btDbvtNode* value);
void btSoftBody_Cluster_setLocii(btSoftBody_Cluster* obj, const btScalar* value);
void btSoftBody_Cluster_setLv(btSoftBody_Cluster* obj, const btScalar* value);
void btSoftBody_Cluster_setMatching(btSoftBody_Cluster* obj, btScalar value);
void btSoftBody_Cluster_setMaxSelfCollisionImpulse(btSoftBody_Cluster* obj, btScalar value);
void btSoftBody_Cluster_setNdamping(btSoftBody_Cluster* obj, btScalar value);
void btSoftBody_Cluster_setNdimpulses(btSoftBody_Cluster* obj, int value);
void btSoftBody_Cluster_setNvimpulses(btSoftBody_Cluster* obj, int value);
void btSoftBody_Cluster_setSelfCollisionImpulseFactor(btSoftBody_Cluster* obj, btScalar value);
void btSoftBody_Cluster_setVimpulses(btSoftBody_Cluster* obj, btScalar* value);
void btSoftBody_Cluster_delete(btSoftBody_Cluster* obj);
btSoftBody_Config* btSoftBody_Config_new();
btSoftBody_eAeroModel btSoftBody_Config_getAeromodel(btSoftBody_Config* obj);
int btSoftBody_Config_getCiterations(btSoftBody_Config* obj);
int btSoftBody_Config_getCollisions(btSoftBody_Config* obj);
int btSoftBody_Config_getDiterations(btSoftBody_Config* obj);
btAlignedSoftBodyPSolverArray* btSoftBody_Config_getDsequence(btSoftBody_Config* obj);
btScalar btSoftBody_Config_getKAHR(btSoftBody_Config* obj);
btScalar btSoftBody_Config_getKCHR(btSoftBody_Config* obj);
btScalar btSoftBody_Config_getKDF(btSoftBody_Config* obj);
btScalar btSoftBody_Config_getKDG(btSoftBody_Config* obj);
btScalar btSoftBody_Config_getKDP(btSoftBody_Config* obj);
btScalar btSoftBody_Config_getKKHR(btSoftBody_Config* obj);
btScalar btSoftBody_Config_getKLF(btSoftBody_Config* obj);
btScalar btSoftBody_Config_getKMT(btSoftBody_Config* obj);
btScalar btSoftBody_Config_getKPR(btSoftBody_Config* obj);
btScalar btSoftBody_Config_getKSHR(btSoftBody_Config* obj);
btScalar btSoftBody_Config_getKSK_SPLT_CL(btSoftBody_Config* obj);
btScalar btSoftBody_Config_getKSKHR_CL(btSoftBody_Config* obj);
btScalar btSoftBody_Config_getKSR_SPLT_CL(btSoftBody_Config* obj);
btScalar btSoftBody_Config_getKSRHR_CL(btSoftBody_Config* obj);
btScalar btSoftBody_Config_getKSS_SPLT_CL(btSoftBody_Config* obj);
btScalar btSoftBody_Config_getKSSHR_CL(btSoftBody_Config* obj);
btScalar btSoftBody_Config_getKVC(btSoftBody_Config* obj);
btScalar btSoftBody_Config_getKVCF(btSoftBody_Config* obj);
btScalar btSoftBody_Config_getMaxvolume(btSoftBody_Config* obj);
int btSoftBody_Config_getPiterations(btSoftBody_Config* obj);
btAlignedSoftBodyPSolverArray* btSoftBody_Config_getPsequence(btSoftBody_Config* obj);
btScalar btSoftBody_Config_getTimescale(btSoftBody_Config* obj);
int btSoftBody_Config_getViterations(btSoftBody_Config* obj);
btAlignedSoftBodyVSolverArray* btSoftBody_Config_getVsequence(btSoftBody_Config* obj);
void btSoftBody_Config_setAeromodel(btSoftBody_Config* obj, btSoftBody_eAeroModel value);
void btSoftBody_Config_setCiterations(btSoftBody_Config* obj, int value);
void btSoftBody_Config_setCollisions(btSoftBody_Config* obj, int value);
void btSoftBody_Config_setDiterations(btSoftBody_Config* obj, int value);
void btSoftBody_Config_setKAHR(btSoftBody_Config* obj, btScalar value);
void btSoftBody_Config_setKCHR(btSoftBody_Config* obj, btScalar value);
void btSoftBody_Config_setKDF(btSoftBody_Config* obj, btScalar value);
void btSoftBody_Config_setKDG(btSoftBody_Config* obj, btScalar value);
void btSoftBody_Config_setKDP(btSoftBody_Config* obj, btScalar value);
void btSoftBody_Config_setKKHR(btSoftBody_Config* obj, btScalar value);
void btSoftBody_Config_setKLF(btSoftBody_Config* obj, btScalar value);
void btSoftBody_Config_setKMT(btSoftBody_Config* obj, btScalar value);
void btSoftBody_Config_setKPR(btSoftBody_Config* obj, btScalar value);
void btSoftBody_Config_setKSHR(btSoftBody_Config* obj, btScalar value);
void btSoftBody_Config_setKSK_SPLT_CL(btSoftBody_Config* obj, btScalar value);
void btSoftBody_Config_setKSKHR_CL(btSoftBody_Config* obj, btScalar value);
void btSoftBody_Config_setKSR_SPLT_CL(btSoftBody_Config* obj, btScalar value);
void btSoftBody_Config_setKSRHR_CL(btSoftBody_Config* obj, btScalar value);
void btSoftBody_Config_setKSS_SPLT_CL(btSoftBody_Config* obj, btScalar value);
void btSoftBody_Config_setKSSHR_CL(btSoftBody_Config* obj, btScalar value);
void btSoftBody_Config_setKVC(btSoftBody_Config* obj, btScalar value);
void btSoftBody_Config_setKVCF(btSoftBody_Config* obj, btScalar value);
void btSoftBody_Config_setMaxvolume(btSoftBody_Config* obj, btScalar value);
void btSoftBody_Config_setPiterations(btSoftBody_Config* obj, int value);
void btSoftBody_Config_setTimescale(btSoftBody_Config* obj, btScalar value);
void btSoftBody_Config_setViterations(btSoftBody_Config* obj, int value);
void btSoftBody_Config_delete(btSoftBody_Config* obj);
btSoftBody_Element* btSoftBody_Element_new();
void* btSoftBody_Element_getTag(btSoftBody_Element* obj);
void btSoftBody_Element_setTag(btSoftBody_Element* obj, void* value);
void btSoftBody_Element_delete(btSoftBody_Element* obj);
btSoftBody_Face* btSoftBody_Face_new();
btDbvtNode* btSoftBody_Face_getLeaf(btSoftBody_Face* obj);
btSoftBody_Node** btSoftBody_Face_getN(btSoftBody_Face* obj);
void btSoftBody_Face_getNormal(btSoftBody_Face* obj, btScalar* value);
btScalar btSoftBody_Face_getRa(btSoftBody_Face* obj);
void btSoftBody_Face_setLeaf(btSoftBody_Face* obj, btDbvtNode* value);
void btSoftBody_Face_setNormal(btSoftBody_Face* obj, const btScalar* value);
void btSoftBody_Face_setRa(btSoftBody_Face* obj, btScalar value);
btSoftBody_Feature* btSoftBody_Feature_new();
btSoftBody_Material* btSoftBody_Feature_getMaterial(btSoftBody_Feature* obj);
void btSoftBody_Feature_setMaterial(btSoftBody_Feature* obj, btSoftBody_Material* value);
btSoftBody_ImplicitFn* btSoftBody_ImplicitFnWrapper_new(pImplicitFn_Eval evalCallback);
btScalar btSoftBody_ImplicitFn_Eval(btSoftBody_ImplicitFn* obj, const btScalar* x);
void btSoftBody_ImplicitFn_delete(btSoftBody_ImplicitFn* obj);
btSoftBody_Impulse* btSoftBody_Impulse_new();
int btSoftBody_Impulse_getAsDrift(btSoftBody_Impulse* obj);
int btSoftBody_Impulse_getAsVelocity(btSoftBody_Impulse* obj);
void btSoftBody_Impulse_getDrift(btSoftBody_Impulse* obj, btScalar* value);
void btSoftBody_Impulse_getVelocity(btSoftBody_Impulse* obj, btScalar* value);
btSoftBody_Impulse* btSoftBody_Impulse_operator_n(btSoftBody_Impulse* obj);
btSoftBody_Impulse* btSoftBody_Impulse_operator_m(btSoftBody_Impulse* obj, btScalar x);
void btSoftBody_Impulse_setAsDrift(btSoftBody_Impulse* obj, int value);
void btSoftBody_Impulse_setAsVelocity(btSoftBody_Impulse* obj, int value);
void btSoftBody_Impulse_setDrift(btSoftBody_Impulse* obj, const btScalar* value);
void btSoftBody_Impulse_setVelocity(btSoftBody_Impulse* obj, const btScalar* value);
void btSoftBody_Impulse_delete(btSoftBody_Impulse* obj);
btSoftBody_Joint_Specs* btSoftBody_Joint_Specs_new();
btScalar btSoftBody_Joint_Specs_getCfm(btSoftBody_Joint_Specs* obj);
btScalar btSoftBody_Joint_Specs_getErp(btSoftBody_Joint_Specs* obj);
btScalar btSoftBody_Joint_Specs_getSplit(btSoftBody_Joint_Specs* obj);
void btSoftBody_Joint_Specs_setCfm(btSoftBody_Joint_Specs* obj, btScalar value);
void btSoftBody_Joint_Specs_setErp(btSoftBody_Joint_Specs* obj, btScalar value);
void btSoftBody_Joint_Specs_setSplit(btSoftBody_Joint_Specs* obj, btScalar value);
void btSoftBody_Joint_Specs_delete(btSoftBody_Joint_Specs* obj);
btSoftBody_Body* btSoftBody_Joint_getBodies(btSoftBody_Joint* obj);
btScalar btSoftBody_Joint_getCfm(btSoftBody_Joint* obj);
bool btSoftBody_Joint_getDelete(btSoftBody_Joint* obj);
void btSoftBody_Joint_getDrift(btSoftBody_Joint* obj, btScalar* value);
btScalar btSoftBody_Joint_getErp(btSoftBody_Joint* obj);
void btSoftBody_Joint_getMassmatrix(btSoftBody_Joint* obj, btScalar* value);
btVector3* btSoftBody_Joint_getRefs(btSoftBody_Joint* obj);
void btSoftBody_Joint_getSdrift(btSoftBody_Joint* obj, btScalar* value);
btScalar btSoftBody_Joint_getSplit(btSoftBody_Joint* obj);
void btSoftBody_Joint_Prepare(btSoftBody_Joint* obj, btScalar dt, int iterations);
void btSoftBody_Joint_setCfm(btSoftBody_Joint* obj, btScalar value);
void btSoftBody_Joint_setDelete(btSoftBody_Joint* obj, bool value);
void btSoftBody_Joint_setDrift(btSoftBody_Joint* obj, const btScalar* value);
void btSoftBody_Joint_setErp(btSoftBody_Joint* obj, btScalar value);
void btSoftBody_Joint_setMassmatrix(btSoftBody_Joint* obj, const btScalar* value);
void btSoftBody_Joint_setSdrift(btSoftBody_Joint* obj, const btScalar* value);
void btSoftBody_Joint_setSplit(btSoftBody_Joint* obj, btScalar value);
void btSoftBody_Joint_Solve(btSoftBody_Joint* obj, btScalar dt, btScalar sor);
void btSoftBody_Joint_Terminate(btSoftBody_Joint* obj, btScalar dt);
btSoftBody_Joint_eType btSoftBody_Joint_Type(btSoftBody_Joint* obj);
void btSoftBody_Joint_delete(btSoftBody_Joint* obj);
btSoftBody_Link* btSoftBody_Link_new();
btSoftBody_Link* btSoftBody_Link_new2(btSoftBody_Link* obj);
int btSoftBody_Link_getBbending(btSoftBody_Link* obj);
btScalar btSoftBody_Link_getC0(btSoftBody_Link* obj);
btScalar btSoftBody_Link_getC1(btSoftBody_Link* obj);
btScalar btSoftBody_Link_getC2(btSoftBody_Link* obj);
void btSoftBody_Link_getC3(btSoftBody_Link* obj, btScalar* value);
btSoftBody_Node** btSoftBody_Link_getN(btSoftBody_Link* obj);
btScalar btSoftBody_Link_getRl(btSoftBody_Link* obj);
void btSoftBody_Link_setBbending(btSoftBody_Link* obj, int value);
void btSoftBody_Link_setC0(btSoftBody_Link* obj, btScalar value);
void btSoftBody_Link_setC1(btSoftBody_Link* obj, btScalar value);
void btSoftBody_Link_setC2(btSoftBody_Link* obj, btScalar value);
void btSoftBody_Link_setC3(btSoftBody_Link* obj, const btScalar* value);
void btSoftBody_Link_setRl(btSoftBody_Link* obj, btScalar value);
btSoftBody_LJoint_Specs* btSoftBody_LJoint_Specs_new();
void btSoftBody_LJoint_Specs_getPosition(btSoftBody_LJoint_Specs* obj, btScalar* value);
void btSoftBody_LJoint_Specs_setPosition(btSoftBody_LJoint_Specs* obj, const btScalar* value);
btSoftBody_LJoint* btSoftBody_LJoint_new();
btVector3* btSoftBody_LJoint_getRpos(btSoftBody_LJoint* obj);
btSoftBody_Material* btSoftBody_Material_new();
int btSoftBody_Material_getFlags(btSoftBody_Material* obj);
btScalar btSoftBody_Material_getKAST(btSoftBody_Material* obj);
btScalar btSoftBody_Material_getKLST(btSoftBody_Material* obj);
btScalar btSoftBody_Material_getKVST(btSoftBody_Material* obj);
void btSoftBody_Material_setFlags(btSoftBody_Material* obj, int value);
void btSoftBody_Material_setKAST(btSoftBody_Material* obj, btScalar value);
void btSoftBody_Material_setKLST(btSoftBody_Material* obj, btScalar value);
void btSoftBody_Material_setKVST(btSoftBody_Material* obj, btScalar value);
btSoftBody_Node* btSoftBody_Node_new();
btScalar btSoftBody_Node_getArea(btSoftBody_Node* obj);
int btSoftBody_Node_getBattach(btSoftBody_Node* obj);
void btSoftBody_Node_getF(btSoftBody_Node* obj, btScalar* value);
btScalar btSoftBody_Node_getIm(btSoftBody_Node* obj);
btDbvtNode* btSoftBody_Node_getLeaf(btSoftBody_Node* obj);
void btSoftBody_Node_getN(btSoftBody_Node* obj, btScalar* value);
void btSoftBody_Node_getQ(btSoftBody_Node* obj, btScalar* value);
void btSoftBody_Node_getV(btSoftBody_Node* obj, btScalar* value);
void btSoftBody_Node_getX(btSoftBody_Node* obj, btScalar* value);
void btSoftBody_Node_setArea(btSoftBody_Node* obj, btScalar value);
void btSoftBody_Node_setBattach(btSoftBody_Node* obj, int value);
void btSoftBody_Node_setF(btSoftBody_Node* obj, const btScalar* value);
void btSoftBody_Node_setIm(btSoftBody_Node* obj, btScalar value);
void btSoftBody_Node_setLeaf(btSoftBody_Node* obj, btDbvtNode* value);
void btSoftBody_Node_setN(btSoftBody_Node* obj, const btScalar* value);
void btSoftBody_Node_setQ(btSoftBody_Node* obj, const btScalar* value);
void btSoftBody_Node_setV(btSoftBody_Node* obj, const btScalar* value);
void btSoftBody_Node_setX(btSoftBody_Node* obj, const btScalar* value);
btSoftBody_Note* btSoftBody_Note_new();
btScalar* btSoftBody_Note_getCoords(btSoftBody_Note* obj);
btSoftBody_Node** btSoftBody_Note_getNodes(btSoftBody_Note* obj);
void btSoftBody_Note_getOffset(btSoftBody_Note* obj, btScalar* value);
int btSoftBody_Note_getRank(btSoftBody_Note* obj);
const char* btSoftBody_Note_getText(btSoftBody_Note* obj);
void btSoftBody_Note_setOffset(btSoftBody_Note* obj, const btScalar* value);
void btSoftBody_Note_setRank(btSoftBody_Note* obj, int value);
void btSoftBody_Note_setText(btSoftBody_Note* obj, const char* value);
btSoftBody_Pose* btSoftBody_Pose_new();
void btSoftBody_Pose_getAqq(btSoftBody_Pose* obj, btScalar* value);
bool btSoftBody_Pose_getBframe(btSoftBody_Pose* obj);
bool btSoftBody_Pose_getBvolume(btSoftBody_Pose* obj);
void btSoftBody_Pose_getCom(btSoftBody_Pose* obj, btScalar* value);
btAlignedVector3Array* btSoftBody_Pose_getPos(btSoftBody_Pose* obj);
void btSoftBody_Pose_getRot(btSoftBody_Pose* obj, btScalar* value);
void btSoftBody_Pose_getScl(btSoftBody_Pose* obj, btScalar* value);
btAlignedScalarArray* btSoftBody_Pose_getWgh(btSoftBody_Pose* obj);
btScalar btSoftBody_Pose_getVolume(btSoftBody_Pose* obj);
void btSoftBody_Pose_setAqq(btSoftBody_Pose* obj, const btScalar* value);
void btSoftBody_Pose_setBframe(btSoftBody_Pose* obj, bool value);
void btSoftBody_Pose_setBvolume(btSoftBody_Pose* obj, bool value);
void btSoftBody_Pose_setCom(btSoftBody_Pose* obj, const btScalar* value);
void btSoftBody_Pose_setRot(btSoftBody_Pose* obj, const btScalar* value);
void btSoftBody_Pose_setScl(btSoftBody_Pose* obj, const btScalar* value);
void btSoftBody_Pose_setVolume(btSoftBody_Pose* obj, btScalar value);
void btSoftBody_Pose_delete(btSoftBody_Pose* obj);
btSoftBody_RayFromToCaster* btSoftBody_RayFromToCaster_new(const btScalar* rayFrom, const btScalar* rayTo, btScalar mxt);
btSoftBody_Face* btSoftBody_RayFromToCaster_getFace(btSoftBody_RayFromToCaster* obj);
btScalar btSoftBody_RayFromToCaster_getMint(btSoftBody_RayFromToCaster* obj);
void btSoftBody_RayFromToCaster_getRayFrom(btSoftBody_RayFromToCaster* obj, btScalar* value);
void btSoftBody_RayFromToCaster_getRayNormalizedDirection(btSoftBody_RayFromToCaster* obj, btScalar* value);
void btSoftBody_RayFromToCaster_getRayTo(btSoftBody_RayFromToCaster* obj, btScalar* value);
int btSoftBody_RayFromToCaster_getTests(btSoftBody_RayFromToCaster* obj);
btScalar btSoftBody_RayFromToCaster_rayFromToTriangle(const btScalar* rayFrom, const btScalar* rayTo, const btScalar* rayNormalizedDirection, const btScalar* a, const btScalar* b, const btScalar* c);
btScalar btSoftBody_RayFromToCaster_rayFromToTriangle2(const btScalar* rayFrom, const btScalar* rayTo, const btScalar* rayNormalizedDirection, const btScalar* a, const btScalar* b, const btScalar* c, btScalar maxt);
void btSoftBody_RayFromToCaster_setFace(btSoftBody_RayFromToCaster* obj, btSoftBody_Face* value);
void btSoftBody_RayFromToCaster_setMint(btSoftBody_RayFromToCaster* obj, btScalar value);
void btSoftBody_RayFromToCaster_setRayFrom(btSoftBody_RayFromToCaster* obj, const btScalar* value);
void btSoftBody_RayFromToCaster_setRayNormalizedDirection(btSoftBody_RayFromToCaster* obj, const btScalar* value);
void btSoftBody_RayFromToCaster_setRayTo(btSoftBody_RayFromToCaster* obj, const btScalar* value);
void btSoftBody_RayFromToCaster_setTests(btSoftBody_RayFromToCaster* obj, int value);
btSoftBody_RContact* btSoftBody_RContact_new();
void btSoftBody_RContact_getC0(btSoftBody_RContact* obj, btScalar* value);
void btSoftBody_RContact_getC1(btSoftBody_RContact* obj, btScalar* value);
btScalar btSoftBody_RContact_getC2(btSoftBody_RContact* obj);
btScalar btSoftBody_RContact_getC3(btSoftBody_RContact* obj);
btScalar btSoftBody_RContact_getC4(btSoftBody_RContact* obj);
btSoftBody_sCti* btSoftBody_RContact_getCti(btSoftBody_RContact* obj);
btSoftBody_Node* btSoftBody_RContact_getNode(btSoftBody_RContact* obj);
void btSoftBody_RContact_setC0(btSoftBody_RContact* obj, const btScalar* value);
void btSoftBody_RContact_setC1(btSoftBody_RContact* obj, const btScalar* value);
void btSoftBody_RContact_setC2(btSoftBody_RContact* obj, btScalar value);
void btSoftBody_RContact_setC3(btSoftBody_RContact* obj, btScalar value);
void btSoftBody_RContact_setC4(btSoftBody_RContact* obj, btScalar value);
void btSoftBody_RContact_setNode(btSoftBody_RContact* obj, btSoftBody_Node* value);
void btSoftBody_RContact_delete(btSoftBody_RContact* obj);
btSoftBody_SContact* btSoftBody_SContact_new();
btScalar* btSoftBody_SContact_getCfm(btSoftBody_SContact* obj);
btSoftBody_Face* btSoftBody_SContact_getFace(btSoftBody_SContact* obj);
btScalar btSoftBody_SContact_getFriction(btSoftBody_SContact* obj);
btScalar btSoftBody_SContact_getMargin(btSoftBody_SContact* obj);
btSoftBody_Node* btSoftBody_SContact_getNode(btSoftBody_SContact* obj);
void btSoftBody_SContact_getNormal(btSoftBody_SContact* obj, btScalar* value);
void btSoftBody_SContact_getWeights(btSoftBody_SContact* obj, btScalar* value);
void btSoftBody_SContact_setFace(btSoftBody_SContact* obj, btSoftBody_Face* value);
void btSoftBody_SContact_setFriction(btSoftBody_SContact* obj, btScalar value);
void btSoftBody_SContact_setMargin(btSoftBody_SContact* obj, btScalar value);
void btSoftBody_SContact_setNode(btSoftBody_SContact* obj, btSoftBody_Node* value);
void btSoftBody_SContact_setNormal(btSoftBody_SContact* obj, const btScalar* value);
void btSoftBody_SContact_setWeights(btSoftBody_SContact* obj, const btScalar* value);
void btSoftBody_SContact_delete(btSoftBody_SContact* obj);
btSoftBody_sCti* btSoftBody_sCti_new();
const btCollisionObject* btSoftBody_sCti_getColObj(btSoftBody_sCti* obj);
void btSoftBody_sCti_getNormal(btSoftBody_sCti* obj, btScalar* value);
btScalar btSoftBody_sCti_getOffset(btSoftBody_sCti* obj);
void btSoftBody_sCti_setColObj(btSoftBody_sCti* obj, const btCollisionObject* value);
void btSoftBody_sCti_setNormal(btSoftBody_sCti* obj, const btScalar* value);
void btSoftBody_sCti_setOffset(btSoftBody_sCti* obj, btScalar value);
void btSoftBody_sCti_delete(btSoftBody_sCti* obj);
btSoftBody_sMedium* btSoftBody_sMedium_new();
btScalar btSoftBody_sMedium_getDensity(btSoftBody_sMedium* obj);
btScalar btSoftBody_sMedium_getPressure(btSoftBody_sMedium* obj);
void btSoftBody_sMedium_getVelocity(btSoftBody_sMedium* obj, btScalar* value);
void btSoftBody_sMedium_setDensity(btSoftBody_sMedium* obj, btScalar value);
void btSoftBody_sMedium_setPressure(btSoftBody_sMedium* obj, btScalar value);
void btSoftBody_sMedium_setVelocity(btSoftBody_sMedium* obj, const btScalar* value);
void btSoftBody_sMedium_delete(btSoftBody_sMedium* obj);
btSoftBody_SolverState* btSoftBody_SolverState_new();
btScalar btSoftBody_SolverState_getIsdt(btSoftBody_SolverState* obj);
btScalar btSoftBody_SolverState_getRadmrg(btSoftBody_SolverState* obj);
btScalar btSoftBody_SolverState_getSdt(btSoftBody_SolverState* obj);
btScalar btSoftBody_SolverState_getUpdmrg(btSoftBody_SolverState* obj);
btScalar btSoftBody_SolverState_getVelmrg(btSoftBody_SolverState* obj);
void btSoftBody_SolverState_setIsdt(btSoftBody_SolverState* obj, btScalar value);
void btSoftBody_SolverState_setRadmrg(btSoftBody_SolverState* obj, btScalar value);
void btSoftBody_SolverState_setSdt(btSoftBody_SolverState* obj, btScalar value);
void btSoftBody_SolverState_setUpdmrg(btSoftBody_SolverState* obj, btScalar value);
void btSoftBody_SolverState_setVelmrg(btSoftBody_SolverState* obj, btScalar value);
void btSoftBody_SolverState_delete(btSoftBody_SolverState* obj);
btSoftBody_sRayCast* btSoftBody_sRayCast_new();
btSoftBody* btSoftBody_sRayCast_getBody(btSoftBody_sRayCast* obj);
btSoftBody_eFeature btSoftBody_sRayCast_getFeature(btSoftBody_sRayCast* obj);
btScalar btSoftBody_sRayCast_getFraction(btSoftBody_sRayCast* obj);
int btSoftBody_sRayCast_getIndex(btSoftBody_sRayCast* obj);
void btSoftBody_sRayCast_setBody(btSoftBody_sRayCast* obj, btSoftBody* value);
void btSoftBody_sRayCast_setFeature(btSoftBody_sRayCast* obj, btSoftBody_eFeature value);
void btSoftBody_sRayCast_setFraction(btSoftBody_sRayCast* obj, btScalar value);
void btSoftBody_sRayCast_setIndex(btSoftBody_sRayCast* obj, int value);
void btSoftBody_sRayCast_delete(btSoftBody_sRayCast* obj);
btSoftBody_Tetra* btSoftBody_Tetra_new();
btVector3* btSoftBody_Tetra_getC0(btSoftBody_Tetra* obj);
btScalar btSoftBody_Tetra_getC1(btSoftBody_Tetra* obj);
btScalar btSoftBody_Tetra_getC2(btSoftBody_Tetra* obj);
btDbvtNode* btSoftBody_Tetra_getLeaf(btSoftBody_Tetra* obj);
btSoftBody_Node** btSoftBody_Tetra_getN(btSoftBody_Tetra* obj);
btScalar btSoftBody_Tetra_getRv(btSoftBody_Tetra* obj);
void btSoftBody_Tetra_setC1(btSoftBody_Tetra* obj, btScalar value);
void btSoftBody_Tetra_setC2(btSoftBody_Tetra* obj, btScalar value);
void btSoftBody_Tetra_setLeaf(btSoftBody_Tetra* obj, btDbvtNode* value);
void btSoftBody_Tetra_setRv(btSoftBody_Tetra* obj, btScalar value);
btSoftBody* btSoftBody_new(btSoftBodyWorldInfo* worldInfo, int node_count, const btScalar* x, const btScalar* m);
btSoftBody* btSoftBody_new2(btSoftBodyWorldInfo* worldInfo);
void btSoftBody_addAeroForceToFace(btSoftBody* obj, const btScalar* windVelocity, int faceIndex);
void btSoftBody_addAeroForceToNode(btSoftBody* obj, const btScalar* windVelocity, int nodeIndex);
void btSoftBody_addForce(btSoftBody* obj, const btScalar* force);
void btSoftBody_addForce2(btSoftBody* obj, const btScalar* force, int node);
void btSoftBody_addVelocity(btSoftBody* obj, const btScalar* velocity, int node);
void btSoftBody_addVelocity2(btSoftBody* obj, const btScalar* velocity);
void btSoftBody_appendAnchor(btSoftBody* obj, int node, btRigidBody* body, const btScalar* localPivot);
void btSoftBody_appendAnchor2(btSoftBody* obj, int node, btRigidBody* body, const btScalar* localPivot, bool disableCollisionBetweenLinkedBodies);
void btSoftBody_appendAnchor3(btSoftBody* obj, int node, btRigidBody* body, const btScalar* localPivot, bool disableCollisionBetweenLinkedBodies, btScalar influence);
void btSoftBody_appendAnchor4(btSoftBody* obj, int node, btRigidBody* body);
void btSoftBody_appendAnchor5(btSoftBody* obj, int node, btRigidBody* body, bool disableCollisionBetweenLinkedBodies);
void btSoftBody_appendAnchor6(btSoftBody* obj, int node, btRigidBody* body, bool disableCollisionBetweenLinkedBodies, btScalar influence);
void btSoftBody_appendAngularJoint(btSoftBody* obj, const btSoftBody_AJoint_Specs* specs);
void btSoftBody_appendAngularJoint2(btSoftBody* obj, const btSoftBody_AJoint_Specs* specs, btSoftBody_Body* body);
void btSoftBody_appendAngularJoint3(btSoftBody* obj, const btSoftBody_AJoint_Specs* specs, btSoftBody* body);
void btSoftBody_appendAngularJoint4(btSoftBody* obj, const btSoftBody_AJoint_Specs* specs, btSoftBody_Cluster* body0, btSoftBody_Body* body1);
void btSoftBody_appendFace(btSoftBody* obj);
void btSoftBody_appendFace2(btSoftBody* obj, int model);
void btSoftBody_appendFace3(btSoftBody* obj, int model, btSoftBody_Material* mat);
void btSoftBody_appendFace4(btSoftBody* obj, int node0, int node1, int node2);
void btSoftBody_appendFace5(btSoftBody* obj, int node0, int node1, int node2, btSoftBody_Material* mat);
void btSoftBody_appendLinearJoint(btSoftBody* obj, const btSoftBody_LJoint_Specs* specs, btSoftBody* body);
void btSoftBody_appendLinearJoint2(btSoftBody* obj, const btSoftBody_LJoint_Specs* specs);
void btSoftBody_appendLinearJoint3(btSoftBody* obj, const btSoftBody_LJoint_Specs* specs, btSoftBody_Body* body);
void btSoftBody_appendLinearJoint4(btSoftBody* obj, const btSoftBody_LJoint_Specs* specs, btSoftBody_Cluster* body0, btSoftBody_Body* body1);
void btSoftBody_appendLink(btSoftBody* obj, int node0, int node1);
void btSoftBody_appendLink2(btSoftBody* obj, int node0, int node1, btSoftBody_Material* mat);
void btSoftBody_appendLink3(btSoftBody* obj, int node0, int node1, btSoftBody_Material* mat, bool bcheckexist);
void btSoftBody_appendLink4(btSoftBody* obj);
void btSoftBody_appendLink5(btSoftBody* obj, int model);
void btSoftBody_appendLink6(btSoftBody* obj, int model, btSoftBody_Material* mat);
void btSoftBody_appendLink7(btSoftBody* obj, btSoftBody_Node* node0, btSoftBody_Node* node1);
void btSoftBody_appendLink8(btSoftBody* obj, btSoftBody_Node* node0, btSoftBody_Node* node1, btSoftBody_Material* mat);
void btSoftBody_appendLink9(btSoftBody* obj, btSoftBody_Node* node0, btSoftBody_Node* node1, btSoftBody_Material* mat, bool bcheckexist);
btSoftBody_Material* btSoftBody_appendMaterial(btSoftBody* obj);
void btSoftBody_appendNode(btSoftBody* obj, const btScalar* x, btScalar m);
void btSoftBody_appendNote(btSoftBody* obj, const char* text, const btScalar* o, btSoftBody_Face* feature);
void btSoftBody_appendNote2(btSoftBody* obj, const char* text, const btScalar* o, btSoftBody_Link* feature);
void btSoftBody_appendNote3(btSoftBody* obj, const char* text, const btScalar* o, btSoftBody_Node* feature);
void btSoftBody_appendNote4(btSoftBody* obj, const char* text, const btScalar* o);
void btSoftBody_appendNote5(btSoftBody* obj, const char* text, const btScalar* o, const btScalar* c);
void btSoftBody_appendNote6(btSoftBody* obj, const char* text, const btScalar* o, const btScalar* c, btSoftBody_Node* n0);
void btSoftBody_appendNote7(btSoftBody* obj, const char* text, const btScalar* o, const btScalar* c, btSoftBody_Node* n0, btSoftBody_Node* n1);
void btSoftBody_appendNote8(btSoftBody* obj, const char* text, const btScalar* o, const btScalar* c, btSoftBody_Node* n0, btSoftBody_Node* n1, btSoftBody_Node* n2);
void btSoftBody_appendNote9(btSoftBody* obj, const char* text, const btScalar* o, const btScalar* c, btSoftBody_Node* n0, btSoftBody_Node* n1, btSoftBody_Node* n2, btSoftBody_Node* n3);
void btSoftBody_appendTetra(btSoftBody* obj, int model, btSoftBody_Material* mat);
void btSoftBody_appendTetra2(btSoftBody* obj, int node0, int node1, int node2, int node3);
void btSoftBody_appendTetra3(btSoftBody* obj, int node0, int node1, int node2, int node3, btSoftBody_Material* mat);
void btSoftBody_applyClusters(btSoftBody* obj, bool drift);
void btSoftBody_applyForces(btSoftBody* obj);
bool btSoftBody_checkContact(btSoftBody* obj, const btCollisionObjectWrapper* colObjWrap, const btScalar* x, btScalar margin, btSoftBody_sCti* cti);
bool btSoftBody_checkFace(btSoftBody* obj, int node0, int node1, int node2);
bool btSoftBody_checkLink(btSoftBody* obj, const btSoftBody_Node* node0, const btSoftBody_Node* node1);
bool btSoftBody_checkLink2(btSoftBody* obj, int node0, int node1);
void btSoftBody_cleanupClusters(btSoftBody* obj);
void btSoftBody_clusterAImpulse(btSoftBody_Cluster* cluster, const btSoftBody_Impulse* impulse);
void btSoftBody_clusterCom(btSoftBody* obj, int cluster, btScalar* value);
void btSoftBody_clusterCom2(const btSoftBody_Cluster* cluster, btScalar* value);
int btSoftBody_clusterCount(btSoftBody* obj);
void btSoftBody_clusterDAImpulse(btSoftBody_Cluster* cluster, const btScalar* impulse);
void btSoftBody_clusterDCImpulse(btSoftBody_Cluster* cluster, const btScalar* impulse);
void btSoftBody_clusterDImpulse(btSoftBody_Cluster* cluster, const btScalar* rpos, const btScalar* impulse);
void btSoftBody_clusterImpulse(btSoftBody_Cluster* cluster, const btScalar* rpos, const btSoftBody_Impulse* impulse);
void btSoftBody_clusterVAImpulse(btSoftBody_Cluster* cluster, const btScalar* impulse);
void btSoftBody_clusterVelocity(const btSoftBody_Cluster* cluster, const btScalar* rpos, btScalar* value);
void btSoftBody_clusterVImpulse(btSoftBody_Cluster* cluster, const btScalar* rpos, const btScalar* impulse);
bool btSoftBody_cutLink(btSoftBody* obj, const btSoftBody_Node* node0, const btSoftBody_Node* node1, btScalar position);
bool btSoftBody_cutLink2(btSoftBody* obj, int node0, int node1, btScalar position);
void btSoftBody_dampClusters(btSoftBody* obj);
void btSoftBody_defaultCollisionHandler(btSoftBody* obj, const btCollisionObjectWrapper* pcoWrap);
void btSoftBody_defaultCollisionHandler2(btSoftBody* obj, btSoftBody* psb);
void btSoftBody_evaluateCom(btSoftBody* obj, btScalar* value);
int btSoftBody_generateBendingConstraints(btSoftBody* obj, int distance);
int btSoftBody_generateBendingConstraints2(btSoftBody* obj, int distance, btSoftBody_Material* mat);
int btSoftBody_generateClusters(btSoftBody* obj, int k);
int btSoftBody_generateClusters2(btSoftBody* obj, int k, int maxiterations);
void btSoftBody_getAabb(btSoftBody* obj, btScalar* aabbMin, btScalar* aabbMax);
btAlignedSoftBodyAnchorArray* btSoftBody_getAnchors(btSoftBody* obj);
btVector3* btSoftBody_getBounds(btSoftBody* obj);
bool btSoftBody_getBUpdateRtCst(btSoftBody* obj);
btDbvt* btSoftBody_getCdbvt(btSoftBody* obj);
btSoftBody_Config* btSoftBody_getCfg(btSoftBody* obj);
btAlignedBoolArray* btSoftBody_getClusterConnectivity(btSoftBody* obj);
btAlignedSoftBodyClusterArray* btSoftBody_getClusters(btSoftBody* obj);
btAlignedConstCollisionObjectArray* btSoftBody_getCollisionDisabledObjects(btSoftBody* obj);
btAlignedSoftBodyFaceArray* btSoftBody_getFaces(btSoftBody* obj);
btDbvt* btSoftBody_getFdbvt(btSoftBody* obj);
void btSoftBody_getInitialWorldTransform(btSoftBody* obj, btScalar* value);
btAlignedSoftBodyJointArray* btSoftBody_getJoints(btSoftBody* obj);
btAlignedSoftBodyLinkArray* btSoftBody_getLinks(btSoftBody* obj);
btScalar btSoftBody_getMass(btSoftBody* obj, int node);
btAlignedSoftBodyMaterialArray* btSoftBody_getMaterials(btSoftBody* obj);
btDbvt* btSoftBody_getNdbvt(btSoftBody* obj);
btAlignedSoftBodyNodeArray* btSoftBody_getNodes(btSoftBody* obj);
btAlignedSoftBodyNoteArray* btSoftBody_getNotes(btSoftBody* obj);
btSoftBody_Pose* btSoftBody_getPose(btSoftBody* obj);
btAlignedSoftBodyRContactArray* btSoftBody_getRcontacts(btSoftBody* obj);
btScalar btSoftBody_getRestLengthScale(btSoftBody* obj);
btAlignedSoftBodySContactArray* btSoftBody_getScontacts(btSoftBody* obj);
btSoftBodySolver* btSoftBody_getSoftBodySolver(btSoftBody* obj);
btSoftBody_psolver_t btSoftBody_getSolver(btSoftBody_ePSolver solver);
btSoftBody_vsolver_t btSoftBody_getSolver2(btSoftBody_eVSolver solver);
btSoftBody_SolverState* btSoftBody_getSst(btSoftBody* obj);
void* btSoftBody_getTag(btSoftBody* obj);
btAlignedSoftBodyTetraArray* btSoftBody_getTetras(btSoftBody* obj);
btScalar btSoftBody_getTimeacc(btSoftBody* obj);
btScalar btSoftBody_getTotalMass(btSoftBody* obj);
btAlignedIntArray* btSoftBody_getUserIndexMapping(btSoftBody* obj);
void btSoftBody_getWindVelocity(btSoftBody* obj, btScalar* velocity);
btScalar btSoftBody_getVolume(btSoftBody* obj);
btSoftBodyWorldInfo* btSoftBody_getWorldInfo(btSoftBody* obj);
void btSoftBody_indicesToPointers(btSoftBody* obj);
void btSoftBody_indicesToPointers2(btSoftBody* obj, const int* map);
void btSoftBody_initDefaults(btSoftBody* obj);
void btSoftBody_initializeClusters(btSoftBody* obj);
void btSoftBody_initializeFaceTree(btSoftBody* obj);
void btSoftBody_integrateMotion(btSoftBody* obj);
void btSoftBody_pointersToIndices(btSoftBody* obj);
void btSoftBody_predictMotion(btSoftBody* obj, btScalar dt);
void btSoftBody_prepareClusters(btSoftBody* obj, int iterations);
void btSoftBody_PSolve_Anchors(btSoftBody* psb, btScalar kst, btScalar ti);
void btSoftBody_PSolve_Links(btSoftBody* psb, btScalar kst, btScalar ti);
void btSoftBody_PSolve_RContacts(btSoftBody* psb, btScalar kst, btScalar ti);
void btSoftBody_PSolve_SContacts(btSoftBody* psb, btScalar __unnamed1, btScalar ti);
void btSoftBody_randomizeConstraints(btSoftBody* obj);
bool btSoftBody_rayTest(btSoftBody* obj, const btScalar* rayFrom, const btScalar* rayTo, btSoftBody_sRayCast* results);
int btSoftBody_rayTest2(btSoftBody* obj, const btScalar* rayFrom, const btScalar* rayTo, btScalar* mint, btSoftBody_eFeature feature, int* index, bool bcountonly);
void btSoftBody_refine(btSoftBody* obj, btSoftBody_ImplicitFn* ifn, btScalar accurary, bool cut);
void btSoftBody_releaseCluster(btSoftBody* obj, int index);
void btSoftBody_releaseClusters(btSoftBody* obj);
void btSoftBody_resetLinkRestLengths(btSoftBody* obj);
void btSoftBody_rotate(btSoftBody* obj, const btScalar* rot);
void btSoftBody_scale(btSoftBody* obj, const btScalar* scl);
void btSoftBody_setBUpdateRtCst(btSoftBody* obj, bool value);
void btSoftBody_setInitialWorldTransform(btSoftBody* obj, const btScalar* value);
void btSoftBody_setMass(btSoftBody* obj, int node, btScalar mass);
void btSoftBody_setNdbvt(btSoftBody* obj, btDbvt* value);
void btSoftBody_setPose(btSoftBody* obj, bool bvolume, bool bframe);
void btSoftBody_setRestLengthScale(btSoftBody* obj, btScalar restLength);
void btSoftBody_setSoftBodySolver(btSoftBody* obj, btSoftBodySolver* softBodySolver);
void btSoftBody_setSolver(btSoftBody* obj, btSoftBody_eSolverPresets preset);
void btSoftBody_setTag(btSoftBody* obj, void* value);
void btSoftBody_setTimeacc(btSoftBody* obj, btScalar value);
void btSoftBody_setTotalDensity(btSoftBody* obj, btScalar density);
void btSoftBody_setTotalMass(btSoftBody* obj, btScalar mass);
void btSoftBody_setTotalMass2(btSoftBody* obj, btScalar mass, bool fromfaces);
void btSoftBody_setVelocity(btSoftBody* obj, const btScalar* velocity);
void btSoftBody_setWindVelocity(btSoftBody* obj, const btScalar* velocity);
void btSoftBody_setVolumeDensity(btSoftBody* obj, btScalar density);
void btSoftBody_setVolumeMass(btSoftBody* obj, btScalar mass);
void btSoftBody_setWorldInfo(btSoftBody* obj, btSoftBodyWorldInfo* value);
void btSoftBody_solveClusters(const btAlignedSoftBodyArray* bodies);
void btSoftBody_solveClusters2(btSoftBody* obj, btScalar sor);
void btSoftBody_solveCommonConstraints(btSoftBody** bodies, int count, int iterations);
void btSoftBody_solveConstraints(btSoftBody* obj);
void btSoftBody_staticSolve(btSoftBody* obj, int iterations);
void btSoftBody_transform(btSoftBody* obj, const btScalar* trs);
void btSoftBody_translate(btSoftBody* obj, const btScalar* trs);
btSoftBody* btSoftBody_upcast(btCollisionObject* colObj);
void btSoftBody_updateArea(btSoftBody* obj);
void btSoftBody_updateArea2(btSoftBody* obj, bool averageArea);
void btSoftBody_updateBounds(btSoftBody* obj);
void btSoftBody_updateClusters(btSoftBody* obj);
void btSoftBody_updateConstants(btSoftBody* obj);
void btSoftBody_updateLinkConstants(btSoftBody* obj);
void btSoftBody_updateNormals(btSoftBody* obj);
void btSoftBody_updatePose(btSoftBody* obj);
void btSoftBody_VSolve_Links(btSoftBody* psb, btScalar kst);
int btSoftBody_getFaceVertexData(btSoftBody* obj, btScalar* vertices);
int btSoftBody_getFaceVertexNormalData(btSoftBody* obj, btScalar* vertices);
int btSoftBody_getFaceVertexNormalData2(btSoftBody* obj, btScalar* vertices, btScalar* normals);
int btSoftBody_getLinkVertexData(btSoftBody* obj, btScalar* vertices);
int btSoftBody_getLinkVertexNormalData(btSoftBody* obj, btScalar* vertices);
int btSoftBody_getTetraVertexData(btSoftBody* obj, btScalar* vertices);
int btSoftBody_getTetraVertexNormalData(btSoftBody* obj, btScalar* vertices);
int btSoftBody_getTetraVertexNormalData2(btSoftBody* obj, btScalar* vertices, btScalar* normals);
btSoftRigidCollisionAlgorithm_CreateFunc* btSoftRigidCollisionAlgorithm_CreateFunc_new();
btSoftRigidCollisionAlgorithm* btSoftRigidCollisionAlgorithm_new(btPersistentManifold* mf, const btCollisionAlgorithmConstructionInfo* ci, const btCollisionObjectWrapper* col0, const btCollisionObjectWrapper* col1Wrap, bool isSwapped);
btSoftRigidDynamicsWorld* btSoftRigidDynamicsWorld_new(btDispatcher* dispatcher, btBroadphaseInterface* pairCache, btConstraintSolver* constraintSolver, btCollisionConfiguration* collisionConfiguration);
btSoftRigidDynamicsWorld* btSoftRigidDynamicsWorld_new2(btDispatcher* dispatcher, btBroadphaseInterface* pairCache, btConstraintSolver* constraintSolver, btCollisionConfiguration* collisionConfiguration, btSoftBodySolver* softBodySolver);
void btSoftRigidDynamicsWorld_addSoftBody(btSoftRigidDynamicsWorld* obj, btSoftBody* body);
void btSoftRigidDynamicsWorld_addSoftBody2(btSoftRigidDynamicsWorld* obj, btSoftBody* body, short collisionFilterGroup);
void btSoftRigidDynamicsWorld_addSoftBody3(btSoftRigidDynamicsWorld* obj, btSoftBody* body, short collisionFilterGroup, short collisionFilterMask);
int btSoftRigidDynamicsWorld_getDrawFlags(btSoftRigidDynamicsWorld* obj);
btSoftBodyArray* btSoftRigidDynamicsWorld_getSoftBodyArray(btSoftRigidDynamicsWorld* obj);
btSoftBodyWorldInfo* btSoftRigidDynamicsWorld_getWorldInfo(btSoftRigidDynamicsWorld* obj);
void btSoftRigidDynamicsWorld_removeSoftBody(btSoftRigidDynamicsWorld* obj, btSoftBody* body);
void btSoftRigidDynamicsWorld_setDrawFlags(btSoftRigidDynamicsWorld* obj, int f);
btSoftSoftCollisionAlgorithm_CreateFunc* btSoftSoftCollisionAlgorithm_CreateFunc_new();
btSoftSoftCollisionAlgorithm* btSoftSoftCollisionAlgorithm_new(const btCollisionAlgorithmConstructionInfo* ci);
btSoftSoftCollisionAlgorithm* btSoftSoftCollisionAlgorithm_new2(btPersistentManifold* mf, const btCollisionAlgorithmConstructionInfo* ci, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap);
btSparseSdf3* btSparseSdf_new();
void btSparseSdf3_GarbageCollect(btSparseSdf3* obj, int lifetime);
void btSparseSdf3_GarbageCollect2(btSparseSdf3* obj);
void btSparseSdf3_Initialize(btSparseSdf3* obj, int hashsize, int clampCells);
void btSparseSdf3_Initialize2(btSparseSdf3* obj, int hashsize);
void btSparseSdf3_Initialize3(btSparseSdf3* obj);
int btSparseSdf3_RemoveReferences(btSparseSdf3* obj, btCollisionShape* pcs);
void btSparseSdf3_Reset(btSparseSdf3* obj);
void btSparseSdf_delete(btSparseSdf3* obj);
btSphereBoxCollisionAlgorithm_CreateFunc* btSphereBoxCollisionAlgorithm_CreateFunc_new();
btSphereBoxCollisionAlgorithm* btSphereBoxCollisionAlgorithm_new(btPersistentManifold* mf, const btCollisionAlgorithmConstructionInfo* ci, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, bool isSwapped);
bool btSphereBoxCollisionAlgorithm_getSphereDistance(btSphereBoxCollisionAlgorithm* obj, const btCollisionObjectWrapper* boxObjWrap, btScalar* v3PointOnBox, btScalar* normal, btScalar* penetrationDepth, const btScalar* v3SphereCenter, btScalar fRadius, btScalar maxContactDistance);
btScalar btSphereBoxCollisionAlgorithm_getSpherePenetration(btSphereBoxCollisionAlgorithm* obj, const btScalar* boxHalfExtent, const btScalar* sphereRelPos, btScalar* closestPoint, btScalar* normal);
btSphereShape* btSphereShape_new(btScalar radius);
btScalar btSphereShape_getRadius(btSphereShape* obj);
void btSphereShape_setUnscaledRadius(btSphereShape* obj, btScalar radius);
btSphereSphereCollisionAlgorithm_CreateFunc* btSphereSphereCollisionAlgorithm_CreateFunc_new();
btSphereSphereCollisionAlgorithm* btSphereSphereCollisionAlgorithm_new(btPersistentManifold* mf, const btCollisionAlgorithmConstructionInfo* ci, const btCollisionObjectWrapper* col0Wrap, const btCollisionObjectWrapper* col1Wrap);
btSphereSphereCollisionAlgorithm* btSphereSphereCollisionAlgorithm_new2(const btCollisionAlgorithmConstructionInfo* ci);
btSphereTriangleCollisionAlgorithm_CreateFunc* btSphereTriangleCollisionAlgorithm_CreateFunc_new();
btSphereTriangleCollisionAlgorithm* btSphereTriangleCollisionAlgorithm_new(btPersistentManifold* mf, const btCollisionAlgorithmConstructionInfo* ci, const btCollisionObjectWrapper* body0Wrap, const btCollisionObjectWrapper* body1Wrap, bool swapped);
btSphereTriangleCollisionAlgorithm* btSphereTriangleCollisionAlgorithm_new2(const btCollisionAlgorithmConstructionInfo* ci);
btStaticPlaneShape* btStaticPlaneShape_new(const btScalar* planeNormal, btScalar planeConstant);
btScalar btStaticPlaneShape_getPlaneConstant(btStaticPlaneShape* obj);
void btStaticPlaneShape_getPlaneNormal(btStaticPlaneShape* obj, btScalar* value);
void btStridingMeshInterface_calculateAabbBruteForce(btStridingMeshInterface* obj, btScalar* aabbMin, btScalar* aabbMax);
int btStridingMeshInterface_calculateSerializeBufferSize(btStridingMeshInterface* obj);
void btStridingMeshInterface_getLockedReadOnlyVertexIndexBase(btStridingMeshInterface* obj, const unsigned char** vertexbase, int* numverts, PHY_ScalarType* type, int* stride, const unsigned char** indexbase, int* indexstride, int* numfaces, PHY_ScalarType* indicestype);
void btStridingMeshInterface_getLockedReadOnlyVertexIndexBase2(btStridingMeshInterface* obj, const unsigned char** vertexbase, int* numverts, PHY_ScalarType* type, int* stride, const unsigned char** indexbase, int* indexstride, int* numfaces, PHY_ScalarType* indicestype, int subpart);
void btStridingMeshInterface_getLockedVertexIndexBase(btStridingMeshInterface* obj, unsigned char** vertexbase, int* numverts, PHY_ScalarType* type, int* stride, unsigned char** indexbase, int* indexstride, int* numfaces, PHY_ScalarType* indicestype);
void btStridingMeshInterface_getLockedVertexIndexBase2(btStridingMeshInterface* obj, unsigned char** vertexbase, int* numverts, PHY_ScalarType* type, int* stride, unsigned char** indexbase, int* indexstride, int* numfaces, PHY_ScalarType* indicestype, int subpart);
int btStridingMeshInterface_getNumSubParts(btStridingMeshInterface* obj);
void btStridingMeshInterface_getPremadeAabb(btStridingMeshInterface* obj, btScalar* aabbMin, btScalar* aabbMax);
void btStridingMeshInterface_getScaling(btStridingMeshInterface* obj, btScalar* scaling);
bool btStridingMeshInterface_hasPremadeAabb(btStridingMeshInterface* obj);
void btStridingMeshInterface_InternalProcessAllTriangles(btStridingMeshInterface* obj, btInternalTriangleIndexCallback* callback, const btScalar* aabbMin, const btScalar* aabbMax);
void btStridingMeshInterface_preallocateIndices(btStridingMeshInterface* obj, int numindices);
void btStridingMeshInterface_preallocateVertices(btStridingMeshInterface* obj, int numverts);
const char* btStridingMeshInterface_serialize(btStridingMeshInterface* obj, void* dataBuffer, btSerializer* serializer);
void btStridingMeshInterface_setPremadeAabb(btStridingMeshInterface* obj, const btScalar* aabbMin, const btScalar* aabbMax);
void btStridingMeshInterface_setScaling(btStridingMeshInterface* obj, const btScalar* scaling);
void btStridingMeshInterface_unLockReadOnlyVertexBase(btStridingMeshInterface* obj, int subpart);
void btStridingMeshInterface_unLockVertexBase(btStridingMeshInterface* obj, int subpart);
void btStridingMeshInterface_delete(btStridingMeshInterface* obj);
btBU_Simplex1to4* btBU_Simplex1to4_new();
btBU_Simplex1to4* btBU_Simplex1to4_new2(const btScalar* pt0);
btBU_Simplex1to4* btBU_Simplex1to4_new3(const btScalar* pt0, const btScalar* pt1);
btBU_Simplex1to4* btBU_Simplex1to4_new4(const btScalar* pt0, const btScalar* pt1, const btScalar* pt2);
btBU_Simplex1to4* btBU_Simplex1to4_new5(const btScalar* pt0, const btScalar* pt1, const btScalar* pt2, const btScalar* pt3);
void btBU_Simplex1to4_addVertex(btBU_Simplex1to4* obj, const btScalar* pt);
int btBU_Simplex1to4_getIndex(btBU_Simplex1to4* obj, int i);
void btBU_Simplex1to4_reset(btBU_Simplex1to4* obj);
void btTransformUtil_calculateDiffAxisAngle(const btScalar* transform0, const btScalar* transform1, btScalar* axis, btScalar* angle);
void btTransformUtil_calculateDiffAxisAngleQuaternion(const btScalar* orn0, const btScalar* orn1a, btScalar* axis, btScalar* angle);
void btTransformUtil_calculateVelocity(const btScalar* transform0, const btScalar* transform1, btScalar timeStep, btScalar* linVel, btScalar* angVel);
void btTransformUtil_calculateVelocityQuaternion(const btScalar* pos0, const btScalar* pos1, const btScalar* orn0, const btScalar* orn1, btScalar timeStep, btScalar* linVel, btScalar* angVel);
void btTransformUtil_integrateTransform(const btScalar* curTrans, const btScalar* linvel, const btScalar* angvel, btScalar timeStep, btScalar* predictedTransform);
btConvexSeparatingDistanceUtil* btConvexSeparatingDistanceUtil_new(btScalar boundingRadiusA, btScalar boundingRadiusB);
btScalar btConvexSeparatingDistanceUtil_getConservativeSeparatingDistance(btConvexSeparatingDistanceUtil* obj);
void btConvexSeparatingDistanceUtil_initSeparatingDistance(btConvexSeparatingDistanceUtil* obj, const btScalar* separatingVector, btScalar separatingDistance, const btScalar* transA, const btScalar* transB);
void btConvexSeparatingDistanceUtil_updateSeparatingDistance(btConvexSeparatingDistanceUtil* obj, const btScalar* transA, const btScalar* transB);
void btConvexSeparatingDistanceUtil_delete(btConvexSeparatingDistanceUtil* obj);
btTriangle* btTriangle_new();
int btTriangle_getPartId(btTriangle* obj);
int btTriangle_getTriangleIndex(btTriangle* obj);
void btTriangle_getVertex0(btTriangle* obj, btScalar* value);
void btTriangle_getVertex1(btTriangle* obj, btScalar* value);
void btTriangle_getVertex2(btTriangle* obj, btScalar* value);
void btTriangle_setPartId(btTriangle* obj, int value);
void btTriangle_setTriangleIndex(btTriangle* obj, int value);
void btTriangle_setVertex0(btTriangle* obj, const btScalar* value);
void btTriangle_setVertex1(btTriangle* obj, const btScalar* value);
void btTriangle_setVertex2(btTriangle* obj, const btScalar* value);
void btTriangle_delete(btTriangle* obj);
btTriangleBuffer* btTriangleBuffer_new();
void btTriangleBuffer_clearBuffer(btTriangleBuffer* obj);
int btTriangleBuffer_getNumTriangles(btTriangleBuffer* obj);
const btTriangle* btTriangleBuffer_getTriangle(btTriangleBuffer* obj, int index);
btTriangleCallbackWrapper* btTriangleCallbackWrapper_new(pTriangleCallback_ProcessTriangle processTriangleCallback);
void btTriangleCallback_delete(btTriangleCallback* obj);
btInternalTriangleIndexCallbackWrapper* btInternalTriangleIndexCallbackWrapper_new(pInternalTriangleIndexCallback_InternalProcessTriangleIndex internalProcessTriangleIndexCallback);
void btInternalTriangleIndexCallback_delete(btInternalTriangleIndexCallback* obj);
btIndexedMesh* btIndexedMesh_new();
PHY_ScalarType btIndexedMesh_getIndexType(btIndexedMesh* obj);
int btIndexedMesh_getNumTriangles(btIndexedMesh* obj);
int btIndexedMesh_getNumVertices(btIndexedMesh* obj);
const unsigned char* btIndexedMesh_getTriangleIndexBase(btIndexedMesh* obj);
int btIndexedMesh_getTriangleIndexStride(btIndexedMesh* obj);
const unsigned char* btIndexedMesh_getVertexBase(btIndexedMesh* obj);
int btIndexedMesh_getVertexStride(btIndexedMesh* obj);
PHY_ScalarType btIndexedMesh_getVertexType(btIndexedMesh* obj);
void btIndexedMesh_setIndexType(btIndexedMesh* obj, PHY_ScalarType value);
void btIndexedMesh_setNumTriangles(btIndexedMesh* obj, int value);
void btIndexedMesh_setNumVertices(btIndexedMesh* obj, int value);
void btIndexedMesh_setTriangleIndexBase(btIndexedMesh* obj, const unsigned char* value);
void btIndexedMesh_setTriangleIndexStride(btIndexedMesh* obj, int value);
void btIndexedMesh_setVertexBase(btIndexedMesh* obj, const unsigned char* value);
void btIndexedMesh_setVertexStride(btIndexedMesh* obj, int value);
void btIndexedMesh_setVertexType(btIndexedMesh* obj, PHY_ScalarType value);
void btIndexedMesh_delete(btIndexedMesh* obj);
btTriangleIndexVertexArray* btTriangleIndexVertexArray_new();
btTriangleIndexVertexArray* btTriangleIndexVertexArray_new2(int numTriangles, int* triangleIndexBase, int triangleIndexStride, int numVertices, btScalar* vertexBase, int vertexStride);
void btTriangleIndexVertexArray_addIndexedMesh(btTriangleIndexVertexArray* obj, const btIndexedMesh* mesh);
void btTriangleIndexVertexArray_addIndexedMesh2(btTriangleIndexVertexArray* obj, const btIndexedMesh* mesh, PHY_ScalarType indexType);
IndexedMeshArray* btTriangleIndexVertexArray_getIndexedMeshArray(btTriangleIndexVertexArray* obj);
btMaterialProperties* btMaterialProperties_new();
const unsigned char* btMaterialProperties_getMaterialBase(btMaterialProperties* obj);
int btMaterialProperties_getMaterialStride(btMaterialProperties* obj);
PHY_ScalarType btMaterialProperties_getMaterialType(btMaterialProperties* obj);
int btMaterialProperties_getNumMaterials(btMaterialProperties* obj);
int btMaterialProperties_getNumTriangles(btMaterialProperties* obj);
const unsigned char* btMaterialProperties_getTriangleMaterialsBase(btMaterialProperties* obj);
int btMaterialProperties_getTriangleMaterialStride(btMaterialProperties* obj);
PHY_ScalarType btMaterialProperties_getTriangleType(btMaterialProperties* obj);
void btMaterialProperties_setMaterialBase(btMaterialProperties* obj, const unsigned char* value);
void btMaterialProperties_setMaterialStride(btMaterialProperties* obj, int value);
void btMaterialProperties_setMaterialType(btMaterialProperties* obj, PHY_ScalarType value);
void btMaterialProperties_setNumMaterials(btMaterialProperties* obj, int value);
void btMaterialProperties_setNumTriangles(btMaterialProperties* obj, int value);
void btMaterialProperties_setTriangleMaterialsBase(btMaterialProperties* obj, const unsigned char* value);
void btMaterialProperties_setTriangleMaterialStride(btMaterialProperties* obj, int value);
void btMaterialProperties_setTriangleType(btMaterialProperties* obj, PHY_ScalarType value);
void btMaterialProperties_delete(btMaterialProperties* obj);
btTriangleIndexVertexMaterialArray* btTriangleIndexVertexMaterialArray_new();
btTriangleIndexVertexMaterialArray* btTriangleIndexVertexMaterialArray_new2(int numTriangles, int* triangleIndexBase, int triangleIndexStride, int numVertices, btScalar* vertexBase, int vertexStride, int numMaterials, unsigned char* materialBase, int materialStride, int* triangleMaterialsBase, int materialIndexStride);
void btTriangleIndexVertexMaterialArray_addMaterialProperties(btTriangleIndexVertexMaterialArray* obj, const btMaterialProperties* mat);
void btTriangleIndexVertexMaterialArray_addMaterialProperties2(btTriangleIndexVertexMaterialArray* obj, const btMaterialProperties* mat, PHY_ScalarType triangleType);
void btTriangleIndexVertexMaterialArray_getLockedMaterialBase(btTriangleIndexVertexMaterialArray* obj, unsigned char** materialBase, int* numMaterials, PHY_ScalarType* materialType, int* materialStride, unsigned char** triangleMaterialBase, int* numTriangles, int* triangleMaterialStride, PHY_ScalarType* triangleType);
void btTriangleIndexVertexMaterialArray_getLockedMaterialBase2(btTriangleIndexVertexMaterialArray* obj, unsigned char** materialBase, int* numMaterials, PHY_ScalarType* materialType, int* materialStride, unsigned char** triangleMaterialBase, int* numTriangles, int* triangleMaterialStride, PHY_ScalarType* triangleType, int subpart);
void btTriangleIndexVertexMaterialArray_getLockedReadOnlyMaterialBase(btTriangleIndexVertexMaterialArray* obj, const unsigned char** materialBase, int* numMaterials, PHY_ScalarType* materialType, int* materialStride, const unsigned char** triangleMaterialBase, int* numTriangles, int* triangleMaterialStride, PHY_ScalarType* triangleType);
void btTriangleIndexVertexMaterialArray_getLockedReadOnlyMaterialBase2(btTriangleIndexVertexMaterialArray* obj, const unsigned char** materialBase, int* numMaterials, PHY_ScalarType* materialType, int* materialStride, const unsigned char** triangleMaterialBase, int* numTriangles, int* triangleMaterialStride, PHY_ScalarType* triangleType, int subpart);
btTriangleInfo* btTriangleInfo_new();
btScalar btTriangleInfo_getEdgeV0V1Angle(btTriangleInfo* obj);
btScalar btTriangleInfo_getEdgeV1V2Angle(btTriangleInfo* obj);
btScalar btTriangleInfo_getEdgeV2V0Angle(btTriangleInfo* obj);
int btTriangleInfo_getFlags(btTriangleInfo* obj);
void btTriangleInfo_setEdgeV0V1Angle(btTriangleInfo* obj, btScalar value);
void btTriangleInfo_setEdgeV1V2Angle(btTriangleInfo* obj, btScalar value);
void btTriangleInfo_setEdgeV2V0Angle(btTriangleInfo* obj, btScalar value);
void btTriangleInfo_setFlags(btTriangleInfo* obj, int value);
void btTriangleInfo_delete(btTriangleInfo* obj);
btTriangleInfoMap* btTriangleInfoMap_new();
int btTriangleInfoMap_calculateSerializeBufferSize(btTriangleInfoMap* obj);
void btTriangleInfoMap_deSerialize(btTriangleInfoMap* obj, btTriangleInfoMapData* data);
btScalar btTriangleInfoMap_getConvexEpsilon(btTriangleInfoMap* obj);
btScalar btTriangleInfoMap_getEdgeDistanceThreshold(btTriangleInfoMap* obj);
btScalar btTriangleInfoMap_getEqualVertexThreshold(btTriangleInfoMap* obj);
btScalar btTriangleInfoMap_getMaxEdgeAngleThreshold(btTriangleInfoMap* obj);
btScalar btTriangleInfoMap_getPlanarEpsilon(btTriangleInfoMap* obj);
btScalar btTriangleInfoMap_getZeroAreaThreshold(btTriangleInfoMap* obj);
const char* btTriangleInfoMap_serialize(btTriangleInfoMap* obj, void* dataBuffer, btSerializer* serializer);
void btTriangleInfoMap_setConvexEpsilon(btTriangleInfoMap* obj, btScalar value);
void btTriangleInfoMap_setEdgeDistanceThreshold(btTriangleInfoMap* obj, btScalar value);
void btTriangleInfoMap_setEqualVertexThreshold(btTriangleInfoMap* obj, btScalar value);
void btTriangleInfoMap_setMaxEdgeAngleThreshold(btTriangleInfoMap* obj, btScalar value);
void btTriangleInfoMap_setPlanarEpsilon(btTriangleInfoMap* obj, btScalar value);
void btTriangleInfoMap_setZeroAreaThreshold(btTriangleInfoMap* obj, btScalar value);
void btTriangleMeshShape_getLocalAabbMax(btTriangleMeshShape* obj, btScalar* value);
void btTriangleMeshShape_getLocalAabbMin(btTriangleMeshShape* obj, btScalar* value);
btStridingMeshInterface* btTriangleMeshShape_getMeshInterface(btTriangleMeshShape* obj);
void btTriangleMeshShape_localGetSupportingVertex(btTriangleMeshShape* obj, const btScalar* vec, btScalar* value);
void btTriangleMeshShape_localGetSupportingVertexWithoutMargin(btTriangleMeshShape* obj, const btScalar* vec, btScalar* value);
void btTriangleMeshShape_recalcLocalAabb(btTriangleMeshShape* obj);
btTriangleMesh* btTriangleMesh_new();
btTriangleMesh* btTriangleMesh_new2(bool use32bitIndices);
btTriangleMesh* btTriangleMesh_new3(bool use32bitIndices, bool use4componentVertices);
void btTriangleMesh_addIndex(btTriangleMesh* obj, int index);
void btTriangleMesh_addTriangle(btTriangleMesh* obj, const btScalar* vertex0, const btScalar* vertex1, const btScalar* vertex2);
void btTriangleMesh_addTriangle2(btTriangleMesh* obj, const btScalar* vertex0, const btScalar* vertex1, const btScalar* vertex2, bool removeDuplicateVertices);
int btTriangleMesh_findOrAddVertex(btTriangleMesh* obj, const btScalar* vertex, bool removeDuplicateVertices);
int btTriangleMesh_getNumTriangles(btTriangleMesh* obj);
bool btTriangleMesh_getUse32bitIndices(btTriangleMesh* obj);
bool btTriangleMesh_getUse4componentVertices(btTriangleMesh* obj);
btScalar btTriangleMesh_getWeldingThreshold(btTriangleMesh* obj);
void btTriangleMesh_setWeldingThreshold(btTriangleMesh* obj, btScalar value);
btTriangleShape* btTriangleShape_new();
btTriangleShape* btTriangleShape_new2(const btScalar* p0, const btScalar* p1, const btScalar* p2);
void btTriangleShape_calcNormal(btTriangleShape* obj, btScalar* normal);
void btTriangleShape_getPlaneEquation(btTriangleShape* obj, int i, btScalar* planeNormal, btScalar* planeSupport);
const btScalar* btTriangleShape_getVertexPtr(btTriangleShape* obj, int index);
btVector3* btTriangleShape_getVertices1(btTriangleShape* obj);
btJointFeedback* btJointFeedback_new();
void btJointFeedback_getAppliedForceBodyA(btJointFeedback* obj, btScalar* value);
void btJointFeedback_getAppliedForceBodyB(btJointFeedback* obj, btScalar* value);
void btJointFeedback_getAppliedTorqueBodyA(btJointFeedback* obj, btScalar* value);
void btJointFeedback_getAppliedTorqueBodyB(btJointFeedback* obj, btScalar* value);
void btJointFeedback_setAppliedForceBodyA(btJointFeedback* obj, const btScalar* value);
void btJointFeedback_setAppliedForceBodyB(btJointFeedback* obj, const btScalar* value);
void btJointFeedback_setAppliedTorqueBodyA(btJointFeedback* obj, const btScalar* value);
void btJointFeedback_setAppliedTorqueBodyB(btJointFeedback* obj, const btScalar* value);
void btJointFeedback_delete(btJointFeedback* obj);
btTypedConstraint_btConstraintInfo1* btTypedConstraint_btConstraintInfo1_new();
int btTypedConstraint_btConstraintInfo1_getNub(btTypedConstraint_btConstraintInfo1* obj);
int btTypedConstraint_btConstraintInfo1_getNumConstraintRows(btTypedConstraint_btConstraintInfo1* obj);
void btTypedConstraint_btConstraintInfo1_setNub(btTypedConstraint_btConstraintInfo1* obj, int value);
void btTypedConstraint_btConstraintInfo1_setNumConstraintRows(btTypedConstraint_btConstraintInfo1* obj, int value);
void btTypedConstraint_btConstraintInfo1_delete(btTypedConstraint_btConstraintInfo1* obj);
btTypedConstraint_btConstraintInfo2* btTypedConstraint_btConstraintInfo2_new();
btScalar* btTypedConstraint_btConstraintInfo2_getCfm(btTypedConstraint_btConstraintInfo2* obj);
btScalar* btTypedConstraint_btConstraintInfo2_getConstraintError(btTypedConstraint_btConstraintInfo2* obj);
btScalar btTypedConstraint_btConstraintInfo2_getDamping(btTypedConstraint_btConstraintInfo2* obj);
btScalar btTypedConstraint_btConstraintInfo2_getErp(btTypedConstraint_btConstraintInfo2* obj);
int* btTypedConstraint_btConstraintInfo2_getFindex(btTypedConstraint_btConstraintInfo2* obj);
btScalar btTypedConstraint_btConstraintInfo2_getFps(btTypedConstraint_btConstraintInfo2* obj);
btScalar* btTypedConstraint_btConstraintInfo2_getJ1angularAxis(btTypedConstraint_btConstraintInfo2* obj);
btScalar* btTypedConstraint_btConstraintInfo2_getJ1linearAxis(btTypedConstraint_btConstraintInfo2* obj);
btScalar* btTypedConstraint_btConstraintInfo2_getJ2angularAxis(btTypedConstraint_btConstraintInfo2* obj);
btScalar* btTypedConstraint_btConstraintInfo2_getJ2linearAxis(btTypedConstraint_btConstraintInfo2* obj);
btScalar* btTypedConstraint_btConstraintInfo2_getLowerLimit(btTypedConstraint_btConstraintInfo2* obj);
int btTypedConstraint_btConstraintInfo2_getNumIterations(btTypedConstraint_btConstraintInfo2* obj);
int btTypedConstraint_btConstraintInfo2_getRowskip(btTypedConstraint_btConstraintInfo2* obj);
btScalar* btTypedConstraint_btConstraintInfo2_getUpperLimit(btTypedConstraint_btConstraintInfo2* obj);
void btTypedConstraint_btConstraintInfo2_setCfm(btTypedConstraint_btConstraintInfo2* obj, btScalar* value);
void btTypedConstraint_btConstraintInfo2_setConstraintError(btTypedConstraint_btConstraintInfo2* obj, btScalar* value);
void btTypedConstraint_btConstraintInfo2_setDamping(btTypedConstraint_btConstraintInfo2* obj, btScalar value);
void btTypedConstraint_btConstraintInfo2_setErp(btTypedConstraint_btConstraintInfo2* obj, btScalar value);
void btTypedConstraint_btConstraintInfo2_setFindex(btTypedConstraint_btConstraintInfo2* obj, int* value);
void btTypedConstraint_btConstraintInfo2_setFps(btTypedConstraint_btConstraintInfo2* obj, btScalar value);
void btTypedConstraint_btConstraintInfo2_setJ1angularAxis(btTypedConstraint_btConstraintInfo2* obj, btScalar* value);
void btTypedConstraint_btConstraintInfo2_setJ1linearAxis(btTypedConstraint_btConstraintInfo2* obj, btScalar* value);
void btTypedConstraint_btConstraintInfo2_setJ2angularAxis(btTypedConstraint_btConstraintInfo2* obj, btScalar* value);
void btTypedConstraint_btConstraintInfo2_setJ2linearAxis(btTypedConstraint_btConstraintInfo2* obj, btScalar* value);
void btTypedConstraint_btConstraintInfo2_setLowerLimit(btTypedConstraint_btConstraintInfo2* obj, btScalar* value);
void btTypedConstraint_btConstraintInfo2_setNumIterations(btTypedConstraint_btConstraintInfo2* obj, int value);
void btTypedConstraint_btConstraintInfo2_setRowskip(btTypedConstraint_btConstraintInfo2* obj, int value);
void btTypedConstraint_btConstraintInfo2_setUpperLimit(btTypedConstraint_btConstraintInfo2* obj, btScalar* value);
void btTypedConstraint_btConstraintInfo2_delete(btTypedConstraint_btConstraintInfo2* obj);
void btTypedConstraint_buildJacobian(btTypedConstraint* obj);
int btTypedConstraint_calculateSerializeBufferSize(btTypedConstraint* obj);
void btTypedConstraint_enableFeedback(btTypedConstraint* obj, bool needsFeedback);
btScalar btTypedConstraint_getAppliedImpulse(btTypedConstraint* obj);
btScalar btTypedConstraint_getBreakingImpulseThreshold(btTypedConstraint* obj);
btTypedConstraintType btTypedConstraint_getConstraintType(btTypedConstraint* obj);
btScalar btTypedConstraint_getDbgDrawSize(btTypedConstraint* obj);
btRigidBody* btTypedConstraint_getFixedBody();
void btTypedConstraint_getInfo1(btTypedConstraint* obj, btTypedConstraint_btConstraintInfo1* info);
void btTypedConstraint_getInfo2(btTypedConstraint* obj, btTypedConstraint_btConstraintInfo2* info);
btJointFeedback* btTypedConstraint_getJointFeedback(btTypedConstraint* obj);
int btTypedConstraint_getOverrideNumSolverIterations(btTypedConstraint* obj);
btScalar btTypedConstraint_getParam(btTypedConstraint* obj, int num);
btScalar btTypedConstraint_getParam2(btTypedConstraint* obj, int num, int axis);
btRigidBody* btTypedConstraint_getRigidBodyA(btTypedConstraint* obj);
btRigidBody* btTypedConstraint_getRigidBodyB(btTypedConstraint* obj);
int btTypedConstraint_getUid(btTypedConstraint* obj);
int btTypedConstraint_getUserConstraintId(btTypedConstraint* obj);
void* btTypedConstraint_getUserConstraintPtr(btTypedConstraint* obj);
int btTypedConstraint_getUserConstraintType(btTypedConstraint* obj);
btScalar btTypedConstraint_internalGetAppliedImpulse(btTypedConstraint* obj);
void btTypedConstraint_internalSetAppliedImpulse(btTypedConstraint* obj, btScalar appliedImpulse);
bool btTypedConstraint_isEnabled(btTypedConstraint* obj);
bool btTypedConstraint_needsFeedback(btTypedConstraint* obj);
const char* btTypedConstraint_serialize(btTypedConstraint* obj, void* dataBuffer, btSerializer* serializer);
void btTypedConstraint_setBreakingImpulseThreshold(btTypedConstraint* obj, btScalar threshold);
void btTypedConstraint_setDbgDrawSize(btTypedConstraint* obj, btScalar dbgDrawSize);
void btTypedConstraint_setEnabled(btTypedConstraint* obj, bool enabled);
void btTypedConstraint_setJointFeedback(btTypedConstraint* obj, btJointFeedback* jointFeedback);
void btTypedConstraint_setOverrideNumSolverIterations(btTypedConstraint* obj, int overideNumIterations);
void btTypedConstraint_setParam(btTypedConstraint* obj, int num, btScalar value);
void btTypedConstraint_setParam2(btTypedConstraint* obj, int num, btScalar value, int axis);
void btTypedConstraint_setupSolverConstraint(btTypedConstraint* obj, btConstraintArray* ca, int solverBodyA, int solverBodyB, btScalar timeStep);
void btTypedConstraint_setUserConstraintId(btTypedConstraint* obj, int uid);
void btTypedConstraint_setUserConstraintPtr(btTypedConstraint* obj, void* ptr);
void btTypedConstraint_setUserConstraintType(btTypedConstraint* obj, int userConstraintType);
void btTypedConstraint_solveConstraintObsolete(btTypedConstraint* obj, btSolverBody* __unnamed0, btSolverBody* __unnamed1, btScalar __unnamed2);
void btTypedConstraint_delete(btTypedConstraint* obj);
btAngularLimit* btAngularLimit_new();
void btAngularLimit_fit(btAngularLimit* obj, btScalar* angle);
btScalar btAngularLimit_getBiasFactor(btAngularLimit* obj);
btScalar btAngularLimit_getCorrection(btAngularLimit* obj);
btScalar btAngularLimit_getError(btAngularLimit* obj);
btScalar btAngularLimit_getHalfRange(btAngularLimit* obj);
btScalar btAngularLimit_getHigh(btAngularLimit* obj);
btScalar btAngularLimit_getLow(btAngularLimit* obj);
btScalar btAngularLimit_getRelaxationFactor(btAngularLimit* obj);
btScalar btAngularLimit_getSign(btAngularLimit* obj);
btScalar btAngularLimit_getSoftness(btAngularLimit* obj);
bool btAngularLimit_isLimit(btAngularLimit* obj);
void btAngularLimit_set(btAngularLimit* obj, btScalar low, btScalar high);
void btAngularLimit_set2(btAngularLimit* obj, btScalar low, btScalar high, btScalar _softness);
void btAngularLimit_set3(btAngularLimit* obj, btScalar low, btScalar high, btScalar _softness, btScalar _biasFactor);
void btAngularLimit_set4(btAngularLimit* obj, btScalar low, btScalar high, btScalar _softness, btScalar _biasFactor, btScalar _relaxationFactor);
void btAngularLimit_test(btAngularLimit* obj, btScalar angle);
void btAngularLimit_delete(btAngularLimit* obj);
btUniformScalingShape* btUniformScalingShape_new(btConvexShape* convexChildShape, btScalar uniformScalingFactor);
btConvexShape* btUniformScalingShape_getChildShape(btUniformScalingShape* obj);
btScalar btUniformScalingShape_getUniformScalingFactor(btUniformScalingShape* obj);
btElement* btElement_new();
int btElement_getId(btElement* obj);
int btElement_getSz(btElement* obj);
void btElement_setId(btElement* obj, int value);
void btElement_setSz(btElement* obj, int value);
void btElement_delete(btElement* obj);
btUnionFind* btUnionFind_new();
void btUnionFind_allocate(btUnionFind* obj, int N);
int btUnionFind_find(btUnionFind* obj, int p, int q);
int btUnionFind_find2(btUnionFind* obj, int x);
void btUnionFind_Free(btUnionFind* obj);
btElement* btUnionFind_getElement(btUnionFind* obj, int index);
int btUnionFind_getNumElements(btUnionFind* obj);
bool btUnionFind_isRoot(btUnionFind* obj, int x);
void btUnionFind_reset(btUnionFind* obj, int N);
void btUnionFind_sortIslands(btUnionFind* obj);
void btUnionFind_unite(btUnionFind* obj, int p, int q);
void btUnionFind_delete(btUnionFind* obj);
btUniversalConstraint* btUniversalConstraint_new(btRigidBody* rbA, btRigidBody* rbB, const btScalar* anchor, const btScalar* axis1, const btScalar* axis2);
void btUniversalConstraint_getAnchor(btUniversalConstraint* obj, btScalar* value);
void btUniversalConstraint_getAnchor2(btUniversalConstraint* obj, btScalar* value);
btScalar btUniversalConstraint_getAngle1(btUniversalConstraint* obj);
btScalar btUniversalConstraint_getAngle2(btUniversalConstraint* obj);
void btUniversalConstraint_getAxis1(btUniversalConstraint* obj, btScalar* value);
void btUniversalConstraint_getAxis2(btUniversalConstraint* obj, btScalar* value);
void btUniversalConstraint_setLowerLimit(btUniversalConstraint* obj, btScalar ang1min, btScalar ang2min);
void btUniversalConstraint_setUpperLimit(btUniversalConstraint* obj, btScalar ang1max, btScalar ang2max);
btVehicleRaycaster_btVehicleRaycasterResult* btVehicleRaycaster_btVehicleRaycasterResult_new();
btScalar btVehicleRaycaster_btVehicleRaycasterResult_getDistFraction(btVehicleRaycaster_btVehicleRaycasterResult* obj);
void btVehicleRaycaster_btVehicleRaycasterResult_getHitNormalInWorld(btVehicleRaycaster_btVehicleRaycasterResult* obj, btScalar* value);
void btVehicleRaycaster_btVehicleRaycasterResult_getHitPointInWorld(btVehicleRaycaster_btVehicleRaycasterResult* obj, btScalar* value);
void btVehicleRaycaster_btVehicleRaycasterResult_setDistFraction(btVehicleRaycaster_btVehicleRaycasterResult* obj, btScalar value);
void btVehicleRaycaster_btVehicleRaycasterResult_setHitNormalInWorld(btVehicleRaycaster_btVehicleRaycasterResult* obj, const btScalar* value);
void btVehicleRaycaster_btVehicleRaycasterResult_setHitPointInWorld(btVehicleRaycaster_btVehicleRaycasterResult* obj, const btScalar* value);
void btVehicleRaycaster_btVehicleRaycasterResult_delete(btVehicleRaycaster_btVehicleRaycasterResult* obj);
void* btVehicleRaycaster_castRay(btVehicleRaycaster* obj, const btScalar* from, const btScalar* to, btVehicleRaycaster_btVehicleRaycasterResult* result);
void btVehicleRaycaster_delete(btVehicleRaycaster* obj);
btUsageBitfield* btUsageBitfield_new();
bool btUsageBitfield_getUnused1(btUsageBitfield* obj);
bool btUsageBitfield_getUnused2(btUsageBitfield* obj);
bool btUsageBitfield_getUnused3(btUsageBitfield* obj);
bool btUsageBitfield_getUnused4(btUsageBitfield* obj);
bool btUsageBitfield_getUsedVertexA(btUsageBitfield* obj);
bool btUsageBitfield_getUsedVertexB(btUsageBitfield* obj);
bool btUsageBitfield_getUsedVertexC(btUsageBitfield* obj);
bool btUsageBitfield_getUsedVertexD(btUsageBitfield* obj);
void btUsageBitfield_reset(btUsageBitfield* obj);
void btUsageBitfield_setUnused1(btUsageBitfield* obj, bool value);
void btUsageBitfield_setUnused2(btUsageBitfield* obj, bool value);
void btUsageBitfield_setUnused3(btUsageBitfield* obj, bool value);
void btUsageBitfield_setUnused4(btUsageBitfield* obj, bool value);
void btUsageBitfield_setUsedVertexA(btUsageBitfield* obj, bool value);
void btUsageBitfield_setUsedVertexB(btUsageBitfield* obj, bool value);
void btUsageBitfield_setUsedVertexC(btUsageBitfield* obj, bool value);
void btUsageBitfield_setUsedVertexD(btUsageBitfield* obj, bool value);
void btUsageBitfield_delete(btUsageBitfield* obj);
btSubSimplexClosestResult* btSubSimplexClosestResult_new();
btScalar* btSubSimplexClosestResult_getBarycentricCoords(btSubSimplexClosestResult* obj);
void btSubSimplexClosestResult_getClosestPointOnSimplex(btSubSimplexClosestResult* obj, btScalar* value);
bool btSubSimplexClosestResult_getDegenerate(btSubSimplexClosestResult* obj);
btUsageBitfield* btSubSimplexClosestResult_getUsedVertices(btSubSimplexClosestResult* obj);
bool btSubSimplexClosestResult_isValid(btSubSimplexClosestResult* obj);
void btSubSimplexClosestResult_reset(btSubSimplexClosestResult* obj);
void btSubSimplexClosestResult_setBarycentricCoordinates(btSubSimplexClosestResult* obj);
void btSubSimplexClosestResult_setBarycentricCoordinates2(btSubSimplexClosestResult* obj, btScalar a);
void btSubSimplexClosestResult_setBarycentricCoordinates3(btSubSimplexClosestResult* obj, btScalar a, btScalar b);
void btSubSimplexClosestResult_setBarycentricCoordinates4(btSubSimplexClosestResult* obj, btScalar a, btScalar b, btScalar c);
void btSubSimplexClosestResult_setBarycentricCoordinates5(btSubSimplexClosestResult* obj, btScalar a, btScalar b, btScalar c, btScalar d);
void btSubSimplexClosestResult_setClosestPointOnSimplex(btSubSimplexClosestResult* obj, const btScalar* value);
void btSubSimplexClosestResult_setDegenerate(btSubSimplexClosestResult* obj, bool value);
void btSubSimplexClosestResult_setUsedVertices(btSubSimplexClosestResult* obj, btUsageBitfield* value);
void btSubSimplexClosestResult_delete(btSubSimplexClosestResult* obj);
btVoronoiSimplexSolver* btVoronoiSimplexSolver_new();
void btVoronoiSimplexSolver_addVertex(btVoronoiSimplexSolver* obj, const btScalar* w, const btScalar* p, const btScalar* q);
void btVoronoiSimplexSolver_backup_closest(btVoronoiSimplexSolver* obj, btScalar* v);
bool btVoronoiSimplexSolver_closest(btVoronoiSimplexSolver* obj, btScalar* v);
bool btVoronoiSimplexSolver_closestPtPointTetrahedron(btVoronoiSimplexSolver* obj, const btScalar* p, const btScalar* a, const btScalar* b, const btScalar* c, const btScalar* d, btSubSimplexClosestResult* finalResult);
bool btVoronoiSimplexSolver_closestPtPointTriangle(btVoronoiSimplexSolver* obj, const btScalar* p, const btScalar* a, const btScalar* b, const btScalar* c, btSubSimplexClosestResult* result);
void btVoronoiSimplexSolver_compute_points(btVoronoiSimplexSolver* obj, btScalar* p1, btScalar* p2);
bool btVoronoiSimplexSolver_emptySimplex(btVoronoiSimplexSolver* obj);
bool btVoronoiSimplexSolver_fullSimplex(btVoronoiSimplexSolver* obj);
btSubSimplexClosestResult* btVoronoiSimplexSolver_getCachedBC(btVoronoiSimplexSolver* obj);
void btVoronoiSimplexSolver_getCachedP1(btVoronoiSimplexSolver* obj, btScalar* value);
void btVoronoiSimplexSolver_getCachedP2(btVoronoiSimplexSolver* obj, btScalar* value);
void btVoronoiSimplexSolver_getCachedV(btVoronoiSimplexSolver* obj, btScalar* value);
bool btVoronoiSimplexSolver_getCachedValidClosest(btVoronoiSimplexSolver* obj);
btScalar btVoronoiSimplexSolver_getEqualVertexThreshold(btVoronoiSimplexSolver* obj);
void btVoronoiSimplexSolver_getLastW(btVoronoiSimplexSolver* obj, btScalar* value);
bool btVoronoiSimplexSolver_getNeedsUpdate(btVoronoiSimplexSolver* obj);
int btVoronoiSimplexSolver_getNumVertices(btVoronoiSimplexSolver* obj);
int btVoronoiSimplexSolver_getSimplex(btVoronoiSimplexSolver* obj, btScalar* pBuf, btScalar* qBuf, btScalar* yBuf);
btVector3* btVoronoiSimplexSolver_getSimplexPointsP(btVoronoiSimplexSolver* obj);
btVector3* btVoronoiSimplexSolver_getSimplexPointsQ(btVoronoiSimplexSolver* obj);
btVector3* btVoronoiSimplexSolver_getSimplexVectorW(btVoronoiSimplexSolver* obj);
bool btVoronoiSimplexSolver_inSimplex(btVoronoiSimplexSolver* obj, const btScalar* w);
btScalar btVoronoiSimplexSolver_maxVertex(btVoronoiSimplexSolver* obj);
int btVoronoiSimplexSolver_numVertices(btVoronoiSimplexSolver* obj);
int btVoronoiSimplexSolver_pointOutsideOfPlane(btVoronoiSimplexSolver* obj, const btScalar* p, const btScalar* a, const btScalar* b, const btScalar* c, const btScalar* d);
void btVoronoiSimplexSolver_reduceVertices(btVoronoiSimplexSolver* obj, const btUsageBitfield* usedVerts);
void btVoronoiSimplexSolver_removeVertex(btVoronoiSimplexSolver* obj, int index);
void btVoronoiSimplexSolver_reset(btVoronoiSimplexSolver* obj);
void btVoronoiSimplexSolver_setCachedBC(btVoronoiSimplexSolver* obj, btSubSimplexClosestResult* value);
void btVoronoiSimplexSolver_setCachedP1(btVoronoiSimplexSolver* obj, const btScalar* value);
void btVoronoiSimplexSolver_setCachedP2(btVoronoiSimplexSolver* obj, const btScalar* value);
void btVoronoiSimplexSolver_setCachedV(btVoronoiSimplexSolver* obj, const btScalar* value);
void btVoronoiSimplexSolver_setCachedValidClosest(btVoronoiSimplexSolver* obj, bool value);
void btVoronoiSimplexSolver_setEqualVertexThreshold(btVoronoiSimplexSolver* obj, btScalar threshold);
void btVoronoiSimplexSolver_setLastW(btVoronoiSimplexSolver* obj, const btScalar* value);
void btVoronoiSimplexSolver_setNeedsUpdate(btVoronoiSimplexSolver* obj, bool value);
void btVoronoiSimplexSolver_setNumVertices(btVoronoiSimplexSolver* obj, int value);
bool btVoronoiSimplexSolver_updateClosestVectorAndPoints(btVoronoiSimplexSolver* obj);
void btVoronoiSimplexSolver_delete(btVoronoiSimplexSolver* obj);
btWheelInfoConstructionInfo* btWheelInfoConstructionInfo_new();
bool btWheelInfoConstructionInfo_getBIsFrontWheel(btWheelInfoConstructionInfo* obj);
void btWheelInfoConstructionInfo_getChassisConnectionCS(btWheelInfoConstructionInfo* obj, btScalar* value);
btScalar btWheelInfoConstructionInfo_getFrictionSlip(btWheelInfoConstructionInfo* obj);
btScalar btWheelInfoConstructionInfo_getMaxSuspensionForce(btWheelInfoConstructionInfo* obj);
btScalar btWheelInfoConstructionInfo_getMaxSuspensionTravelCm(btWheelInfoConstructionInfo* obj);
btScalar btWheelInfoConstructionInfo_getSuspensionRestLength(btWheelInfoConstructionInfo* obj);
btScalar btWheelInfoConstructionInfo_getSuspensionStiffness(btWheelInfoConstructionInfo* obj);
void btWheelInfoConstructionInfo_getWheelAxleCS(btWheelInfoConstructionInfo* obj, btScalar* value);
void btWheelInfoConstructionInfo_getWheelDirectionCS(btWheelInfoConstructionInfo* obj, btScalar* value);
btScalar btWheelInfoConstructionInfo_getWheelRadius(btWheelInfoConstructionInfo* obj);
btScalar btWheelInfoConstructionInfo_getWheelsDampingCompression(btWheelInfoConstructionInfo* obj);
btScalar btWheelInfoConstructionInfo_getWheelsDampingRelaxation(btWheelInfoConstructionInfo* obj);
void btWheelInfoConstructionInfo_setBIsFrontWheel(btWheelInfoConstructionInfo* obj, bool value);
void btWheelInfoConstructionInfo_setChassisConnectionCS(btWheelInfoConstructionInfo* obj, const btScalar* value);
void btWheelInfoConstructionInfo_setFrictionSlip(btWheelInfoConstructionInfo* obj, btScalar value);
void btWheelInfoConstructionInfo_setMaxSuspensionForce(btWheelInfoConstructionInfo* obj, btScalar value);
void btWheelInfoConstructionInfo_setMaxSuspensionTravelCm(btWheelInfoConstructionInfo* obj, btScalar value);
void btWheelInfoConstructionInfo_setSuspensionRestLength(btWheelInfoConstructionInfo* obj, btScalar value);
void btWheelInfoConstructionInfo_setSuspensionStiffness(btWheelInfoConstructionInfo* obj, btScalar value);
void btWheelInfoConstructionInfo_setWheelAxleCS(btWheelInfoConstructionInfo* obj, const btScalar* value);
void btWheelInfoConstructionInfo_setWheelDirectionCS(btWheelInfoConstructionInfo* obj, const btScalar* value);
void btWheelInfoConstructionInfo_setWheelRadius(btWheelInfoConstructionInfo* obj, btScalar value);
void btWheelInfoConstructionInfo_setWheelsDampingCompression(btWheelInfoConstructionInfo* obj, btScalar value);
void btWheelInfoConstructionInfo_setWheelsDampingRelaxation(btWheelInfoConstructionInfo* obj, btScalar value);
void btWheelInfoConstructionInfo_delete(btWheelInfoConstructionInfo* obj);
btWheelInfo_RaycastInfo* btWheelInfo_RaycastInfo_new();
void btWheelInfo_RaycastInfo_getContactNormalWS(btWheelInfo_RaycastInfo* obj, btScalar* value);
void btWheelInfo_RaycastInfo_getContactPointWS(btWheelInfo_RaycastInfo* obj, btScalar* value);
void* btWheelInfo_RaycastInfo_getGroundObject(btWheelInfo_RaycastInfo* obj);
void btWheelInfo_RaycastInfo_getHardPointWS(btWheelInfo_RaycastInfo* obj, btScalar* value);
bool btWheelInfo_RaycastInfo_getIsInContact(btWheelInfo_RaycastInfo* obj);
btScalar btWheelInfo_RaycastInfo_getSuspensionLength(btWheelInfo_RaycastInfo* obj);
void btWheelInfo_RaycastInfo_getWheelAxleWS(btWheelInfo_RaycastInfo* obj, btScalar* value);
void btWheelInfo_RaycastInfo_getWheelDirectionWS(btWheelInfo_RaycastInfo* obj, btScalar* value);
void btWheelInfo_RaycastInfo_setContactNormalWS(btWheelInfo_RaycastInfo* obj, const btScalar* value);
void btWheelInfo_RaycastInfo_setContactPointWS(btWheelInfo_RaycastInfo* obj, const btScalar* value);
void btWheelInfo_RaycastInfo_setGroundObject(btWheelInfo_RaycastInfo* obj, void* value);
void btWheelInfo_RaycastInfo_setHardPointWS(btWheelInfo_RaycastInfo* obj, const btScalar* value);
void btWheelInfo_RaycastInfo_setIsInContact(btWheelInfo_RaycastInfo* obj, bool value);
void btWheelInfo_RaycastInfo_setSuspensionLength(btWheelInfo_RaycastInfo* obj, btScalar value);
void btWheelInfo_RaycastInfo_setWheelAxleWS(btWheelInfo_RaycastInfo* obj, const btScalar* value);
void btWheelInfo_RaycastInfo_setWheelDirectionWS(btWheelInfo_RaycastInfo* obj, const btScalar* value);
void btWheelInfo_RaycastInfo_delete(btWheelInfo_RaycastInfo* obj);
btWheelInfo* btWheelInfo_new(btWheelInfoConstructionInfo* ci);
bool btWheelInfo_getBIsFrontWheel(btWheelInfo* obj);
btScalar btWheelInfo_getBrake(btWheelInfo* obj);
void btWheelInfo_getChassisConnectionPointCS(btWheelInfo* obj, btScalar* value);
void* btWheelInfo_getClientInfo(btWheelInfo* obj);
btScalar btWheelInfo_getClippedInvContactDotSuspension(btWheelInfo* obj);
btScalar btWheelInfo_getDeltaRotation(btWheelInfo* obj);
btScalar btWheelInfo_getEngineForce(btWheelInfo* obj);
btScalar btWheelInfo_getFrictionSlip(btWheelInfo* obj);
btScalar btWheelInfo_getMaxSuspensionForce(btWheelInfo* obj);
btScalar btWheelInfo_getMaxSuspensionTravelCm(btWheelInfo* obj);
btWheelInfo_RaycastInfo* btWheelInfo_getRaycastInfo(btWheelInfo* obj);
btScalar btWheelInfo_getRollInfluence(btWheelInfo* obj);
btScalar btWheelInfo_getRotation(btWheelInfo* obj);
btScalar btWheelInfo_getSkidInfo(btWheelInfo* obj);
btScalar btWheelInfo_getSteering(btWheelInfo* obj);
btScalar btWheelInfo_getSuspensionRelativeVelocity(btWheelInfo* obj);
btScalar btWheelInfo_getSuspensionRestLength(btWheelInfo* obj);
btScalar btWheelInfo_getSuspensionRestLength1(btWheelInfo* obj);
btScalar btWheelInfo_getSuspensionStiffness(btWheelInfo* obj);
void btWheelInfo_getWheelAxleCS(btWheelInfo* obj, btScalar* value);
void btWheelInfo_getWheelDirectionCS(btWheelInfo* obj, btScalar* value);
btScalar btWheelInfo_getWheelsDampingCompression(btWheelInfo* obj);
btScalar btWheelInfo_getWheelsDampingRelaxation(btWheelInfo* obj);
btScalar btWheelInfo_getWheelsRadius(btWheelInfo* obj);
btScalar btWheelInfo_getWheelsSuspensionForce(btWheelInfo* obj);
void btWheelInfo_getWorldTransform(btWheelInfo* obj, btScalar* value);
void btWheelInfo_setBIsFrontWheel(btWheelInfo* obj, bool value);
void btWheelInfo_setBrake(btWheelInfo* obj, btScalar value);
void btWheelInfo_setChassisConnectionPointCS(btWheelInfo* obj, const btScalar* value);
void btWheelInfo_setClientInfo(btWheelInfo* obj, void* value);
void btWheelInfo_setClippedInvContactDotSuspension(btWheelInfo* obj, btScalar value);
void btWheelInfo_setDeltaRotation(btWheelInfo* obj, btScalar value);
void btWheelInfo_setEngineForce(btWheelInfo* obj, btScalar value);
void btWheelInfo_setFrictionSlip(btWheelInfo* obj, btScalar value);
void btWheelInfo_setMaxSuspensionForce(btWheelInfo* obj, btScalar value);
void btWheelInfo_setMaxSuspensionTravelCm(btWheelInfo* obj, btScalar value);
void btWheelInfo_setRollInfluence(btWheelInfo* obj, btScalar value);
void btWheelInfo_setRotation(btWheelInfo* obj, btScalar value);
void btWheelInfo_setSkidInfo(btWheelInfo* obj, btScalar value);
void btWheelInfo_setSteering(btWheelInfo* obj, btScalar value);
void btWheelInfo_setSuspensionRelativeVelocity(btWheelInfo* obj, btScalar value);
void btWheelInfo_setSuspensionRestLength1(btWheelInfo* obj, btScalar value);
void btWheelInfo_setSuspensionStiffness(btWheelInfo* obj, btScalar value);
void btWheelInfo_setWheelAxleCS(btWheelInfo* obj, const btScalar* value);
void btWheelInfo_setWheelDirectionCS(btWheelInfo* obj, const btScalar* value);
void btWheelInfo_setWheelsDampingCompression(btWheelInfo* obj, btScalar value);
void btWheelInfo_setWheelsDampingRelaxation(btWheelInfo* obj, btScalar value);
void btWheelInfo_setWheelsRadius(btWheelInfo* obj, btScalar value);
void btWheelInfo_setWheelsSuspensionForce(btWheelInfo* obj, btScalar value);
void btWheelInfo_setWorldTransform(btWheelInfo* obj, const btScalar* value);
void btWheelInfo_updateWheel(btWheelInfo* obj, const btRigidBody* chassis, btWheelInfo_RaycastInfo* raycastInfo);
void btWheelInfo_delete(btWheelInfo* obj);
btWorldImporter* btWorldImporter_new(btDynamicsWorld* world);
btCollisionShape* btWorldImporter_createBoxShape(btWorldImporter* obj, const btScalar* halfExtents);
btBvhTriangleMeshShape* btWorldImporter_createBvhTriangleMeshShape(btWorldImporter* obj, btStridingMeshInterface* trimesh, btOptimizedBvh* bvh);
btCollisionShape* btWorldImporter_createCapsuleShapeZ(btWorldImporter* obj, btScalar radius, btScalar height);
btCollisionShape* btWorldImporter_createCapsuleShapeX(btWorldImporter* obj, btScalar radius, btScalar height);
btCollisionShape* btWorldImporter_createCapsuleShapeY(btWorldImporter* obj, btScalar radius, btScalar height);
btCollisionObject* btWorldImporter_createCollisionObject(btWorldImporter* obj, const btScalar* startTransform, btCollisionShape* shape, const char* bodyName);
btCompoundShape* btWorldImporter_createCompoundShape(btWorldImporter* obj);
btCollisionShape* btWorldImporter_createConeShapeZ(btWorldImporter* obj, btScalar radius, btScalar height);
btCollisionShape* btWorldImporter_createConeShapeX(btWorldImporter* obj, btScalar radius, btScalar height);
btCollisionShape* btWorldImporter_createConeShapeY(btWorldImporter* obj, btScalar radius, btScalar height);
btConeTwistConstraint* btWorldImporter_createConeTwistConstraint(btWorldImporter* obj, btRigidBody* rbA, btRigidBody* rbB, const btScalar* rbAFrame, const btScalar* rbBFrame);
btConeTwistConstraint* btWorldImporter_createConeTwistConstraint2(btWorldImporter* obj, btRigidBody* rbA, const btScalar* rbAFrame);
btConvexHullShape* btWorldImporter_createConvexHullShape(btWorldImporter* obj);
btCollisionShape* btWorldImporter_createConvexTriangleMeshShape(btWorldImporter* obj, btStridingMeshInterface* trimesh);
btCollisionShape* btWorldImporter_createCylinderShapeZ(btWorldImporter* obj, btScalar radius, btScalar height);
btCollisionShape* btWorldImporter_createCylinderShapeX(btWorldImporter* obj, btScalar radius, btScalar height);
btCollisionShape* btWorldImporter_createCylinderShapeY(btWorldImporter* obj, btScalar radius, btScalar height);
btGearConstraint* btWorldImporter_createGearConstraint(btWorldImporter* obj, btRigidBody* rbA, btRigidBody* rbB, const btScalar* axisInA, const btScalar* axisInB, btScalar ratio);
btGeneric6DofConstraint* btWorldImporter_createGeneric6DofConstraint(btWorldImporter* obj, btRigidBody* rbA, btRigidBody* rbB, const btScalar* frameInA, const btScalar* frameInB, bool useLinearReferenceFrameA);
btGeneric6DofConstraint* btWorldImporter_createGeneric6DofConstraint2(btWorldImporter* obj, btRigidBody* rbB, const btScalar* frameInB, bool useLinearReferenceFrameB);
btGeneric6DofSpringConstraint* btWorldImporter_createGeneric6DofSpringConstraint(btWorldImporter* obj, btRigidBody* rbA, btRigidBody* rbB, const btScalar* frameInA, const btScalar* frameInB, bool useLinearReferenceFrameA);
btGeneric6DofSpring2Constraint* btWorldImporter_createGeneric6DofSpring2Constraint(btWorldImporter* obj, btRigidBody* rbA, btRigidBody* rbB, const btScalar* frameInA, const btScalar* frameInB, int rotateOrder);
btGImpactMeshShape* btWorldImporter_createGimpactShape(btWorldImporter* obj, btStridingMeshInterface* trimesh);
btHingeConstraint* btWorldImporter_createHingeConstraint(btWorldImporter* obj, btRigidBody* rbA, btRigidBody* rbB, const btScalar* rbAFrame, const btScalar* rbBFrame);
btHingeConstraint* btWorldImporter_createHingeConstraint2(btWorldImporter* obj, btRigidBody* rbA, btRigidBody* rbB, const btScalar* rbAFrame, const btScalar* rbBFrame, bool useReferenceFrameA);
btHingeConstraint* btWorldImporter_createHingeConstraint3(btWorldImporter* obj, btRigidBody* rbA, const btScalar* rbAFrame);
btHingeConstraint* btWorldImporter_createHingeConstraint4(btWorldImporter* obj, btRigidBody* rbA, const btScalar* rbAFrame, bool useReferenceFrameA);
btTriangleIndexVertexArray* btWorldImporter_createMeshInterface(btWorldImporter* obj, btStridingMeshInterfaceData* meshData);
btMultiSphereShape* btWorldImporter_createMultiSphereShape(btWorldImporter* obj, const btScalar* positions, const btScalar* radi, int numSpheres);
btOptimizedBvh* btWorldImporter_createOptimizedBvh(btWorldImporter* obj);
btCollisionShape* btWorldImporter_createPlaneShape(btWorldImporter* obj, const btScalar* planeNormal, btScalar planeConstant);
btPoint2PointConstraint* btWorldImporter_createPoint2PointConstraint(btWorldImporter* obj, btRigidBody* rbA, const btScalar* pivotInA);
btPoint2PointConstraint* btWorldImporter_createPoint2PointConstraint2(btWorldImporter* obj, btRigidBody* rbA, btRigidBody* rbB, const btScalar* pivotInA, const btScalar* pivotInB);
btRigidBody* btWorldImporter_createRigidBody(btWorldImporter* obj, bool isDynamic, btScalar mass, const btScalar* startTransform, btCollisionShape* shape, const char* bodyName);
btScaledBvhTriangleMeshShape* btWorldImporter_createScaledTrangleMeshShape(btWorldImporter* obj, btBvhTriangleMeshShape* meshShape, const btScalar* localScalingbtBvhTriangleMeshShape);
btSliderConstraint* btWorldImporter_createSliderConstraint(btWorldImporter* obj, btRigidBody* rbA, btRigidBody* rbB, const btScalar* frameInA, const btScalar* frameInB, bool useLinearReferenceFrameA);
btSliderConstraint* btWorldImporter_createSliderConstraint2(btWorldImporter* obj, btRigidBody* rbB, const btScalar* frameInB, bool useLinearReferenceFrameA);
btCollisionShape* btWorldImporter_createSphereShape(btWorldImporter* obj, btScalar radius);
btStridingMeshInterfaceData* btWorldImporter_createStridingMeshInterfaceData(btWorldImporter* obj, btStridingMeshInterfaceData* interfaceData);
btTriangleInfoMap* btWorldImporter_createTriangleInfoMap(btWorldImporter* obj);
btTriangleIndexVertexArray* btWorldImporter_createTriangleMeshContainer(btWorldImporter* obj);
void btWorldImporter_deleteAllData(btWorldImporter* obj);
btOptimizedBvh* btWorldImporter_getBvhByIndex(btWorldImporter* obj, int index);
btCollisionShape* btWorldImporter_getCollisionShapeByIndex(btWorldImporter* obj, int index);
btCollisionShape* btWorldImporter_getCollisionShapeByName(btWorldImporter* obj, const char* name);
btTypedConstraint* btWorldImporter_getConstraintByIndex(btWorldImporter* obj, int index);
btTypedConstraint* btWorldImporter_getConstraintByName(btWorldImporter* obj, const char* name);
const char* btWorldImporter_getNameForPointer(btWorldImporter* obj, const void* ptr);
int btWorldImporter_getNumBvhs(btWorldImporter* obj);
int btWorldImporter_getNumCollisionShapes(btWorldImporter* obj);
int btWorldImporter_getNumConstraints(btWorldImporter* obj);
int btWorldImporter_getNumRigidBodies(btWorldImporter* obj);
int btWorldImporter_getNumTriangleInfoMaps(btWorldImporter* obj);
btCollisionObject* btWorldImporter_getRigidBodyByIndex(btWorldImporter* obj, int index);
btRigidBody* btWorldImporter_getRigidBodyByName(btWorldImporter* obj, const char* name);
btTriangleInfoMap* btWorldImporter_getTriangleInfoMapByIndex(btWorldImporter* obj, int index);
int btWorldImporter_getVerboseMode(btWorldImporter* obj);
void btWorldImporter_setDynamicsWorldInfo(btWorldImporter* obj, const btScalar* gravity, const btContactSolverInfo* solverInfo);
void btWorldImporter_setVerboseMode(btWorldImporter* obj, int verboseMode);
void btWorldImporter_delete(btWorldImporter* obj);
btCompoundShapeChild* btCompoundShapeChild_array_at(btCompoundShapeChild* a, int n);
btSoftBody_Node* btSoftBodyNodePtrArray_at(btSoftBodyNodePtrArray* obj, int n);
void btSoftBodyNodePtrArray_set(btSoftBodyNodePtrArray* obj, btSoftBody_Node* value, int index);
void btVector3_array_at(const btVector3* a, int n, btScalar* value);
void btVector3_array_set(btVector3* obj, int n, const btScalar* value);
btAlignedVector3Array* btAlignedVector3Array_new();
void btAlignedVector3Array_at(btAlignedVector3Array* obj, int n, btScalar* value);
void btAlignedVector3Array_push_back(btAlignedVector3Array* obj, const btScalar* value);
void btAlignedVector3Array_push_back2(btAlignedVector3Array* obj, const btScalar* value);
void btAlignedVector3Array_set(btAlignedVector3Array* obj, int n, const btScalar* value);
int btAlignedVector3Array_size(btAlignedVector3Array* obj);
void btAlignedVector3Array_delete(btAlignedVector3Array* obj);
HACD_HACD* HACD_new();
bool HACD_Compute(HACD_HACD* obj);
bool HACD_Compute2(HACD_HACD* obj, bool fullCH);
bool HACD_Compute3(HACD_HACD* obj, bool fullCH, bool exportDistPoints);
void HACD_DenormalizeData(HACD_HACD* obj);
bool HACD_GetAddExtraDistPoints(HACD_HACD* obj);
bool HACD_GetAddFacesPoints(HACD_HACD* obj);
bool HACD_GetAddNeighboursDistPoints(HACD_HACD* obj);
const HACD_CallBackFunction HACD_GetCallBack(HACD_HACD* obj);
bool HACD_GetCH(HACD_HACD* obj, int numCH, HACD_Vec3_Real* points, HACD_Vec3_long* triangles);
double HACD_GetCompacityWeight(HACD_HACD* obj);
double HACD_GetConcavity(HACD_HACD* obj);
double HACD_GetConnectDist(HACD_HACD* obj);
size_t HACD_GetNClusters(HACD_HACD* obj);
size_t HACD_GetNPoints(HACD_HACD* obj);
size_t HACD_GetNPointsCH(HACD_HACD* obj, int numCH);
size_t HACD_GetNTriangles(HACD_HACD* obj);
size_t HACD_GetNTrianglesCH(HACD_HACD* obj, int numCH);
size_t HACD_GetNVerticesPerCH(HACD_HACD* obj);
const long* HACD_GetPartition(HACD_HACD* obj);
const HACD_Vec3_Real* HACD_GetPoints(HACD_HACD* obj);
double HACD_GetScaleFactor(HACD_HACD* obj);
const HACD_Vec3_long* HACD_GetTriangles(HACD_HACD* obj);
double HACD_GetVolumeWeight(HACD_HACD* obj);
void HACD_NormalizeData(HACD_HACD* obj);
bool HACD_Save(HACD_HACD* obj, const char* fileName, bool uniColor);
bool HACD_Save2(HACD_HACD* obj, const char* fileName, bool uniColor, long numCluster);
void HACD_SetAddExtraDistPoints(HACD_HACD* obj, bool addExtraDistPoints);
void HACD_SetAddFacesPoints(HACD_HACD* obj, bool addFacesPoints);
void HACD_SetAddNeighboursDistPoints(HACD_HACD* obj, bool addNeighboursDistPoints);
void HACD_SetCallBack(HACD_HACD* obj, HACD_CallBackFunction callBack);
void HACD_SetCompacityWeight(HACD_HACD* obj, double alpha);
void HACD_SetConcavity(HACD_HACD* obj, double concavity);
void HACD_SetConnectDist(HACD_HACD* obj, double ccConnectDist);
void HACD_SetNClusters(HACD_HACD* obj, int nClusters);
void HACD_SetNPoints(HACD_HACD* obj, int nPoints);
void HACD_SetNTriangles(HACD_HACD* obj, int nTriangles);
void HACD_SetNVerticesPerCH(HACD_HACD* obj, int nVerticesPerCH);
void HACD_SetPoints(HACD_HACD* obj, HACD_Vec3_Real* points);
void HACD_SetScaleFactor(HACD_HACD* obj, double scale);
void HACD_SetTriangles(HACD_HACD* obj, HACD_Vec3_long* triangles);
void HACD_SetVolumeWeight(HACD_HACD* obj, double beta);
void HACD_delete(HACD_HACD* obj);
]])
local lib = ffi.load('libbulletc')
local bullet = {}
do -- GImpactMeshShapePart
	local META = {}
	META.__index = META
	function META:GetPart(...)
		lib.btGImpactMeshShapePart_getPart(self.__ptr, ...)
	end
	function META:GetVertexCount(...)
		lib.btGImpactMeshShapePart_getVertexCount(self.__ptr, ...)
	end
	function META:GetVertex(...)
		lib.btGImpactMeshShapePart_getVertex(self.__ptr, ...)
	end
	function META:GetTrimeshPrimitiveManager(...)
		lib.btGImpactMeshShapePart_getTrimeshPrimitiveManager(self.__ptr, ...)
	end
	function bullet.CreateGImpactMeshShapePart(...)
		return setmetatable({__ptr = lib.btGImpactMeshShapePart_new2(...)}, META)
	end
end
do -- ContinuousConvexCollision
	local META = {}
	META.__index = META
	function bullet.CreateContinuousConvexCollision(...)
		return setmetatable({__ptr = lib.btContinuousConvexCollision_new2(...)}, META)
	end
end
do -- TriangleIndexVertexMaterialArray
	local META = {}
	META.__index = META
	function META:AddMaterialProperties(...)
		lib.btTriangleIndexVertexMaterialArray_addMaterialProperties(self.__ptr, ...)
	end
	function META:GetLockedReadOnlyMaterialBase(...)
		lib.btTriangleIndexVertexMaterialArray_getLockedReadOnlyMaterialBase(self.__ptr, ...)
	end
	function META:GetLockedMaterialBase(...)
		lib.btTriangleIndexVertexMaterialArray_getLockedMaterialBase(self.__ptr, ...)
	end
	function bullet.CreateTriangleIndexVertexMaterialArray(...)
		return setmetatable({__ptr = lib.btTriangleIndexVertexMaterialArray_new2(...)}, META)
	end
end
do -- BulletFile
	local META = {}
	META.__index = META
	function META:GetBvhs(...)
		lib.btBulletFile_getBvhs(self.__ptr, ...)
	end
	function META:GetRigidBodies(...)
		lib.btBulletFile_getRigidBodies(self.__ptr, ...)
	end
	function META:GetDataBlocks(...)
		lib.btBulletFile_getDataBlocks(self.__ptr, ...)
	end
	function META:GetCollisionObjects(...)
		lib.btBulletFile_getCollisionObjects(self.__ptr, ...)
	end
	function META:GetConstraints(...)
		lib.btBulletFile_getConstraints(self.__ptr, ...)
	end
	function META:GetDynamicsWorldInfo(...)
		lib.btBulletFile_getDynamicsWorldInfo(self.__ptr, ...)
	end
	function META:GetCollisionShapes(...)
		lib.btBulletFile_getCollisionShapes(self.__ptr, ...)
	end
	function META:GetSoftBodies(...)
		lib.btBulletFile_getSoftBodies(self.__ptr, ...)
	end
	function META:GetTriangleInfoMaps(...)
		lib.btBulletFile_getTriangleInfoMaps(self.__ptr, ...)
	end
	function META:ParseData(...)
		lib.btBulletFile_parseData(self.__ptr, ...)
	end
	function META:AddStruct(...)
		lib.btBulletFile_addStruct(self.__ptr, ...)
	end
	function bullet.CreateBulletFile(...)
		return setmetatable({__ptr = lib.btBulletFile_new2(...)}, META)
	end
end
do -- ConeTwistConstraint
	local META = {}
	META.__index = META
	function META:GetInfo2NonVirtual(...)
		lib.btConeTwistConstraint_getInfo2NonVirtual(self.__ptr, ...)
	end
	function META:SetDamping(...)
		lib.btConeTwistConstraint_setDamping(self.__ptr, ...)
	end
	function META:GetFrameOffsetA(...)
		lib.btConeTwistConstraint_getFrameOffsetA(self.__ptr, ...)
	end
	function META:GetSwingSpan(...)
		lib.btConeTwistConstraint_getSwingSpan1(self.__ptr, ...)
	end
	function META:GetInfo1NonVirtual(...)
		lib.btConeTwistConstraint_getInfo1NonVirtual(self.__ptr, ...)
	end
	function META:SetLimit(...)
		lib.btConeTwistConstraint_setLimit(self.__ptr, ...)
	end
	function META:GetFixThresh(...)
		lib.btConeTwistConstraint_getFixThresh(self.__ptr, ...)
	end
	function META:UpdateRHS(...)
		lib.btConeTwistConstraint_updateRHS(self.__ptr, ...)
	end
	function META:GetSolveTwistLimit(...)
		lib.btConeTwistConstraint_getSolveTwistLimit(self.__ptr, ...)
	end
	function META:GetTwistAngle(...)
		lib.btConeTwistConstraint_getTwistAngle(self.__ptr, ...)
	end
	function META:SetMotorTargetInConstraintSpace(...)
		lib.btConeTwistConstraint_setMotorTargetInConstraintSpace(self.__ptr, ...)
	end
	function META:GetPointForAngle(...)
		lib.btConeTwistConstraint_GetPointForAngle(self.__ptr, ...)
	end
	function META:GetFrameOffsetB(...)
		lib.btConeTwistConstraint_getFrameOffsetB(self.__ptr, ...)
	end
	function META:GetTwistLimitSign(...)
		lib.btConeTwistConstraint_getTwistLimitSign(self.__ptr, ...)
	end
	function META:SetMaxMotorImpulseNormalized(...)
		lib.btConeTwistConstraint_setMaxMotorImpulseNormalized(self.__ptr, ...)
	end
	function META:SetMaxMotorImpulse(...)
		lib.btConeTwistConstraint_setMaxMotorImpulse(self.__ptr, ...)
	end
	function META:SetAngularOnly(...)
		lib.btConeTwistConstraint_setAngularOnly(self.__ptr, ...)
	end
	function META:SetFrames(...)
		lib.btConeTwistConstraint_setFrames(self.__ptr, ...)
	end
	function META:SetFixThresh(...)
		lib.btConeTwistConstraint_setFixThresh(self.__ptr, ...)
	end
	function META:EnableMotor(...)
		lib.btConeTwistConstraint_enableMotor(self.__ptr, ...)
	end
	function META:IsPastSwingLimit(...)
		lib.btConeTwistConstraint_isPastSwingLimit(self.__ptr, ...)
	end
	function META:GetTwistSpan(...)
		lib.btConeTwistConstraint_getTwistSpan(self.__ptr, ...)
	end
	function META:GetBFrame(...)
		lib.btConeTwistConstraint_getBFrame(self.__ptr, ...)
	end
	function META:GetSolveSwingLimit(...)
		lib.btConeTwistConstraint_getSolveSwingLimit(self.__ptr, ...)
	end
	function META:CalcAngleInfo(...)
		lib.btConeTwistConstraint_calcAngleInfo(self.__ptr, ...)
	end
	function META:GetAFrame(...)
		lib.btConeTwistConstraint_getAFrame(self.__ptr, ...)
	end
	function META:SetMotorTarget(...)
		lib.btConeTwistConstraint_setMotorTarget(self.__ptr, ...)
	end
	function bullet.CreateConeTwistConstraint(...)
		return setmetatable({__ptr = lib.btConeTwistConstraint_new2(...)}, META)
	end
end
do -- BvhTriangleMeshShape
	local META = {}
	META.__index = META
	function META:GetTriangleInfoMap(...)
		lib.btBvhTriangleMeshShape_getTriangleInfoMap(self.__ptr, ...)
	end
	function META:PerformRaycast(...)
		lib.btBvhTriangleMeshShape_performRaycast(self.__ptr, ...)
	end
	function META:UsesQuantizedAabbCompression(...)
		lib.btBvhTriangleMeshShape_usesQuantizedAabbCompression(self.__ptr, ...)
	end
	function META:RefitTree(...)
		lib.btBvhTriangleMeshShape_refitTree(self.__ptr, ...)
	end
	function META:PerformConvexcast(...)
		lib.btBvhTriangleMeshShape_performConvexcast(self.__ptr, ...)
	end
	function META:SerializeSingleTriangleInfoMap(...)
		lib.btBvhTriangleMeshShape_serializeSingleTriangleInfoMap(self.__ptr, ...)
	end
	function META:PartialRefitTree(...)
		lib.btBvhTriangleMeshShape_partialRefitTree(self.__ptr, ...)
	end
	function META:SetOptimizedBvh(...)
		lib.btBvhTriangleMeshShape_setOptimizedBvh(self.__ptr, ...)
	end
	function META:GetOptimizedBvh(...)
		lib.btBvhTriangleMeshShape_getOptimizedBvh(self.__ptr, ...)
	end
	function META:SetTriangleInfoMap(...)
		lib.btBvhTriangleMeshShape_setTriangleInfoMap(self.__ptr, ...)
	end
	function META:SerializeSingleBvh(...)
		lib.btBvhTriangleMeshShape_serializeSingleBvh(self.__ptr, ...)
	end
	function META:GetOwnsBvh(...)
		lib.btBvhTriangleMeshShape_getOwnsBvh(self.__ptr, ...)
	end
	function META:BuildOptimizedBvh(...)
		lib.btBvhTriangleMeshShape_buildOptimizedBvh(self.__ptr, ...)
	end
	function bullet.CreateBvhTriangleMeshShape(...)
		return setmetatable({__ptr = lib.btBvhTriangleMeshShape_new2(...)}, META)
	end
end
do -- DbvtBroadphase
	local META = {}
	META.__index = META
	function META:GetNewpairs(...)
		lib.btDbvtBroadphase_getNewpairs(self.__ptr, ...)
	end
	function META:SetNeedcleanup(...)
		lib.btDbvtBroadphase_setNeedcleanup(self.__ptr, ...)
	end
	function META:Optimize(...)
		lib.btDbvtBroadphase_optimize(self.__ptr, ...)
	end
	function META:GetDupdates(...)
		lib.btDbvtBroadphase_getDupdates(self.__ptr, ...)
	end
	function META:SetFupdates(...)
		lib.btDbvtBroadphase_setFupdates(self.__ptr, ...)
	end
	function META:GetDeferedcollide(...)
		lib.btDbvtBroadphase_getDeferedcollide(self.__ptr, ...)
	end
	function META:GetFupdates(...)
		lib.btDbvtBroadphase_getFupdates(self.__ptr, ...)
	end
	function META:Collide(...)
		lib.btDbvtBroadphase_collide(self.__ptr, ...)
	end
	function META:SetGid(...)
		lib.btDbvtBroadphase_setGid(self.__ptr, ...)
	end
	function META:SetStageCurrent(...)
		lib.btDbvtBroadphase_setStageCurrent(self.__ptr, ...)
	end
	function META:SetAabbForceUpdate(...)
		lib.btDbvtBroadphase_setAabbForceUpdate(self.__ptr, ...)
	end
	function META:GetNeedcleanup(...)
		lib.btDbvtBroadphase_getNeedcleanup(self.__ptr, ...)
	end
	function META:SetDupdates(...)
		lib.btDbvtBroadphase_setDupdates(self.__ptr, ...)
	end
	function META:GetVelocityPrediction(...)
		lib.btDbvtBroadphase_getVelocityPrediction(self.__ptr, ...)
	end
	function META:SetPrediction(...)
		lib.btDbvtBroadphase_setPrediction(self.__ptr, ...)
	end
	function META:GetStageRoots(...)
		lib.btDbvtBroadphase_getStageRoots(self.__ptr, ...)
	end
	function META:SetDeferedcollide(...)
		lib.btDbvtBroadphase_setDeferedcollide(self.__ptr, ...)
	end
	function META:SetVelocityPrediction(...)
		lib.btDbvtBroadphase_setVelocityPrediction(self.__ptr, ...)
	end
	function META:GetSets(...)
		lib.btDbvtBroadphase_getSets(self.__ptr, ...)
	end
	function META:GetCupdates(...)
		lib.btDbvtBroadphase_getCupdates(self.__ptr, ...)
	end
	function META:GetPrediction(...)
		lib.btDbvtBroadphase_getPrediction(self.__ptr, ...)
	end
	function META:SetPid(...)
		lib.btDbvtBroadphase_setPid(self.__ptr, ...)
	end
	function META:GetGid(...)
		lib.btDbvtBroadphase_getGid(self.__ptr, ...)
	end
	function META:GetReleasepaircache(...)
		lib.btDbvtBroadphase_getReleasepaircache(self.__ptr, ...)
	end
	function META:SetNewpairs(...)
		lib.btDbvtBroadphase_setNewpairs(self.__ptr, ...)
	end
	function META:GetStageCurrent(...)
		lib.btDbvtBroadphase_getStageCurrent(self.__ptr, ...)
	end
	function META:PerformDeferredRemoval(...)
		lib.btDbvtBroadphase_performDeferredRemoval(self.__ptr, ...)
	end
	function META:Benchmark(...)
		lib.btDbvtBroadphase_benchmark(self.__ptr, ...)
	end
	function META:GetPaircache(...)
		lib.btDbvtBroadphase_getPaircache(self.__ptr, ...)
	end
	function META:GetPid(...)
		lib.btDbvtBroadphase_getPid(self.__ptr, ...)
	end
	function META:SetReleasepaircache(...)
		lib.btDbvtBroadphase_setReleasepaircache(self.__ptr, ...)
	end
	function META:GetFixedleft(...)
		lib.btDbvtBroadphase_getFixedleft(self.__ptr, ...)
	end
	function META:SetPaircache(...)
		lib.btDbvtBroadphase_setPaircache(self.__ptr, ...)
	end
	function META:SetCid(...)
		lib.btDbvtBroadphase_setCid(self.__ptr, ...)
	end
	function META:SetCupdates(...)
		lib.btDbvtBroadphase_setCupdates(self.__ptr, ...)
	end
	function META:GetCid(...)
		lib.btDbvtBroadphase_getCid(self.__ptr, ...)
	end
	function META:SetFixedleft(...)
		lib.btDbvtBroadphase_setFixedleft(self.__ptr, ...)
	end
	function bullet.CreateDbvtBroadphase(...)
		return setmetatable({__ptr = lib.btDbvtBroadphase_new2(...)}, META)
	end
end
do -- Generic6DofSpringConstraint
	local META = {}
	META.__index = META
	function META:EnableSpring(...)
		lib.btGeneric6DofSpringConstraint_enableSpring(self.__ptr, ...)
	end
	function META:SetDamping(...)
		lib.btGeneric6DofSpringConstraint_setDamping(self.__ptr, ...)
	end
	function META:SetStiffness(...)
		lib.btGeneric6DofSpringConstraint_setStiffness(self.__ptr, ...)
	end
	function META:SetEquilibriumPoint(...)
		lib.btGeneric6DofSpringConstraint_setEquilibriumPoint(self.__ptr, ...)
	end
	function bullet.CreateGeneric6DofSpringConstraint(...)
		return setmetatable({__ptr = lib.btGeneric6DofSpringConstraint_new2(...)}, META)
	end
end
do -- RotationalLimitMotor2
	local META = {}
	META.__index = META
	function META:SetTargetVelocity(...)
		lib.btRotationalLimitMotor2_setTargetVelocity(self.__ptr, ...)
	end
	function META:GetLoLimit(...)
		lib.btRotationalLimitMotor2_getLoLimit(self.__ptr, ...)
	end
	function META:GetCurrentLimit(...)
		lib.btRotationalLimitMotor2_getCurrentLimit(self.__ptr, ...)
	end
	function META:GetEquilibriumPoint(...)
		lib.btRotationalLimitMotor2_getEquilibriumPoint(self.__ptr, ...)
	end
	function META:SetCurrentPosition(...)
		lib.btRotationalLimitMotor2_setCurrentPosition(self.__ptr, ...)
	end
	function META:GetEnableSpring(...)
		lib.btRotationalLimitMotor2_getEnableSpring(self.__ptr, ...)
	end
	function META:SetEnableMotor(...)
		lib.btRotationalLimitMotor2_setEnableMotor(self.__ptr, ...)
	end
	function META:SetCurrentLimitErrorHi(...)
		lib.btRotationalLimitMotor2_setCurrentLimitErrorHi(self.__ptr, ...)
	end
	function META:SetEquilibriumPoint(...)
		lib.btRotationalLimitMotor2_setEquilibriumPoint(self.__ptr, ...)
	end
	function META:IsLimited(...)
		lib.btRotationalLimitMotor2_isLimited(self.__ptr, ...)
	end
	function META:SetCurrentLimit(...)
		lib.btRotationalLimitMotor2_setCurrentLimit(self.__ptr, ...)
	end
	function META:SetServoMotor(...)
		lib.btRotationalLimitMotor2_setServoMotor(self.__ptr, ...)
	end
	function META:GetSpringDamping(...)
		lib.btRotationalLimitMotor2_getSpringDamping(self.__ptr, ...)
	end
	function META:SetMotorERP(...)
		lib.btRotationalLimitMotor2_setMotorERP(self.__ptr, ...)
	end
	function META:GetServoMotor(...)
		lib.btRotationalLimitMotor2_getServoMotor(self.__ptr, ...)
	end
	function META:GetTargetVelocity(...)
		lib.btRotationalLimitMotor2_getTargetVelocity(self.__ptr, ...)
	end
	function META:Delete(...)
		lib.btRotationalLimitMotor2_delete(self.__ptr, ...)
	end
	function META:TestLimitValue(...)
		lib.btRotationalLimitMotor2_testLimitValue(self.__ptr, ...)
	end
	function META:SetStopERP(...)
		lib.btRotationalLimitMotor2_setStopERP(self.__ptr, ...)
	end
	function META:GetMotorCFM(...)
		lib.btRotationalLimitMotor2_getMotorCFM(self.__ptr, ...)
	end
	function META:SetStopCFM(...)
		lib.btRotationalLimitMotor2_setStopCFM(self.__ptr, ...)
	end
	function META:GetEnableMotor(...)
		lib.btRotationalLimitMotor2_getEnableMotor(self.__ptr, ...)
	end
	function META:GetServoTarget(...)
		lib.btRotationalLimitMotor2_getServoTarget(self.__ptr, ...)
	end
	function META:SetSpringStiffness(...)
		lib.btRotationalLimitMotor2_setSpringStiffness(self.__ptr, ...)
	end
	function META:GetStopERP(...)
		lib.btRotationalLimitMotor2_getStopERP(self.__ptr, ...)
	end
	function META:SetSpringDamping(...)
		lib.btRotationalLimitMotor2_setSpringDamping(self.__ptr, ...)
	end
	function META:GetCurrentPosition(...)
		lib.btRotationalLimitMotor2_getCurrentPosition(self.__ptr, ...)
	end
	function META:SetServoTarget(...)
		lib.btRotationalLimitMotor2_setServoTarget(self.__ptr, ...)
	end
	function META:SetLoLimit(...)
		lib.btRotationalLimitMotor2_setLoLimit(self.__ptr, ...)
	end
	function META:SetMotorCFM(...)
		lib.btRotationalLimitMotor2_setMotorCFM(self.__ptr, ...)
	end
	function META:GetCurrentLimitError(...)
		lib.btRotationalLimitMotor2_getCurrentLimitError(self.__ptr, ...)
	end
	function META:GetMotorERP(...)
		lib.btRotationalLimitMotor2_getMotorERP(self.__ptr, ...)
	end
	function META:GetBounce(...)
		lib.btRotationalLimitMotor2_getBounce(self.__ptr, ...)
	end
	function META:GetStopCFM(...)
		lib.btRotationalLimitMotor2_getStopCFM(self.__ptr, ...)
	end
	function META:GetHiLimit(...)
		lib.btRotationalLimitMotor2_getHiLimit(self.__ptr, ...)
	end
	function META:SetBounce(...)
		lib.btRotationalLimitMotor2_setBounce(self.__ptr, ...)
	end
	function META:GetSpringStiffness(...)
		lib.btRotationalLimitMotor2_getSpringStiffness(self.__ptr, ...)
	end
	function META:SetCurrentLimitError(...)
		lib.btRotationalLimitMotor2_setCurrentLimitError(self.__ptr, ...)
	end
	function META:SetMaxMotorForce(...)
		lib.btRotationalLimitMotor2_setMaxMotorForce(self.__ptr, ...)
	end
	function META:SetHiLimit(...)
		lib.btRotationalLimitMotor2_setHiLimit(self.__ptr, ...)
	end
	function META:GetMaxMotorForce(...)
		lib.btRotationalLimitMotor2_getMaxMotorForce(self.__ptr, ...)
	end
	function META:SetEnableSpring(...)
		lib.btRotationalLimitMotor2_setEnableSpring(self.__ptr, ...)
	end
	function META:GetCurrentLimitErrorHi(...)
		lib.btRotationalLimitMotor2_getCurrentLimitErrorHi(self.__ptr, ...)
	end
	function bullet.CreateRotationalLimitMotor2(...)
		return setmetatable({__ptr = lib.btRotationalLimitMotor2_new2(...)}, META)
	end
end
do -- SoftBodyRigidBodyCollisionConfiguration
	local META = {}
	META.__index = META
	function bullet.CreateSoftBodyRigidBodyCollisionConfiguration(...)
		return setmetatable({__ptr = lib.btSoftBodyRigidBodyCollisionConfiguration_new2(...)}, META)
	end
end
do -- BulletWorldImporter
	local META = {}
	META.__index = META
	function META:ConvertAllObjects(...)
		lib.btBulletWorldImporter_convertAllObjects(self.__ptr, ...)
	end
	function META:LoadFile(...)
		lib.btBulletWorldImporter_loadFile(self.__ptr, ...)
	end
	function META:LoadFileFromMemory(...)
		lib.btBulletWorldImporter_loadFileFromMemory(self.__ptr, ...)
	end
	function bullet.CreateBulletWorldImporter(...)
		return setmetatable({__ptr = lib.btBulletWorldImporter_new2(...)}, META)
	end
end
do -- Box2dShape
	local META = {}
	META.__index = META
	function META:GetVertexCount(...)
		lib.btBox2dShape_getVertexCount(self.__ptr, ...)
	end
	function META:GetVertices(...)
		lib.btBox2dShape_getVertices(self.__ptr, ...)
	end
	function META:GetNormals(...)
		lib.btBox2dShape_getNormals(self.__ptr, ...)
	end
	function META:GetPlaneEquation(...)
		lib.btBox2dShape_getPlaneEquation(self.__ptr, ...)
	end
	function META:GetCentroid(...)
		lib.btBox2dShape_getCentroid(self.__ptr, ...)
	end
	function META:GetHalfExtentsWithMargin(...)
		lib.btBox2dShape_getHalfExtentsWithMargin(self.__ptr, ...)
	end
	function META:GetHalfExtentsWithoutMargin(...)
		lib.btBox2dShape_getHalfExtentsWithoutMargin(self.__ptr, ...)
	end
	function bullet.CreateBox2dShape(...)
		return setmetatable({__ptr = lib.btBox2dShape_new2(...)}, META)
	end
end
do -- Dbvt_sStkNPS
	local META = {}
	META.__index = META
	function META:SetValue(...)
		lib.btDbvt_sStkNPS_setValue(self.__ptr, ...)
	end
	function META:Delete(...)
		lib.btDbvt_sStkNPS_delete(self.__ptr, ...)
	end
	function META:SetNode(...)
		lib.btDbvt_sStkNPS_setNode(self.__ptr, ...)
	end
	function META:GetValue(...)
		lib.btDbvt_sStkNPS_getValue(self.__ptr, ...)
	end
	function META:GetMask(...)
		lib.btDbvt_sStkNPS_getMask(self.__ptr, ...)
	end
	function META:GetNode(...)
		lib.btDbvt_sStkNPS_getNode(self.__ptr, ...)
	end
	function META:SetMask(...)
		lib.btDbvt_sStkNPS_setMask(self.__ptr, ...)
	end
	function bullet.CreateDbvt_sStkNPS(...)
		return setmetatable({__ptr = lib.btDbvt_sStkNPS_new2(...)}, META)
	end
end
do -- MultiBody
	local META = {}
	META.__index = META
	function META:FillContactJacobianMultiDof(...)
		lib.btMultiBody_fillContactJacobianMultiDof(self.__ptr, ...)
	end
	function META:GetBasePos(...)
		lib.btMultiBody_getBasePos(self.__ptr, ...)
	end
	function META:GetBaseMass(...)
		lib.btMultiBody_getBaseMass(self.__ptr, ...)
	end
	function META:IsUsingGlobalVelocities(...)
		lib.btMultiBody_isUsingGlobalVelocities(self.__ptr, ...)
	end
	function META:GetWorldToBaseRot(...)
		lib.btMultiBody_getWorldToBaseRot(self.__ptr, ...)
	end
	function META:SetJointVel(...)
		lib.btMultiBody_setJointVel(self.__ptr, ...)
	end
	function META:GetKineticEnergy(...)
		lib.btMultiBody_getKineticEnergy(self.__ptr, ...)
	end
	function META:SetupSpherical(...)
		lib.btMultiBody_setupSpherical(self.__ptr, ...)
	end
	function META:GetJointVelMultiDof(...)
		lib.btMultiBody_getJointVelMultiDof(self.__ptr, ...)
	end
	function META:FillContactJacobian(...)
		lib.btMultiBody_fillContactJacobian(self.__ptr, ...)
	end
	function META:SetWorldToBaseRot(...)
		lib.btMultiBody_setWorldToBaseRot(self.__ptr, ...)
	end
	function META:AddJointTorque(...)
		lib.btMultiBody_addJointTorque(self.__ptr, ...)
	end
	function META:GetNumPosVars(...)
		lib.btMultiBody_getNumPosVars(self.__ptr, ...)
	end
	function META:GetBaseOmega(...)
		lib.btMultiBody_getBaseOmega(self.__ptr, ...)
	end
	function META:ClearForcesAndTorques(...)
		lib.btMultiBody_clearForcesAndTorques(self.__ptr, ...)
	end
	function META:StepVelocitiesMultiDof(...)
		lib.btMultiBody_stepVelocitiesMultiDof(self.__ptr, ...)
	end
	function META:AddJointTorqueMultiDof(...)
		lib.btMultiBody_addJointTorqueMultiDof(self.__ptr, ...)
	end
	function META:GetBaseVel(...)
		lib.btMultiBody_getBaseVel(self.__ptr, ...)
	end
	function META:GetParentToLocalRot(...)
		lib.btMultiBody_getParentToLocalRot(self.__ptr, ...)
	end
	function META:CheckMotionAndSleepIfRequired(...)
		lib.btMultiBody_checkMotionAndSleepIfRequired(self.__ptr, ...)
	end
	function META:SetupPlanar(...)
		lib.btMultiBody_setupPlanar(self.__ptr, ...)
	end
	function META:SetJointPosMultiDof(...)
		lib.btMultiBody_setJointPosMultiDof(self.__ptr, ...)
	end
	function META:IsPosUpdated(...)
		lib.btMultiBody_isPosUpdated(self.__ptr, ...)
	end
	function META:GetNumLinks(...)
		lib.btMultiBody_getNumLinks(self.__ptr, ...)
	end
	function META:SetUseGyroTerm(...)
		lib.btMultiBody_setUseGyroTerm(self.__ptr, ...)
	end
	function META:GetRVector(...)
		lib.btMultiBody_getRVector(self.__ptr, ...)
	end
	function META:GetJointPosMultiDof(...)
		lib.btMultiBody_getJointPosMultiDof(self.__ptr, ...)
	end
	function META:GetLink(...)
		lib.btMultiBody_getLink(self.__ptr, ...)
	end
	function META:GetMaxAppliedImpulse(...)
		lib.btMultiBody_getMaxAppliedImpulse(self.__ptr, ...)
	end
	function META:AddBaseTorque(...)
		lib.btMultiBody_addBaseTorque(self.__ptr, ...)
	end
	function META:GetJointTorque(...)
		lib.btMultiBody_getJointTorque(self.__ptr, ...)
	end
	function META:WakeUp(...)
		lib.btMultiBody_wakeUp(self.__ptr, ...)
	end
	function META:GetParent(...)
		lib.btMultiBody_getParent(self.__ptr, ...)
	end
	function META:GetAngularDamping(...)
		lib.btMultiBody_getAngularDamping(self.__ptr, ...)
	end
	function META:ApplyDeltaVee(...)
		lib.btMultiBody_applyDeltaVee(self.__ptr, ...)
	end
	function META:WorldDirToLocal(...)
		lib.btMultiBody_worldDirToLocal(self.__ptr, ...)
	end
	function META:SetBaseMass(...)
		lib.btMultiBody_setBaseMass(self.__ptr, ...)
	end
	function META:GetJointVel(...)
		lib.btMultiBody_getJointVel(self.__ptr, ...)
	end
	function META:CalcAccelerationDeltasMultiDof(...)
		lib.btMultiBody_calcAccelerationDeltasMultiDof(self.__ptr, ...)
	end
	function META:SetBaseVel(...)
		lib.btMultiBody_setBaseVel(self.__ptr, ...)
	end
	function META:GetCompanionId(...)
		lib.btMultiBody_getCompanionId(self.__ptr, ...)
	end
	function META:GetLinkTorque(...)
		lib.btMultiBody_getLinkTorque(self.__ptr, ...)
	end
	function META:Delete(...)
		lib.btMultiBody_delete(self.__ptr, ...)
	end
	function META:UseRK4Integration(...)
		lib.btMultiBody_useRK4Integration(self.__ptr, ...)
	end
	function META:UseGlobalVelocities(...)
		lib.btMultiBody_useGlobalVelocities(self.__ptr, ...)
	end
	function META:SetBaseOmega(...)
		lib.btMultiBody_setBaseOmega(self.__ptr, ...)
	end
	function META:StepVelocities(...)
		lib.btMultiBody_stepVelocities(self.__ptr, ...)
	end
	function META:GoToSleep(...)
		lib.btMultiBody_goToSleep(self.__ptr, ...)
	end
	function META:StepPositionsMultiDof(...)
		lib.btMultiBody_stepPositionsMultiDof(self.__ptr, ...)
	end
	function META:SetupRevolute(...)
		lib.btMultiBody_setupRevolute(self.__ptr, ...)
	end
	function META:StepPositions(...)
		lib.btMultiBody_stepPositions(self.__ptr, ...)
	end
	function META:SetupPrismatic(...)
		lib.btMultiBody_setupPrismatic(self.__ptr, ...)
	end
	function META:SetupFixed(...)
		lib.btMultiBody_setupFixed(self.__ptr, ...)
	end
	function META:SetPosUpdated(...)
		lib.btMultiBody_setPosUpdated(self.__ptr, ...)
	end
	function META:SetBaseCollider(...)
		lib.btMultiBody_setBaseCollider(self.__ptr, ...)
	end
	function META:SetMaxCoordinateVelocity(...)
		lib.btMultiBody_setMaxCoordinateVelocity(self.__ptr, ...)
	end
	function META:SetNumLinks(...)
		lib.btMultiBody_setNumLinks(self.__ptr, ...)
	end
	function META:AddLinkTorque(...)
		lib.btMultiBody_addLinkTorque(self.__ptr, ...)
	end
	function META:GetBaseCollider(...)
		lib.btMultiBody_getBaseCollider(self.__ptr, ...)
	end
	function META:SetJointVelMultiDof(...)
		lib.btMultiBody_setJointVelMultiDof(self.__ptr, ...)
	end
	function META:LocalDirToWorld(...)
		lib.btMultiBody_localDirToWorld(self.__ptr, ...)
	end
	function META:SetJointPos(...)
		lib.btMultiBody_setJointPos(self.__ptr, ...)
	end
	function META:ApplyDeltaVeeMultiDof(...)
		lib.btMultiBody_applyDeltaVeeMultiDof(self.__ptr, ...)
	end
	function META:HasFixedBase(...)
		lib.btMultiBody_hasFixedBase(self.__ptr, ...)
	end
	function META:SetHasSelfCollision(...)
		lib.btMultiBody_setHasSelfCollision(self.__ptr, ...)
	end
	function META:SetCompanionId(...)
		lib.btMultiBody_setCompanionId(self.__ptr, ...)
	end
	function META:GetLinkForce(...)
		lib.btMultiBody_getLinkForce(self.__ptr, ...)
	end
	function META:SetCanSleep(...)
		lib.btMultiBody_setCanSleep(self.__ptr, ...)
	end
	function META:SetBasePos(...)
		lib.btMultiBody_setBasePos(self.__ptr, ...)
	end
	function META:WorldPosToLocal(...)
		lib.btMultiBody_worldPosToLocal(self.__ptr, ...)
	end
	function META:GetAngularMomentum(...)
		lib.btMultiBody_getAngularMomentum(self.__ptr, ...)
	end
	function META:SetMaxAppliedImpulse(...)
		lib.btMultiBody_setMaxAppliedImpulse(self.__ptr, ...)
	end
	function META:HasSelfCollision(...)
		lib.btMultiBody_hasSelfCollision(self.__ptr, ...)
	end
	function META:ClearVelocities(...)
		lib.btMultiBody_clearVelocities(self.__ptr, ...)
	end
	function META:CalcAccelerationDeltas(...)
		lib.btMultiBody_calcAccelerationDeltas(self.__ptr, ...)
	end
	function META:IsMultiDof(...)
		lib.btMultiBody_isMultiDof(self.__ptr, ...)
	end
	function META:IsUsingRK4Integration(...)
		lib.btMultiBody_isUsingRK4Integration(self.__ptr, ...)
	end
	function META:LocalPosToWorld(...)
		lib.btMultiBody_localPosToWorld(self.__ptr, ...)
	end
	function META:AddLinkForce(...)
		lib.btMultiBody_addLinkForce(self.__ptr, ...)
	end
	function META:FinalizeMultiDof(...)
		lib.btMultiBody_finalizeMultiDof(self.__ptr, ...)
	end
	function META:GetBaseForce(...)
		lib.btMultiBody_getBaseForce(self.__ptr, ...)
	end
	function META:GetCanSleep(...)
		lib.btMultiBody_getCanSleep(self.__ptr, ...)
	end
	function META:GetMaxCoordinateVelocity(...)
		lib.btMultiBody_getMaxCoordinateVelocity(self.__ptr, ...)
	end
	function META:GetBaseTorque(...)
		lib.btMultiBody_getBaseTorque(self.__ptr, ...)
	end
	function META:SetLinearDamping(...)
		lib.btMultiBody_setLinearDamping(self.__ptr, ...)
	end
	function META:GetLinkMass(...)
		lib.btMultiBody_getLinkMass(self.__ptr, ...)
	end
	function META:GetJointTorqueMultiDof(...)
		lib.btMultiBody_getJointTorqueMultiDof(self.__ptr, ...)
	end
	function META:GetJointPos(...)
		lib.btMultiBody_getJointPos(self.__ptr, ...)
	end
	function META:GetLinearDamping(...)
		lib.btMultiBody_getLinearDamping(self.__ptr, ...)
	end
	function META:GetBaseInertia(...)
		lib.btMultiBody_getBaseInertia(self.__ptr, ...)
	end
	function META:AddBaseForce(...)
		lib.btMultiBody_addBaseForce(self.__ptr, ...)
	end
	function META:GetLinkInertia(...)
		lib.btMultiBody_getLinkInertia(self.__ptr, ...)
	end
	function META:IsAwake(...)
		lib.btMultiBody_isAwake(self.__ptr, ...)
	end
	function META:SetBaseInertia(...)
		lib.btMultiBody_setBaseInertia(self.__ptr, ...)
	end
	function META:GetUseGyroTerm(...)
		lib.btMultiBody_getUseGyroTerm(self.__ptr, ...)
	end
	function META:GetNumDofs(...)
		lib.btMultiBody_getNumDofs(self.__ptr, ...)
	end
	function META:GetVelocityVector(...)
		lib.btMultiBody_getVelocityVector(self.__ptr, ...)
	end
	function META:FilConstraintJacobianMultiDof(...)
		lib.btMultiBody_filConstraintJacobianMultiDof(self.__ptr, ...)
	end
	function META:SetAngularDamping(...)
		lib.btMultiBody_setAngularDamping(self.__ptr, ...)
	end
	function bullet.CreateMultiBody(...)
		return setmetatable({__ptr = lib.btMultiBody_new2(...)}, META)
	end
end
do -- SphereTriangleCollisionAlgorithm
	local META = {}
	META.__index = META
	function bullet.CreateSphereTriangleCollisionAlgorithm(...)
		return setmetatable({__ptr = lib.btSphereTriangleCollisionAlgorithm_new2(...)}, META)
	end
end
do -- ConvexHullShape
	local META = {}
	META.__index = META
	function META:AddPoint(...)
		lib.btConvexHullShape_addPoint(self.__ptr, ...)
	end
	function META:GetScaledPoint(...)
		lib.btConvexHullShape_getScaledPoint(self.__ptr, ...)
	end
	function META:GetNumPoints(...)
		lib.btConvexHullShape_getNumPoints(self.__ptr, ...)
	end
	function META:GetUnscaledPoints(...)
		lib.btConvexHullShape_getUnscaledPoints(self.__ptr, ...)
	end
	function META:GetPoints(...)
		lib.btConvexHullShape_getPoints(self.__ptr, ...)
	end
	function META:Project(...)
		lib.btConvexHullShape_project(self.__ptr, ...)
	end
	function bullet.CreateConvexHullShape(...)
		return setmetatable({__ptr = lib.btConvexHullShape_new2(...)}, META)
	end
end
do -- Dbvt_sStkNN
	local META = {}
	META.__index = META
	function META:GetA(...)
		lib.btDbvt_sStkNN_getA(self.__ptr, ...)
	end
	function META:GetB(...)
		lib.btDbvt_sStkNN_getB(self.__ptr, ...)
	end
	function META:SetA(...)
		lib.btDbvt_sStkNN_setA(self.__ptr, ...)
	end
	function META:SetB(...)
		lib.btDbvt_sStkNN_setB(self.__ptr, ...)
	end
	function META:Delete(...)
		lib.btDbvt_sStkNN_delete(self.__ptr, ...)
	end
	function bullet.CreateDbvt_sStkNN(...)
		return setmetatable({__ptr = lib.btDbvt_sStkNN_new2(...)}, META)
	end
end
do -- Generic6DofSpring2Constraint
	local META = {}
	META.__index = META
	function META:SetTargetVelocity(...)
		lib.btGeneric6DofSpring2Constraint_setTargetVelocity(self.__ptr, ...)
	end
	function META:GetFrameOffsetA(...)
		lib.btGeneric6DofSpring2Constraint_getFrameOffsetA(self.__ptr, ...)
	end
	function META:CalculateTransforms(...)
		lib.btGeneric6DofSpring2Constraint_calculateTransforms(self.__ptr, ...)
	end
	function META:SetStiffness(...)
		lib.btGeneric6DofSpring2Constraint_setStiffness(self.__ptr, ...)
	end
	function META:SetAngularLowerLimitReversed(...)
		lib.btGeneric6DofSpring2Constraint_setAngularLowerLimitReversed(self.__ptr, ...)
	end
	function META:SetAngularLowerLimit(...)
		lib.btGeneric6DofSpring2Constraint_setAngularLowerLimit(self.__ptr, ...)
	end
	function META:SetFrames(...)
		lib.btGeneric6DofSpring2Constraint_setFrames(self.__ptr, ...)
	end
	function META:EnableMotor(...)
		lib.btGeneric6DofSpring2Constraint_enableMotor(self.__ptr, ...)
	end
	function META:GetTranslationalLimitMotor(...)
		lib.btGeneric6DofSpring2Constraint_getTranslationalLimitMotor(self.__ptr, ...)
	end
	function META:SetRotationOrder(...)
		lib.btGeneric6DofSpring2Constraint_setRotationOrder(self.__ptr, ...)
	end
	function META:SetEquilibriumPoint(...)
		lib.btGeneric6DofSpring2Constraint_setEquilibriumPoint(self.__ptr, ...)
	end
	function META:GetAngularUpperLimit(...)
		lib.btGeneric6DofSpring2Constraint_getAngularUpperLimit(self.__ptr, ...)
	end
	function META:GetCalculatedTransformA(...)
		lib.btGeneric6DofSpring2Constraint_getCalculatedTransformA(self.__ptr, ...)
	end
	function META:GetAngularUpperLimitReversed(...)
		lib.btGeneric6DofSpring2Constraint_getAngularUpperLimitReversed(self.__ptr, ...)
	end
	function META:SetAngularUpperLimit(...)
		lib.btGeneric6DofSpring2Constraint_setAngularUpperLimit(self.__ptr, ...)
	end
	function META:SetAngularUpperLimitReversed(...)
		lib.btGeneric6DofSpring2Constraint_setAngularUpperLimitReversed(self.__ptr, ...)
	end
	function META:GetCalculatedTransformB(...)
		lib.btGeneric6DofSpring2Constraint_getCalculatedTransformB(self.__ptr, ...)
	end
	function META:SetDamping(...)
		lib.btGeneric6DofSpring2Constraint_setDamping(self.__ptr, ...)
	end
	function META:SetLimitReversed(...)
		lib.btGeneric6DofSpring2Constraint_setLimitReversed(self.__ptr, ...)
	end
	function META:GetRotationOrder(...)
		lib.btGeneric6DofSpring2Constraint_getRotationOrder(self.__ptr, ...)
	end
	function META:SetLimit(...)
		lib.btGeneric6DofSpring2Constraint_setLimit(self.__ptr, ...)
	end
	function META:GetLinearLowerLimit(...)
		lib.btGeneric6DofSpring2Constraint_getLinearLowerLimit(self.__ptr, ...)
	end
	function META:GetRelativePivotPosition(...)
		lib.btGeneric6DofSpring2Constraint_getRelativePivotPosition(self.__ptr, ...)
	end
	function META:SetBounce(...)
		lib.btGeneric6DofSpring2Constraint_setBounce(self.__ptr, ...)
	end
	function META:GetRotationalLimitMotor(...)
		lib.btGeneric6DofSpring2Constraint_getRotationalLimitMotor(self.__ptr, ...)
	end
	function META:GetFrameOffsetB(...)
		lib.btGeneric6DofSpring2Constraint_getFrameOffsetB(self.__ptr, ...)
	end
	function META:GetAngularLowerLimitReversed(...)
		lib.btGeneric6DofSpring2Constraint_getAngularLowerLimitReversed(self.__ptr, ...)
	end
	function META:SetLinearUpperLimit(...)
		lib.btGeneric6DofSpring2Constraint_setLinearUpperLimit(self.__ptr, ...)
	end
	function META:GetAngularLowerLimit(...)
		lib.btGeneric6DofSpring2Constraint_getAngularLowerLimit(self.__ptr, ...)
	end
	function META:SetServoTarget(...)
		lib.btGeneric6DofSpring2Constraint_setServoTarget(self.__ptr, ...)
	end
	function META:SetServo(...)
		lib.btGeneric6DofSpring2Constraint_setServo(self.__ptr, ...)
	end
	function META:IsLimited(...)
		lib.btGeneric6DofSpring2Constraint_isLimited(self.__ptr, ...)
	end
	function META:GetAngle(...)
		lib.btGeneric6DofSpring2Constraint_getAngle(self.__ptr, ...)
	end
	function META:GetLinearUpperLimit(...)
		lib.btGeneric6DofSpring2Constraint_getLinearUpperLimit(self.__ptr, ...)
	end
	function META:SetMaxMotorForce(...)
		lib.btGeneric6DofSpring2Constraint_setMaxMotorForce(self.__ptr, ...)
	end
	function META:SetLinearLowerLimit(...)
		lib.btGeneric6DofSpring2Constraint_setLinearLowerLimit(self.__ptr, ...)
	end
	function META:EnableSpring(...)
		lib.btGeneric6DofSpring2Constraint_enableSpring(self.__ptr, ...)
	end
	function META:GetAxis(...)
		lib.btGeneric6DofSpring2Constraint_getAxis(self.__ptr, ...)
	end
	function META:SetAxis(...)
		lib.btGeneric6DofSpring2Constraint_setAxis(self.__ptr, ...)
	end
	function bullet.CreateGeneric6DofSpring2Constraint(...)
		return setmetatable({__ptr = lib.btGeneric6DofSpring2Constraint_new2(...)}, META)
	end
end
do -- ManifoldResult
	local META = {}
	META.__index = META
	function META:GetBody1Internal(...)
		lib.btManifoldResult_getBody1Internal(self.__ptr, ...)
	end
	function META:SetBody1Wrap(...)
		lib.btManifoldResult_setBody1Wrap(self.__ptr, ...)
	end
	function META:GetBody0Wrap(...)
		lib.btManifoldResult_getBody0Wrap(self.__ptr, ...)
	end
	function META:GetBody1Wrap(...)
		lib.btManifoldResult_getBody1Wrap(self.__ptr, ...)
	end
	function META:CalculateCombinedRestitution(...)
		lib.btManifoldResult_calculateCombinedRestitution(self.__ptr, ...)
	end
	function META:GetBody0Internal(...)
		lib.btManifoldResult_getBody0Internal(self.__ptr, ...)
	end
	function META:SetPersistentManifold(...)
		lib.btManifoldResult_setPersistentManifold(self.__ptr, ...)
	end
	function META:CalculateCombinedFriction(...)
		lib.btManifoldResult_calculateCombinedFriction(self.__ptr, ...)
	end
	function META:RefreshContactPoints(...)
		lib.btManifoldResult_refreshContactPoints(self.__ptr, ...)
	end
	function META:SetBody0Wrap(...)
		lib.btManifoldResult_setBody0Wrap(self.__ptr, ...)
	end
	function META:GetPersistentManifold(...)
		lib.btManifoldResult_getPersistentManifold(self.__ptr, ...)
	end
	function bullet.CreateManifoldResult(...)
		return setmetatable({__ptr = lib.btManifoldResult_new2(...)}, META)
	end
end
do -- MultiBodyJointMotor
	local META = {}
	META.__index = META
	function META:SetVelocityTarget(...)
		lib.btMultiBodyJointMotor_setVelocityTarget(self.__ptr, ...)
	end
	function bullet.CreateMultiBodyJointMotor(...)
		return setmetatable({__ptr = lib.btMultiBodyJointMotor_new2(...)}, META)
	end
end
do -- MultimaterialTriangleMeshShape
	local META = {}
	META.__index = META
	function META:GetMaterialProperties(...)
		lib.btMultimaterialTriangleMeshShape_getMaterialProperties(self.__ptr, ...)
	end
	function bullet.CreateMultimaterialTriangleMeshShape(...)
		return setmetatable({__ptr = lib.btMultimaterialTriangleMeshShape_new2(...)}, META)
	end
end
do -- BoxBoxCollisionAlgorithm
	local META = {}
	META.__index = META
	function bullet.CreateBoxBoxCollisionAlgorithm(...)
		return setmetatable({__ptr = lib.btBoxBoxCollisionAlgorithm_new2(...)}, META)
	end
end
do -- Generic6DofConstraint
	local META = {}
	META.__index = META
	function META:GetCalculatedTransformB(...)
		lib.btGeneric6DofConstraint_getCalculatedTransformB(self.__ptr, ...)
	end
	function META:SetLinearLowerLimit(...)
		lib.btGeneric6DofConstraint_setLinearLowerLimit(self.__ptr, ...)
	end
	function META:GetFrameOffsetA(...)
		lib.btGeneric6DofConstraint_getFrameOffsetA(self.__ptr, ...)
	end
	function META:CalculateTransforms(...)
		lib.btGeneric6DofConstraint_calculateTransforms(self.__ptr, ...)
	end
	function META:TestAngularLimitMotor(...)
		lib.btGeneric6DofConstraint_testAngularLimitMotor(self.__ptr, ...)
	end
	function META:GetInfo1NonVirtual(...)
		lib.btGeneric6DofConstraint_getInfo1NonVirtual(self.__ptr, ...)
	end
	function META:SetLimit(...)
		lib.btGeneric6DofConstraint_setLimit(self.__ptr, ...)
	end
	function META:GetLinearLowerLimit(...)
		lib.btGeneric6DofConstraint_getLinearLowerLimit(self.__ptr, ...)
	end
	function META:SetAngularLowerLimit(...)
		lib.btGeneric6DofConstraint_setAngularLowerLimit(self.__ptr, ...)
	end
	function META:UpdateRHS(...)
		lib.btGeneric6DofConstraint_updateRHS(self.__ptr, ...)
	end
	function META:SetUseFrameOffset(...)
		lib.btGeneric6DofConstraint_setUseFrameOffset(self.__ptr, ...)
	end
	function META:GetRelativePivotPosition(...)
		lib.btGeneric6DofConstraint_getRelativePivotPosition(self.__ptr, ...)
	end
	function META:SetFrames(...)
		lib.btGeneric6DofConstraint_setFrames(self.__ptr, ...)
	end
	function META:GetAngularUpperLimit(...)
		lib.btGeneric6DofConstraint_getAngularUpperLimit(self.__ptr, ...)
	end
	function META:GetRotationalLimitMotor(...)
		lib.btGeneric6DofConstraint_getRotationalLimitMotor(self.__ptr, ...)
	end
	function META:SetUseSolveConstraintObsolete(...)
		lib.btGeneric6DofConstraint_setUseSolveConstraintObsolete(self.__ptr, ...)
	end
	function META:GetFrameOffsetB(...)
		lib.btGeneric6DofConstraint_getFrameOffsetB(self.__ptr, ...)
	end
	function META:SetAxis(...)
		lib.btGeneric6DofConstraint_setAxis(self.__ptr, ...)
	end
	function META:GetAxis(...)
		lib.btGeneric6DofConstraint_getAxis(self.__ptr, ...)
	end
	function META:SetLinearUpperLimit(...)
		lib.btGeneric6DofConstraint_setLinearUpperLimit(self.__ptr, ...)
	end
	function META:GetAngularLowerLimit(...)
		lib.btGeneric6DofConstraint_getAngularLowerLimit(self.__ptr, ...)
	end
	function META:IsLimited(...)
		lib.btGeneric6DofConstraint_isLimited(self.__ptr, ...)
	end
	function META:GetUseSolveConstraintObsolete(...)
		lib.btGeneric6DofConstraint_getUseSolveConstraintObsolete(self.__ptr, ...)
	end
	function META:CalcAnchorPos(...)
		lib.btGeneric6DofConstraint_calcAnchorPos(self.__ptr, ...)
	end
	function META:GetAngle(...)
		lib.btGeneric6DofConstraint_getAngle(self.__ptr, ...)
	end
	function META:GetCalculatedTransformA(...)
		lib.btGeneric6DofConstraint_getCalculatedTransformA(self.__ptr, ...)
	end
	function META:GetTranslationalLimitMotor(...)
		lib.btGeneric6DofConstraint_getTranslationalLimitMotor(self.__ptr, ...)
	end
	function META:GetUseFrameOffset(...)
		lib.btGeneric6DofConstraint_getUseFrameOffset(self.__ptr, ...)
	end
	function META:SetAngularUpperLimit(...)
		lib.btGeneric6DofConstraint_setAngularUpperLimit(self.__ptr, ...)
	end
	function META:GetLinearUpperLimit(...)
		lib.btGeneric6DofConstraint_getLinearUpperLimit(self.__ptr, ...)
	end
	function META:GetInfo2NonVirtual(...)
		lib.btGeneric6DofConstraint_getInfo2NonVirtual(self.__ptr, ...)
	end
	function bullet.CreateGeneric6DofConstraint(...)
		return setmetatable({__ptr = lib.btGeneric6DofConstraint_new2(...)}, META)
	end
end
do -- RigidBody_btRigidBodyConstructionInfo
	local META = {}
	META.__index = META
	function META:SetAngularDamping(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_setAngularDamping(self.__ptr, ...)
	end
	function META:GetCollisionShape(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_getCollisionShape(self.__ptr, ...)
	end
	function META:Delete(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_delete(self.__ptr, ...)
	end
	function META:SetAdditionalDamping(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_setAdditionalDamping(self.__ptr, ...)
	end
	function META:SetMotionState(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_setMotionState(self.__ptr, ...)
	end
	function META:SetAdditionalAngularDampingFactor(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_setAdditionalAngularDampingFactor(self.__ptr, ...)
	end
	function META:SetRestitution(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_setRestitution(self.__ptr, ...)
	end
	function META:GetAdditionalDampingFactor(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_getAdditionalDampingFactor(self.__ptr, ...)
	end
	function META:SetLocalInertia(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_setLocalInertia(self.__ptr, ...)
	end
	function META:SetAdditionalDampingFactor(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_setAdditionalDampingFactor(self.__ptr, ...)
	end
	function META:GetAdditionalDamping(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_getAdditionalDamping(self.__ptr, ...)
	end
	function META:GetFriction(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_getFriction(self.__ptr, ...)
	end
	function META:GetLocalInertia(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_getLocalInertia(self.__ptr, ...)
	end
	function META:GetStartWorldTransform(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_getStartWorldTransform(self.__ptr, ...)
	end
	function META:SetAdditionalLinearDampingThresholdSqr(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_setAdditionalLinearDampingThresholdSqr(self.__ptr, ...)
	end
	function META:SetLinearSleepingThreshold(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_setLinearSleepingThreshold(self.__ptr, ...)
	end
	function META:GetAdditionalLinearDampingThresholdSqr(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_getAdditionalLinearDampingThresholdSqr(self.__ptr, ...)
	end
	function META:SetMass(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_setMass(self.__ptr, ...)
	end
	function META:SetStartWorldTransform(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_setStartWorldTransform(self.__ptr, ...)
	end
	function META:SetRollingFriction(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_setRollingFriction(self.__ptr, ...)
	end
	function META:GetRollingFriction(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_getRollingFriction(self.__ptr, ...)
	end
	function META:SetLinearDamping(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_setLinearDamping(self.__ptr, ...)
	end
	function META:SetFriction(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_setFriction(self.__ptr, ...)
	end
	function META:GetAngularSleepingThreshold(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_getAngularSleepingThreshold(self.__ptr, ...)
	end
	function META:GetLinearDamping(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_getLinearDamping(self.__ptr, ...)
	end
	function META:GetAngularDamping(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_getAngularDamping(self.__ptr, ...)
	end
	function META:SetAngularSleepingThreshold(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_setAngularSleepingThreshold(self.__ptr, ...)
	end
	function META:GetLinearSleepingThreshold(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_getLinearSleepingThreshold(self.__ptr, ...)
	end
	function META:GetRestitution(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_getRestitution(self.__ptr, ...)
	end
	function META:SetCollisionShape(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_setCollisionShape(self.__ptr, ...)
	end
	function META:SetAdditionalAngularDampingThresholdSqr(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_setAdditionalAngularDampingThresholdSqr(self.__ptr, ...)
	end
	function META:GetAdditionalAngularDampingThresholdSqr(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_getAdditionalAngularDampingThresholdSqr(self.__ptr, ...)
	end
	function META:GetMotionState(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_getMotionState(self.__ptr, ...)
	end
	function META:GetAdditionalAngularDampingFactor(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_getAdditionalAngularDampingFactor(self.__ptr, ...)
	end
	function META:GetMass(...)
		lib.btRigidBody_btRigidBodyConstructionInfo_getMass(self.__ptr, ...)
	end
	function bullet.CreateRigidBody_btRigidBodyConstructionInfo(...)
		return setmetatable({__ptr = lib.btRigidBody_btRigidBodyConstructionInfo_new2(...)}, META)
	end
end
do -- SoftBody_Body
	local META = {}
	META.__index = META
	function META:Velocity(...)
		lib.btSoftBody_Body_velocity(self.__ptr, ...)
	end
	function META:ApplyDCImpulse(...)
		lib.btSoftBody_Body_applyDCImpulse(self.__ptr, ...)
	end
	function META:ApplyDImpulse(...)
		lib.btSoftBody_Body_applyDImpulse(self.__ptr, ...)
	end
	function META:GetCollisionObject(...)
		lib.btSoftBody_Body_getCollisionObject(self.__ptr, ...)
	end
	function META:GetSoft(...)
		lib.btSoftBody_Body_getSoft(self.__ptr, ...)
	end
	function META:ApplyVImpulse(...)
		lib.btSoftBody_Body_applyVImpulse(self.__ptr, ...)
	end
	function META:SetCollisionObject(...)
		lib.btSoftBody_Body_setCollisionObject(self.__ptr, ...)
	end
	function META:Activate(...)
		lib.btSoftBody_Body_activate(self.__ptr, ...)
	end
	function META:SetRigid(...)
		lib.btSoftBody_Body_setRigid(self.__ptr, ...)
	end
	function META:Xform(...)
		lib.btSoftBody_Body_xform(self.__ptr, ...)
	end
	function META:InvWorldInertia(...)
		lib.btSoftBody_Body_invWorldInertia(self.__ptr, ...)
	end
	function META:LinearVelocity(...)
		lib.btSoftBody_Body_linearVelocity(self.__ptr, ...)
	end
	function META:GetRigid(...)
		lib.btSoftBody_Body_getRigid(self.__ptr, ...)
	end
	function META:ApplyVAImpulse(...)
		lib.btSoftBody_Body_applyVAImpulse(self.__ptr, ...)
	end
	function META:Delete(...)
		lib.btSoftBody_Body_delete(self.__ptr, ...)
	end
	function META:ApplyDAImpulse(...)
		lib.btSoftBody_Body_applyDAImpulse(self.__ptr, ...)
	end
	function META:SetSoft(...)
		lib.btSoftBody_Body_setSoft(self.__ptr, ...)
	end
	function META:InvMass(...)
		lib.btSoftBody_Body_invMass(self.__ptr, ...)
	end
	function META:ApplyImpulse(...)
		lib.btSoftBody_Body_applyImpulse(self.__ptr, ...)
	end
	function META:AngularVelocity(...)
		lib.btSoftBody_Body_angularVelocity(self.__ptr, ...)
	end
	function META:ApplyAImpulse(...)
		lib.btSoftBody_Body_applyAImpulse(self.__ptr, ...)
	end
	function bullet.CreateSoftBody_Body(...)
		return setmetatable({__ptr = lib.btSoftBody_Body_new2(...)}, META)
	end
end
do -- SoftBody_Link
	local META = {}
	META.__index = META
	function META:GetBbending(...)
		lib.btSoftBody_Link_getBbending(self.__ptr, ...)
	end
	function META:SetRl(...)
		lib.btSoftBody_Link_setRl(self.__ptr, ...)
	end
	function META:SetC(...)
		lib.btSoftBody_Link_setC0(self.__ptr, ...)
	end
	function META:SetBbending(...)
		lib.btSoftBody_Link_setBbending(self.__ptr, ...)
	end
	function META:GetN(...)
		lib.btSoftBody_Link_getN(self.__ptr, ...)
	end
	function META:GetC(...)
		lib.btSoftBody_Link_getC0(self.__ptr, ...)
	end
	function META:GetRl(...)
		lib.btSoftBody_Link_getRl(self.__ptr, ...)
	end
	function bullet.CreateSoftBody_Link(...)
		return setmetatable({__ptr = lib.btSoftBody_Link_new2(...)}, META)
	end
end
do -- AABB
	local META = {}
	META.__index = META
	function META:GetMax(...)
		lib.btAABB_getMax(self.__ptr, ...)
	end
	function META:Invalidate(...)
		lib.btAABB_invalidate(self.__ptr, ...)
	end
	function META:Delete(...)
		lib.btAABB_delete(self.__ptr, ...)
	end
	function META:SetMin(...)
		lib.btAABB_setMin(self.__ptr, ...)
	end
	function META:SetMax(...)
		lib.btAABB_setMax(self.__ptr, ...)
	end
	function META:Merge(...)
		lib.btAABB_merge(self.__ptr, ...)
	end
	function META:GetMin(...)
		lib.btAABB_getMin(self.__ptr, ...)
	end
	function bullet.CreateAABB(...)
		return setmetatable({__ptr = lib.btAABB_new2(...)}, META)
	end
end
do -- HeightfieldTerrainShape
	local META = {}
	META.__index = META
	function META:SetUseZigzagSubdivision(...)
		lib.btHeightfieldTerrainShape_setUseZigzagSubdivision(self.__ptr, ...)
	end
	function META:SetUseDiamondSubdivision(...)
		lib.btHeightfieldTerrainShape_setUseDiamondSubdivision(self.__ptr, ...)
	end
	function bullet.CreateHeightfieldTerrainShape(...)
		return setmetatable({__ptr = lib.btHeightfieldTerrainShape_new2(...)}, META)
	end
end
do -- SliderConstraint
	local META = {}
	META.__index = META
	function META:SetLowerLinLimit(...)
		lib.btSliderConstraint_setLowerLinLimit(self.__ptr, ...)
	end
	function META:GetUseLinearReferenceFrameA(...)
		lib.btSliderConstraint_getUseLinearReferenceFrameA(self.__ptr, ...)
	end
	function META:GetSoftnessDirAng(...)
		lib.btSliderConstraint_getSoftnessDirAng(self.__ptr, ...)
	end
	function META:GetFrameOffsetA(...)
		lib.btSliderConstraint_getFrameOffsetA(self.__ptr, ...)
	end
	function META:CalculateTransforms(...)
		lib.btSliderConstraint_calculateTransforms(self.__ptr, ...)
	end
	function META:GetInfo1NonVirtual(...)
		lib.btSliderConstraint_getInfo1NonVirtual(self.__ptr, ...)
	end
	function META:SetDampingDirLin(...)
		lib.btSliderConstraint_setDampingDirLin(self.__ptr, ...)
	end
	function META:GetAncorInA(...)
		lib.btSliderConstraint_getAncorInA(self.__ptr, ...)
	end
	function META:GetLinearPos(...)
		lib.btSliderConstraint_getLinearPos(self.__ptr, ...)
	end
	function META:GetRestitutionDirAng(...)
		lib.btSliderConstraint_getRestitutionDirAng(self.__ptr, ...)
	end
	function META:SetDampingDirAng(...)
		lib.btSliderConstraint_setDampingDirAng(self.__ptr, ...)
	end
	function META:GetDampingLimLin(...)
		lib.btSliderConstraint_getDampingLimLin(self.__ptr, ...)
	end
	function META:GetSoftnessOrthoLin(...)
		lib.btSliderConstraint_getSoftnessOrthoLin(self.__ptr, ...)
	end
	function META:GetDampingDirAng(...)
		lib.btSliderConstraint_getDampingDirAng(self.__ptr, ...)
	end
	function META:GetSolveAngLimit(...)
		lib.btSliderConstraint_getSolveAngLimit(self.__ptr, ...)
	end
	function META:GetDampingDirLin(...)
		lib.btSliderConstraint_getDampingDirLin(self.__ptr, ...)
	end
	function META:GetLinDepth(...)
		lib.btSliderConstraint_getLinDepth(self.__ptr, ...)
	end
	function META:SetUseFrameOffset(...)
		lib.btSliderConstraint_setUseFrameOffset(self.__ptr, ...)
	end
	function META:GetSolveLinLimit(...)
		lib.btSliderConstraint_getSolveLinLimit(self.__ptr, ...)
	end
	function META:SetRestitutionOrthoLin(...)
		lib.btSliderConstraint_setRestitutionOrthoLin(self.__ptr, ...)
	end
	function META:SetSoftnessOrthoLin(...)
		lib.btSliderConstraint_setSoftnessOrthoLin(self.__ptr, ...)
	end
	function META:GetMaxLinMotorForce(...)
		lib.btSliderConstraint_getMaxLinMotorForce(self.__ptr, ...)
	end
	function META:SetMaxLinMotorForce(...)
		lib.btSliderConstraint_setMaxLinMotorForce(self.__ptr, ...)
	end
	function META:SetUpperAngLimit(...)
		lib.btSliderConstraint_setUpperAngLimit(self.__ptr, ...)
	end
	function META:SetRestitutionDirLin(...)
		lib.btSliderConstraint_setRestitutionDirLin(self.__ptr, ...)
	end
	function META:GetUpperLinLimit(...)
		lib.btSliderConstraint_getUpperLinLimit(self.__ptr, ...)
	end
	function META:GetInfo2NonVirtual(...)
		lib.btSliderConstraint_getInfo2NonVirtual(self.__ptr, ...)
	end
	function META:GetRestitutionOrthoLin(...)
		lib.btSliderConstraint_getRestitutionOrthoLin(self.__ptr, ...)
	end
	function META:GetTargetAngMotorVelocity(...)
		lib.btSliderConstraint_getTargetAngMotorVelocity(self.__ptr, ...)
	end
	function META:SetFrames(...)
		lib.btSliderConstraint_setFrames(self.__ptr, ...)
	end
	function META:GetAncorInB(...)
		lib.btSliderConstraint_getAncorInB(self.__ptr, ...)
	end
	function META:GetRestitutionLimAng(...)
		lib.btSliderConstraint_getRestitutionLimAng(self.__ptr, ...)
	end
	function META:SetTargetAngMotorVelocity(...)
		lib.btSliderConstraint_setTargetAngMotorVelocity(self.__ptr, ...)
	end
	function META:GetTargetLinMotorVelocity(...)
		lib.btSliderConstraint_getTargetLinMotorVelocity(self.__ptr, ...)
	end
	function META:SetTargetLinMotorVelocity(...)
		lib.btSliderConstraint_setTargetLinMotorVelocity(self.__ptr, ...)
	end
	function META:SetPoweredLinMotor(...)
		lib.btSliderConstraint_setPoweredLinMotor(self.__ptr, ...)
	end
	function META:GetRestitutionLimLin(...)
		lib.btSliderConstraint_getRestitutionLimLin(self.__ptr, ...)
	end
	function META:SetDampingLimLin(...)
		lib.btSliderConstraint_setDampingLimLin(self.__ptr, ...)
	end
	function META:GetAngularPos(...)
		lib.btSliderConstraint_getAngularPos(self.__ptr, ...)
	end
	function META:GetCalculatedTransformA(...)
		lib.btSliderConstraint_getCalculatedTransformA(self.__ptr, ...)
	end
	function META:SetUpperLinLimit(...)
		lib.btSliderConstraint_setUpperLinLimit(self.__ptr, ...)
	end
	function META:TestAngLimits(...)
		lib.btSliderConstraint_testAngLimits(self.__ptr, ...)
	end
	function META:SetSoftnessOrthoAng(...)
		lib.btSliderConstraint_setSoftnessOrthoAng(self.__ptr, ...)
	end
	function META:SetSoftnessLimLin(...)
		lib.btSliderConstraint_setSoftnessLimLin(self.__ptr, ...)
	end
	function META:SetLowerAngLimit(...)
		lib.btSliderConstraint_setLowerAngLimit(self.__ptr, ...)
	end
	function META:GetCalculatedTransformB(...)
		lib.btSliderConstraint_getCalculatedTransformB(self.__ptr, ...)
	end
	function META:SetSoftnessLimAng(...)
		lib.btSliderConstraint_setSoftnessLimAng(self.__ptr, ...)
	end
	function META:SetSoftnessDirLin(...)
		lib.btSliderConstraint_setSoftnessDirLin(self.__ptr, ...)
	end
	function META:SetPoweredAngMotor(...)
		lib.btSliderConstraint_setPoweredAngMotor(self.__ptr, ...)
	end
	function META:SetMaxAngMotorForce(...)
		lib.btSliderConstraint_setMaxAngMotorForce(self.__ptr, ...)
	end
	function META:GetSoftnessDirLin(...)
		lib.btSliderConstraint_getSoftnessDirLin(self.__ptr, ...)
	end
	function META:GetDampingOrthoAng(...)
		lib.btSliderConstraint_getDampingOrthoAng(self.__ptr, ...)
	end
	function META:GetPoweredAngMotor(...)
		lib.btSliderConstraint_getPoweredAngMotor(self.__ptr, ...)
	end
	function META:GetMaxAngMotorForce(...)
		lib.btSliderConstraint_getMaxAngMotorForce(self.__ptr, ...)
	end
	function META:GetAngDepth(...)
		lib.btSliderConstraint_getAngDepth(self.__ptr, ...)
	end
	function META:SetDampingOrthoAng(...)
		lib.btSliderConstraint_setDampingOrthoAng(self.__ptr, ...)
	end
	function META:SetSoftnessDirAng(...)
		lib.btSliderConstraint_setSoftnessDirAng(self.__ptr, ...)
	end
	function META:GetDampingLimAng(...)
		lib.btSliderConstraint_getDampingLimAng(self.__ptr, ...)
	end
	function META:GetLowerLinLimit(...)
		lib.btSliderConstraint_getLowerLinLimit(self.__ptr, ...)
	end
	function META:GetDampingOrthoLin(...)
		lib.btSliderConstraint_getDampingOrthoLin(self.__ptr, ...)
	end
	function META:GetFrameOffsetB(...)
		lib.btSliderConstraint_getFrameOffsetB(self.__ptr, ...)
	end
	function META:GetSoftnessLimLin(...)
		lib.btSliderConstraint_getSoftnessLimLin(self.__ptr, ...)
	end
	function META:GetRestitutionDirLin(...)
		lib.btSliderConstraint_getRestitutionDirLin(self.__ptr, ...)
	end
	function META:GetSoftnessLimAng(...)
		lib.btSliderConstraint_getSoftnessLimAng(self.__ptr, ...)
	end
	function META:SetRestitutionLimLin(...)
		lib.btSliderConstraint_setRestitutionLimLin(self.__ptr, ...)
	end
	function META:GetSoftnessOrthoAng(...)
		lib.btSliderConstraint_getSoftnessOrthoAng(self.__ptr, ...)
	end
	function META:GetLowerAngLimit(...)
		lib.btSliderConstraint_getLowerAngLimit(self.__ptr, ...)
	end
	function META:GetPoweredLinMotor(...)
		lib.btSliderConstraint_getPoweredLinMotor(self.__ptr, ...)
	end
	function META:SetDampingLimAng(...)
		lib.btSliderConstraint_setDampingLimAng(self.__ptr, ...)
	end
	function META:TestLinLimits(...)
		lib.btSliderConstraint_testLinLimits(self.__ptr, ...)
	end
	function META:SetDampingOrthoLin(...)
		lib.btSliderConstraint_setDampingOrthoLin(self.__ptr, ...)
	end
	function META:SetRestitutionOrthoAng(...)
		lib.btSliderConstraint_setRestitutionOrthoAng(self.__ptr, ...)
	end
	function META:GetUpperAngLimit(...)
		lib.btSliderConstraint_getUpperAngLimit(self.__ptr, ...)
	end
	function META:GetUseFrameOffset(...)
		lib.btSliderConstraint_getUseFrameOffset(self.__ptr, ...)
	end
	function META:SetRestitutionDirAng(...)
		lib.btSliderConstraint_setRestitutionDirAng(self.__ptr, ...)
	end
	function META:GetRestitutionOrthoAng(...)
		lib.btSliderConstraint_getRestitutionOrthoAng(self.__ptr, ...)
	end
	function META:SetRestitutionLimAng(...)
		lib.btSliderConstraint_setRestitutionLimAng(self.__ptr, ...)
	end
	function bullet.CreateSliderConstraint(...)
		return setmetatable({__ptr = lib.btSliderConstraint_new2(...)}, META)
	end
end
do -- GIM_PAIR
	local META = {}
	META.__index = META
	function bullet.CreateGIM_PAIR(...)
		return setmetatable({__ptr = lib.GIM_PAIR_new2(...)}, META)
	end
end
do -- Point2PointConstraint
	local META = {}
	META.__index = META
	function META:GetInfo2NonVirtual(...)
		lib.btPoint2PointConstraint_getInfo2NonVirtual(self.__ptr, ...)
	end
	function META:GetUseSolveConstraintObsolete(...)
		lib.btPoint2PointConstraint_getUseSolveConstraintObsolete(self.__ptr, ...)
	end
	function META:GetPivotInA(...)
		lib.btPoint2PointConstraint_getPivotInA(self.__ptr, ...)
	end
	function META:GetInfo1NonVirtual(...)
		lib.btPoint2PointConstraint_getInfo1NonVirtual(self.__ptr, ...)
	end
	function META:UpdateRHS(...)
		lib.btPoint2PointConstraint_updateRHS(self.__ptr, ...)
	end
	function META:GetPivotInB(...)
		lib.btPoint2PointConstraint_getPivotInB(self.__ptr, ...)
	end
	function META:SetPivotA(...)
		lib.btPoint2PointConstraint_setPivotA(self.__ptr, ...)
	end
	function META:SetUseSolveConstraintObsolete(...)
		lib.btPoint2PointConstraint_setUseSolveConstraintObsolete(self.__ptr, ...)
	end
	function META:SetPivotB(...)
		lib.btPoint2PointConstraint_setPivotB(self.__ptr, ...)
	end
	function META:GetSetting(...)
		lib.btPoint2PointConstraint_getSetting(self.__ptr, ...)
	end
	function bullet.CreatePoint2PointConstraint(...)
		return setmetatable({__ptr = lib.btPoint2PointConstraint_new2(...)}, META)
	end
end
do -- TriangleMesh
	local META = {}
	META.__index = META
	function META:AddTriangle(...)
		lib.btTriangleMesh_addTriangle(self.__ptr, ...)
	end
	function META:GetUse4componentVertices(...)
		lib.btTriangleMesh_getUse4componentVertices(self.__ptr, ...)
	end
	function META:FindOrAddVertex(...)
		lib.btTriangleMesh_findOrAddVertex(self.__ptr, ...)
	end
	function META:SetWeldingThreshold(...)
		lib.btTriangleMesh_setWeldingThreshold(self.__ptr, ...)
	end
	function META:AddIndex(...)
		lib.btTriangleMesh_addIndex(self.__ptr, ...)
	end
	function META:GetUse32bitIndices(...)
		lib.btTriangleMesh_getUse32bitIndices(self.__ptr, ...)
	end
	function META:GetNumTriangles(...)
		lib.btTriangleMesh_getNumTriangles(self.__ptr, ...)
	end
	function META:GetWeldingThreshold(...)
		lib.btTriangleMesh_getWeldingThreshold(self.__ptr, ...)
	end
	function bullet.CreateTriangleMesh(...)
		return setmetatable({__ptr = lib.btTriangleMesh_new2(...)}, META)
	end
end
do -- RigidBody
	local META = {}
	META.__index = META
	function META:SaveKinematicState(...)
		lib.btRigidBody_saveKinematicState(self.__ptr, ...)
	end
	function META:GetLinearVelocity(...)
		lib.btRigidBody_getLinearVelocity(self.__ptr, ...)
	end
	function META:SetContactSolverType(...)
		lib.btRigidBody_setContactSolverType(self.__ptr, ...)
	end
	function META:GetVelocityInLocalPoint(...)
		lib.btRigidBody_getVelocityInLocalPoint(self.__ptr, ...)
	end
	function META:ComputeGyroscopicForceExplicit(...)
		lib.btRigidBody_computeGyroscopicForceExplicit(self.__ptr, ...)
	end
	function META:GetCenterOfMassTransform(...)
		lib.btRigidBody_getCenterOfMassTransform(self.__ptr, ...)
	end
	function META:SetCenterOfMassTransform(...)
		lib.btRigidBody_setCenterOfMassTransform(self.__ptr, ...)
	end
	function META:GetLinearFactor(...)
		lib.btRigidBody_getLinearFactor(self.__ptr, ...)
	end
	function META:RemoveConstraintRef(...)
		lib.btRigidBody_removeConstraintRef(self.__ptr, ...)
	end
	function META:GetAabb(...)
		lib.btRigidBody_getAabb(self.__ptr, ...)
	end
	function META:GetAngularVelocity(...)
		lib.btRigidBody_getAngularVelocity(self.__ptr, ...)
	end
	function META:IsInWorld(...)
		lib.btRigidBody_isInWorld(self.__ptr, ...)
	end
	function META:ApplyForce(...)
		lib.btRigidBody_applyForce(self.__ptr, ...)
	end
	function META:ProceedToTransform(...)
		lib.btRigidBody_proceedToTransform(self.__ptr, ...)
	end
	function META:GetBroadphaseProxy(...)
		lib.btRigidBody_getBroadphaseProxy(self.__ptr, ...)
	end
	function META:ApplyCentralForce(...)
		lib.btRigidBody_applyCentralForce(self.__ptr, ...)
	end
	function META:ApplyImpulse(...)
		lib.btRigidBody_applyImpulse(self.__ptr, ...)
	end
	function META:UpdateInertiaTensor(...)
		lib.btRigidBody_updateInertiaTensor(self.__ptr, ...)
	end
	function META:GetConstraintRef(...)
		lib.btRigidBody_getConstraintRef(self.__ptr, ...)
	end
	function META:GetFlags(...)
		lib.btRigidBody_getFlags(self.__ptr, ...)
	end
	function META:ApplyTorque(...)
		lib.btRigidBody_applyTorque(self.__ptr, ...)
	end
	function META:Upcast(...)
		lib.btRigidBody_upcast(self.__ptr, ...)
	end
	function META:GetFrictionSolverType(...)
		lib.btRigidBody_getFrictionSolverType(self.__ptr, ...)
	end
	function META:GetGravity(...)
		lib.btRigidBody_getGravity(self.__ptr, ...)
	end
	function META:ApplyDamping(...)
		lib.btRigidBody_applyDamping(self.__ptr, ...)
	end
	function META:GetAngularDamping(...)
		lib.btRigidBody_getAngularDamping(self.__ptr, ...)
	end
	function META:ApplyGravity(...)
		lib.btRigidBody_applyGravity(self.__ptr, ...)
	end
	function META:SetMassProps(...)
		lib.btRigidBody_setMassProps(self.__ptr, ...)
	end
	function META:SetMotionState(...)
		lib.btRigidBody_setMotionState(self.__ptr, ...)
	end
	function META:SetLinearFactor(...)
		lib.btRigidBody_setLinearFactor(self.__ptr, ...)
	end
	function META:GetTotalForce(...)
		lib.btRigidBody_getTotalForce(self.__ptr, ...)
	end
	function META:SetNewBroadphaseProxy(...)
		lib.btRigidBody_setNewBroadphaseProxy(self.__ptr, ...)
	end
	function META:GetInvInertiaTensorWorld(...)
		lib.btRigidBody_getInvInertiaTensorWorld(self.__ptr, ...)
	end
	function META:IntegrateVelocities(...)
		lib.btRigidBody_integrateVelocities(self.__ptr, ...)
	end
	function META:ApplyCentralImpulse(...)
		lib.btRigidBody_applyCentralImpulse(self.__ptr, ...)
	end
	function META:SetDamping(...)
		lib.btRigidBody_setDamping(self.__ptr, ...)
	end
	function META:WantsSleeping(...)
		lib.btRigidBody_wantsSleeping(self.__ptr, ...)
	end
	function META:GetInvMass(...)
		lib.btRigidBody_getInvMass(self.__ptr, ...)
	end
	function META:SetFrictionSolverType(...)
		lib.btRigidBody_setFrictionSolverType(self.__ptr, ...)
	end
	function META:ClearForces(...)
		lib.btRigidBody_clearForces(self.__ptr, ...)
	end
	function META:ComputeAngularImpulseDenominator(...)
		lib.btRigidBody_computeAngularImpulseDenominator(self.__ptr, ...)
	end
	function META:GetLinearSleepingThreshold(...)
		lib.btRigidBody_getLinearSleepingThreshold(self.__ptr, ...)
	end
	function META:ComputeImpulseDenominator(...)
		lib.btRigidBody_computeImpulseDenominator(self.__ptr, ...)
	end
	function META:GetOrientation(...)
		lib.btRigidBody_getOrientation(self.__ptr, ...)
	end
	function META:GetAngularFactor(...)
		lib.btRigidBody_getAngularFactor(self.__ptr, ...)
	end
	function META:GetCenterOfMassPosition(...)
		lib.btRigidBody_getCenterOfMassPosition(self.__ptr, ...)
	end
	function META:GetAngularSleepingThreshold(...)
		lib.btRigidBody_getAngularSleepingThreshold(self.__ptr, ...)
	end
	function META:AddConstraintRef(...)
		lib.btRigidBody_addConstraintRef(self.__ptr, ...)
	end
	function META:ApplyTorqueImpulse(...)
		lib.btRigidBody_applyTorqueImpulse(self.__ptr, ...)
	end
	function META:SetGravity(...)
		lib.btRigidBody_setGravity(self.__ptr, ...)
	end
	function META:GetInvInertiaDiagLocal(...)
		lib.btRigidBody_getInvInertiaDiagLocal(self.__ptr, ...)
	end
	function META:GetNumConstraintRefs(...)
		lib.btRigidBody_getNumConstraintRefs(self.__ptr, ...)
	end
	function META:GetLocalInertia(...)
		lib.btRigidBody_getLocalInertia(self.__ptr, ...)
	end
	function META:GetMotionState(...)
		lib.btRigidBody_getMotionState(self.__ptr, ...)
	end
	function META:Translate(...)
		lib.btRigidBody_translate(self.__ptr, ...)
	end
	function META:GetLinearDamping(...)
		lib.btRigidBody_getLinearDamping(self.__ptr, ...)
	end
	function META:GetTotalTorque(...)
		lib.btRigidBody_getTotalTorque(self.__ptr, ...)
	end
	function META:PredictIntegratedTransform(...)
		lib.btRigidBody_predictIntegratedTransform(self.__ptr, ...)
	end
	function META:GetContactSolverType(...)
		lib.btRigidBody_getContactSolverType(self.__ptr, ...)
	end
	function META:SetAngularVelocity(...)
		lib.btRigidBody_setAngularVelocity(self.__ptr, ...)
	end
	function META:SetInvInertiaDiagLocal(...)
		lib.btRigidBody_setInvInertiaDiagLocal(self.__ptr, ...)
	end
	function META:SetFlags(...)
		lib.btRigidBody_setFlags(self.__ptr, ...)
	end
	function META:SetLinearVelocity(...)
		lib.btRigidBody_setLinearVelocity(self.__ptr, ...)
	end
	function META:UpdateDeactivation(...)
		lib.btRigidBody_updateDeactivation(self.__ptr, ...)
	end
	function META:SetAngularFactor(...)
		lib.btRigidBody_setAngularFactor(self.__ptr, ...)
	end
	function META:SetSleepingThresholds(...)
		lib.btRigidBody_setSleepingThresholds(self.__ptr, ...)
	end
	function bullet.CreateRigidBody(...)
		return setmetatable({__ptr = lib.btRigidBody_new2(...)}, META)
	end
end
do -- 32BitAxisSweep3
	local META = {}
	META.__index = META
	function META:AddHandle(...)
		lib.bt32BitAxisSweep3_addHandle(self.__ptr, ...)
	end
	function META:Quantize(...)
		lib.bt32BitAxisSweep3_quantize(self.__ptr, ...)
	end
	function META:TestAabbOverlap(...)
		lib.bt32BitAxisSweep3_testAabbOverlap(self.__ptr, ...)
	end
	function META:GetNumHandles(...)
		lib.bt32BitAxisSweep3_getNumHandles(self.__ptr, ...)
	end
	function META:UnQuantize(...)
		lib.bt32BitAxisSweep3_unQuantize(self.__ptr, ...)
	end
	function META:RemoveHandle(...)
		lib.bt32BitAxisSweep3_removeHandle(self.__ptr, ...)
	end
	function META:SetOverlappingPairUserCallback(...)
		lib.bt32BitAxisSweep3_setOverlappingPairUserCallback(self.__ptr, ...)
	end
	function META:GetHandle(...)
		lib.bt32BitAxisSweep3_getHandle(self.__ptr, ...)
	end
	function META:ProcessAllOverlappingPairs(...)
		lib.bt32BitAxisSweep3_processAllOverlappingPairs(self.__ptr, ...)
	end
	function META:UpdateHandle(...)
		lib.bt32BitAxisSweep3_updateHandle(self.__ptr, ...)
	end
	function META:GetOverlappingPairCache(...)
		lib.bt32BitAxisSweep3_getOverlappingPairCache(self.__ptr, ...)
	end
	function bullet.Create32BitAxisSweep3(...)
		return setmetatable({__ptr = lib.bt32BitAxisSweep3_new2(...)}, META)
	end
end
do -- GjkPairDetector
	local META = {}
	META.__index = META
	function META:GetLastUsedMethod(...)
		lib.btGjkPairDetector_getLastUsedMethod(self.__ptr, ...)
	end
	function META:GetClosestPointsNonVirtual(...)
		lib.btGjkPairDetector_getClosestPointsNonVirtual(self.__ptr, ...)
	end
	function META:SetMinkowskiA(...)
		lib.btGjkPairDetector_setMinkowskiA(self.__ptr, ...)
	end
	function META:GetCurIter(...)
		lib.btGjkPairDetector_getCurIter(self.__ptr, ...)
	end
	function META:SetIgnoreMargin(...)
		lib.btGjkPairDetector_setIgnoreMargin(self.__ptr, ...)
	end
	function META:SetCurIter(...)
		lib.btGjkPairDetector_setCurIter(self.__ptr, ...)
	end
	function META:SetLastUsedMethod(...)
		lib.btGjkPairDetector_setLastUsedMethod(self.__ptr, ...)
	end
	function META:GetCachedSeparatingAxis(...)
		lib.btGjkPairDetector_getCachedSeparatingAxis(self.__ptr, ...)
	end
	function META:GetFixContactNormalDirection(...)
		lib.btGjkPairDetector_getFixContactNormalDirection(self.__ptr, ...)
	end
	function META:GetCachedSeparatingDistance(...)
		lib.btGjkPairDetector_getCachedSeparatingDistance(self.__ptr, ...)
	end
	function META:SetMinkowskiB(...)
		lib.btGjkPairDetector_setMinkowskiB(self.__ptr, ...)
	end
	function META:SetFixContactNormalDirection(...)
		lib.btGjkPairDetector_setFixContactNormalDirection(self.__ptr, ...)
	end
	function META:SetPenetrationDepthSolver(...)
		lib.btGjkPairDetector_setPenetrationDepthSolver(self.__ptr, ...)
	end
	function META:GetCatchDegeneracies(...)
		lib.btGjkPairDetector_getCatchDegeneracies(self.__ptr, ...)
	end
	function META:SetCachedSeparatingAxis(...)
		lib.btGjkPairDetector_setCachedSeparatingAxis(self.__ptr, ...)
	end
	function META:SetCatchDegeneracies(...)
		lib.btGjkPairDetector_setCatchDegeneracies(self.__ptr, ...)
	end
	function META:GetDegenerateSimplex(...)
		lib.btGjkPairDetector_getDegenerateSimplex(self.__ptr, ...)
	end
	function META:SetDegenerateSimplex(...)
		lib.btGjkPairDetector_setDegenerateSimplex(self.__ptr, ...)
	end
	function bullet.CreateGjkPairDetector(...)
		return setmetatable({__ptr = lib.btGjkPairDetector_new2(...)}, META)
	end
end
do -- TriangleIndexVertexArray
	local META = {}
	META.__index = META
	function META:GetIndexedMeshArray(...)
		lib.btTriangleIndexVertexArray_getIndexedMeshArray(self.__ptr, ...)
	end
	function META:AddIndexedMesh(...)
		lib.btTriangleIndexVertexArray_addIndexedMesh(self.__ptr, ...)
	end
	function bullet.CreateTriangleIndexVertexArray(...)
		return setmetatable({__ptr = lib.btTriangleIndexVertexArray_new2(...)}, META)
	end
end
do -- BroadphasePair
	local META = {}
	META.__index = META
	function META:SetPProxy(...)
		lib.btBroadphasePair_setPProxy0(self.__ptr, ...)
	end
	function META:Delete(...)
		lib.btBroadphasePair_delete(self.__ptr, ...)
	end
	function META:GetAlgorithm(...)
		lib.btBroadphasePair_getAlgorithm(self.__ptr, ...)
	end
	function META:SetAlgorithm(...)
		lib.btBroadphasePair_setAlgorithm(self.__ptr, ...)
	end
	function META:GetPProxy(...)
		lib.btBroadphasePair_getPProxy0(self.__ptr, ...)
	end
	function bullet.CreateBroadphasePair(...)
		return setmetatable({__ptr = lib.btBroadphasePair_new2(...)}, META)
	end
end
do -- GImpactCompoundShape_CompoundPrimitiveManager
	local META = {}
	META.__index = META
	function META:GetCompoundShape(...)
		lib.btGImpactCompoundShape_CompoundPrimitiveManager_getCompoundShape(self.__ptr, ...)
	end
	function META:SetCompoundShape(...)
		lib.btGImpactCompoundShape_CompoundPrimitiveManager_setCompoundShape(self.__ptr, ...)
	end
	function bullet.CreateGImpactCompoundShape_CompoundPrimitiveManager(...)
		return setmetatable({__ptr = lib.btGImpactCompoundShape_CompoundPrimitiveManager_new2(...)}, META)
	end
end
do -- PolarDecomposition
	local META = {}
	META.__index = META
	function META:MaxIterations(...)
		lib.btPolarDecomposition_maxIterations(self.__ptr, ...)
	end
	function META:Delete(...)
		lib.btPolarDecomposition_delete(self.__ptr, ...)
	end
	function META:Decompose(...)
		lib.btPolarDecomposition_decompose(self.__ptr, ...)
	end
	function bullet.CreatePolarDecomposition(...)
		return setmetatable({__ptr = lib.btPolarDecomposition_new2(...)}, META)
	end
end
do -- Box2dBox2dCollisionAlgorithm
	local META = {}
	META.__index = META
	function bullet.CreateBox2dBox2dCollisionAlgorithm(...)
		return setmetatable({__ptr = lib.btBox2dBox2dCollisionAlgorithm_new2(...)}, META)
	end
end
do -- ManifoldPoint
	local META = {}
	META.__index = META
	function META:SetLateralFrictionInitialized(...)
		lib.btManifoldPoint_setLateralFrictionInitialized(self.__ptr, ...)
	end
	function META:GetDistance(...)
		lib.btManifoldPoint_getDistance(self.__ptr, ...)
	end
	function META:GetLocalPointB(...)
		lib.btManifoldPoint_getLocalPointB(self.__ptr, ...)
	end
	function META:GetPartId(...)
		lib.btManifoldPoint_getPartId0(self.__ptr, ...)
	end
	function META:GetCombinedRestitution(...)
		lib.btManifoldPoint_getCombinedRestitution(self.__ptr, ...)
	end
	function META:GetLateralFrictionDir(...)
		lib.btManifoldPoint_getLateralFrictionDir1(self.__ptr, ...)
	end
	function META:SetAppliedImpulse(...)
		lib.btManifoldPoint_setAppliedImpulse(self.__ptr, ...)
	end
	function META:GetLifeTime(...)
		lib.btManifoldPoint_getLifeTime(self.__ptr, ...)
	end
	function META:SetUserPersistentData(...)
		lib.btManifoldPoint_setUserPersistentData(self.__ptr, ...)
	end
	function META:SetNormalWorldOnB(...)
		lib.btManifoldPoint_setNormalWorldOnB(self.__ptr, ...)
	end
	function META:GetContactMotion(...)
		lib.btManifoldPoint_getContactMotion1(self.__ptr, ...)
	end
	function META:SetLateralFrictionDir(...)
		lib.btManifoldPoint_setLateralFrictionDir1(self.__ptr, ...)
	end
	function META:SetPositionWorldOnB(...)
		lib.btManifoldPoint_setPositionWorldOnB(self.__ptr, ...)
	end
	function META:GetContactCFM(...)
		lib.btManifoldPoint_getContactCFM1(self.__ptr, ...)
	end
	function META:SetAppliedImpulseLateral(...)
		lib.btManifoldPoint_setAppliedImpulseLateral1(self.__ptr, ...)
	end
	function META:GetUserPersistentData(...)
		lib.btManifoldPoint_getUserPersistentData(self.__ptr, ...)
	end
	function META:Delete(...)
		lib.btManifoldPoint_delete(self.__ptr, ...)
	end
	function META:SetPositionWorldOnA(...)
		lib.btManifoldPoint_setPositionWorldOnA(self.__ptr, ...)
	end
	function META:GetIndex(...)
		lib.btManifoldPoint_getIndex0(self.__ptr, ...)
	end
	function META:SetLifeTime(...)
		lib.btManifoldPoint_setLifeTime(self.__ptr, ...)
	end
	function META:SetContactCFM(...)
		lib.btManifoldPoint_setContactCFM1(self.__ptr, ...)
	end
	function META:GetPositionWorldOnB(...)
		lib.btManifoldPoint_getPositionWorldOnB(self.__ptr, ...)
	end
	function META:SetCombinedRestitution(...)
		lib.btManifoldPoint_setCombinedRestitution(self.__ptr, ...)
	end
	function META:SetCombinedRollingFriction(...)
		lib.btManifoldPoint_setCombinedRollingFriction(self.__ptr, ...)
	end
	function META:SetLocalPointA(...)
		lib.btManifoldPoint_setLocalPointA(self.__ptr, ...)
	end
	function META:GetCombinedFriction(...)
		lib.btManifoldPoint_getCombinedFriction(self.__ptr, ...)
	end
	function META:GetLocalPointA(...)
		lib.btManifoldPoint_getLocalPointA(self.__ptr, ...)
	end
	function META:GetLateralFrictionInitialized(...)
		lib.btManifoldPoint_getLateralFrictionInitialized(self.__ptr, ...)
	end
	function META:SetPartId(...)
		lib.btManifoldPoint_setPartId0(self.__ptr, ...)
	end
	function META:GetAppliedImpulseLateral(...)
		lib.btManifoldPoint_getAppliedImpulseLateral1(self.__ptr, ...)
	end
	function META:GetAppliedImpulse(...)
		lib.btManifoldPoint_getAppliedImpulse(self.__ptr, ...)
	end
	function META:GetNormalWorldOnB(...)
		lib.btManifoldPoint_getNormalWorldOnB(self.__ptr, ...)
	end
	function META:GetPositionWorldOnA(...)
		lib.btManifoldPoint_getPositionWorldOnA(self.__ptr, ...)
	end
	function META:SetContactMotion(...)
		lib.btManifoldPoint_setContactMotion1(self.__ptr, ...)
	end
	function META:SetLocalPointB(...)
		lib.btManifoldPoint_setLocalPointB(self.__ptr, ...)
	end
	function META:GetCombinedRollingFriction(...)
		lib.btManifoldPoint_getCombinedRollingFriction(self.__ptr, ...)
	end
	function META:SetCombinedFriction(...)
		lib.btManifoldPoint_setCombinedFriction(self.__ptr, ...)
	end
	function META:SetIndex(...)
		lib.btManifoldPoint_setIndex0(self.__ptr, ...)
	end
	function META:SetDistance(...)
		lib.btManifoldPoint_setDistance(self.__ptr, ...)
	end
	function bullet.CreateManifoldPoint(...)
		return setmetatable({__ptr = lib.btManifoldPoint_new2(...)}, META)
	end
end
do -- GImpactMeshShapePart_TrimeshPrimitiveManager
	local META = {}
	META.__index = META
	function META:GetPart(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_getPart(self.__ptr, ...)
	end
	function META:GetIndicestype(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_getIndicestype(self.__ptr, ...)
	end
	function META:SetScale(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_setScale(self.__ptr, ...)
	end
	function META:GetMargin(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_getMargin(self.__ptr, ...)
	end
	function META:GetType(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_getType(self.__ptr, ...)
	end
	function META:GetScale(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_getScale(self.__ptr, ...)
	end
	function META:GetIndexbase(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_getIndexbase(self.__ptr, ...)
	end
	function META:SetNumfaces(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_setNumfaces(self.__ptr, ...)
	end
	function META:SetMargin(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_setMargin(self.__ptr, ...)
	end
	function META:GetVertexbase(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_getVertexbase(self.__ptr, ...)
	end
	function META:SetVertexbase(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_setVertexbase(self.__ptr, ...)
	end
	function META:SetMeshInterface(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_setMeshInterface(self.__ptr, ...)
	end
	function META:SetType(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_setType(self.__ptr, ...)
	end
	function META:GetIndexstride(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_getIndexstride(self.__ptr, ...)
	end
	function META:GetStride(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_getStride(self.__ptr, ...)
	end
	function META:SetIndexbase(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_setIndexbase(self.__ptr, ...)
	end
	function META:SetStride(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_setStride(self.__ptr, ...)
	end
	function META:SetPart(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_setPart(self.__ptr, ...)
	end
	function META:SetNumverts(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_setNumverts(self.__ptr, ...)
	end
	function META:Unlock(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_unlock(self.__ptr, ...)
	end
	function META:GetNumfaces(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_getNumfaces(self.__ptr, ...)
	end
	function META:GetNumverts(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_getNumverts(self.__ptr, ...)
	end
	function META:Lock(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_lock(self.__ptr, ...)
	end
	function META:GetMeshInterface(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_getMeshInterface(self.__ptr, ...)
	end
	function META:SetIndicestype(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_setIndicestype(self.__ptr, ...)
	end
	function META:SetIndexstride(...)
		lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_setIndexstride(self.__ptr, ...)
	end
	function bullet.CreateGImpactMeshShapePart_TrimeshPrimitiveManager(...)
		return setmetatable({__ptr = lib.btGImpactMeshShapePart_TrimeshPrimitiveManager_new2(...)}, META)
	end
end
do -- CylinderShapeX
	local META = {}
	META.__index = META
	function bullet.CreateCylinderShapeX(...)
		return setmetatable({__ptr = lib.btCylinderShapeX_new2(...)}, META)
	end
end
do -- SoftBody
	local META = {}
	META.__index = META
	function META:SetBUpdateRtCst(...)
		lib.btSoftBody_setBUpdateRtCst(self.__ptr, ...)
	end
	function META:GetVolume(...)
		lib.btSoftBody_getVolume(self.__ptr, ...)
	end
	function META:AppendTetra(...)
		lib.btSoftBody_appendTetra(self.__ptr, ...)
	end
	function META:ClusterCount(...)
		lib.btSoftBody_clusterCount(self.__ptr, ...)
	end
	function META:GetRestLengthScale(...)
		lib.btSoftBody_getRestLengthScale(self.__ptr, ...)
	end
	function META:GetAnchors(...)
		lib.btSoftBody_getAnchors(self.__ptr, ...)
	end
	function META:GetNodes(...)
		lib.btSoftBody_getNodes(self.__ptr, ...)
	end
	function META:ClusterVelocity(...)
		lib.btSoftBody_clusterVelocity(self.__ptr, ...)
	end
	function META:GetFaces(...)
		lib.btSoftBody_getFaces(self.__ptr, ...)
	end
	function META:SetInitialWorldTransform(...)
		lib.btSoftBody_setInitialWorldTransform(self.__ptr, ...)
	end
	function META:DampClusters(...)
		lib.btSoftBody_dampClusters(self.__ptr, ...)
	end
	function META:GetNotes(...)
		lib.btSoftBody_getNotes(self.__ptr, ...)
	end
	function META:GetTetraVertexNormalData(...)
		lib.btSoftBody_getTetraVertexNormalData(self.__ptr, ...)
	end
	function META:ClusterDCImpulse(...)
		lib.btSoftBody_clusterDCImpulse(self.__ptr, ...)
	end
	function META:GetAabb(...)
		lib.btSoftBody_getAabb(self.__ptr, ...)
	end
	function META:GetTetraVertexData(...)
		lib.btSoftBody_getTetraVertexData(self.__ptr, ...)
	end
	function META:GenerateClusters(...)
		lib.btSoftBody_generateClusters(self.__ptr, ...)
	end
	function META:SetSoftBodySolver(...)
		lib.btSoftBody_setSoftBodySolver(self.__ptr, ...)
	end
	function META:GetLinkVertexNormalData(...)
		lib.btSoftBody_getLinkVertexNormalData(self.__ptr, ...)
	end
	function META:GetLinkVertexData(...)
		lib.btSoftBody_getLinkVertexData(self.__ptr, ...)
	end
	function META:GetWorldInfo(...)
		lib.btSoftBody_getWorldInfo(self.__ptr, ...)
	end
	function META:SetVolumeDensity(...)
		lib.btSoftBody_setVolumeDensity(self.__ptr, ...)
	end
	function META:Rotate(...)
		lib.btSoftBody_rotate(self.__ptr, ...)
	end
	function META:UpdateBounds(...)
		lib.btSoftBody_updateBounds(self.__ptr, ...)
	end
	function META:CheckFace(...)
		lib.btSoftBody_checkFace(self.__ptr, ...)
	end
	function META:GetPose(...)
		lib.btSoftBody_getPose(self.__ptr, ...)
	end
	function META:UpdatePose(...)
		lib.btSoftBody_updatePose(self.__ptr, ...)
	end
	function META:GetJoints(...)
		lib.btSoftBody_getJoints(self.__ptr, ...)
	end
	function META:UpdateNormals(...)
		lib.btSoftBody_updateNormals(self.__ptr, ...)
	end
	function META:GetLinks(...)
		lib.btSoftBody_getLinks(self.__ptr, ...)
	end
	function META:GetClusterConnectivity(...)
		lib.btSoftBody_getClusterConnectivity(self.__ptr, ...)
	end
	function META:GetWindVelocity(...)
		lib.btSoftBody_getWindVelocity(self.__ptr, ...)
	end
	function META:UpdateConstants(...)
		lib.btSoftBody_updateConstants(self.__ptr, ...)
	end
	function META:ClusterDImpulse(...)
		lib.btSoftBody_clusterDImpulse(self.__ptr, ...)
	end
	function META:GetMass(...)
		lib.btSoftBody_getMass(self.__ptr, ...)
	end
	function META:AddForce(...)
		lib.btSoftBody_addForce(self.__ptr, ...)
	end
	function META:GetFaceVertexNormalData(...)
		lib.btSoftBody_getFaceVertexNormalData(self.__ptr, ...)
	end
	function META:RandomizeConstraints(...)
		lib.btSoftBody_randomizeConstraints(self.__ptr, ...)
	end
	function META:ApplyClusters(...)
		lib.btSoftBody_applyClusters(self.__ptr, ...)
	end
	function META:UpdateArea(...)
		lib.btSoftBody_updateArea(self.__ptr, ...)
	end
	function META:Upcast(...)
		lib.btSoftBody_upcast(self.__ptr, ...)
	end
	function META:AppendLinearJoint(...)
		lib.btSoftBody_appendLinearJoint(self.__ptr, ...)
	end
	function META:GetBounds(...)
		lib.btSoftBody_getBounds(self.__ptr, ...)
	end
	function META:Transform(...)
		lib.btSoftBody_transform(self.__ptr, ...)
	end
	function META:RayTest(...)
		lib.btSoftBody_rayTest(self.__ptr, ...)
	end
	function META:InitDefaults(...)
		lib.btSoftBody_initDefaults(self.__ptr, ...)
	end
	function META:GetSoftBodySolver(...)
		lib.btSoftBody_getSoftBodySolver(self.__ptr, ...)
	end
	function META:StaticSolve(...)
		lib.btSoftBody_staticSolve(self.__ptr, ...)
	end
	function META:IndicesToPointers(...)
		lib.btSoftBody_indicesToPointers(self.__ptr, ...)
	end
	function META:GenerateBendingConstraints(...)
		lib.btSoftBody_generateBendingConstraints(self.__ptr, ...)
	end
	function META:GetCollisionDisabledObjects(...)
		lib.btSoftBody_getCollisionDisabledObjects(self.__ptr, ...)
	end
	function META:CleanupClusters(...)
		lib.btSoftBody_cleanupClusters(self.__ptr, ...)
	end
	function META:GetTetras(...)
		lib.btSoftBody_getTetras(self.__ptr, ...)
	end
	function META:SolveCommonConstraints(...)
		lib.btSoftBody_solveCommonConstraints(self.__ptr, ...)
	end
	function META:SolveClusters(...)
		lib.btSoftBody_solveClusters(self.__ptr, ...)
	end
	function META:ClusterImpulse(...)
		lib.btSoftBody_clusterImpulse(self.__ptr, ...)
	end
	function META:UpdateLinkConstants(...)
		lib.btSoftBody_updateLinkConstants(self.__ptr, ...)
	end
	function META:DefaultCollisionHandler(...)
		lib.btSoftBody_defaultCollisionHandler(self.__ptr, ...)
	end
	function META:GetTotalMass(...)
		lib.btSoftBody_getTotalMass(self.__ptr, ...)
	end
	function META:ReleaseCluster(...)
		lib.btSoftBody_releaseCluster(self.__ptr, ...)
	end
	function META:AddAeroForceToNode(...)
		lib.btSoftBody_addAeroForceToNode(self.__ptr, ...)
	end
	function META:ClusterCom(...)
		lib.btSoftBody_clusterCom(self.__ptr, ...)
	end
	function META:SetWindVelocity(...)
		lib.btSoftBody_setWindVelocity(self.__ptr, ...)
	end
	function META:SetVelocity(...)
		lib.btSoftBody_setVelocity(self.__ptr, ...)
	end
	function META:GetSolver(...)
		lib.btSoftBody_getSolver(self.__ptr, ...)
	end
	function META:ReleaseClusters(...)
		lib.btSoftBody_releaseClusters(self.__ptr, ...)
	end
	function META:ClusterVAImpulse(...)
		lib.btSoftBody_clusterVAImpulse(self.__ptr, ...)
	end
	function META:SetTimeacc(...)
		lib.btSoftBody_setTimeacc(self.__ptr, ...)
	end
	function META:PointersToIndices(...)
		lib.btSoftBody_pointersToIndices(self.__ptr, ...)
	end
	function META:SetSolver(...)
		lib.btSoftBody_setSolver(self.__ptr, ...)
	end
	function META:AddVelocity(...)
		lib.btSoftBody_addVelocity(self.__ptr, ...)
	end
	function META:GetSst(...)
		lib.btSoftBody_getSst(self.__ptr, ...)
	end
	function META:ClusterVImpulse(...)
		lib.btSoftBody_clusterVImpulse(self.__ptr, ...)
	end
	function META:SetRestLengthScale(...)
		lib.btSoftBody_setRestLengthScale(self.__ptr, ...)
	end
	function META:GetScontacts(...)
		lib.btSoftBody_getScontacts(self.__ptr, ...)
	end
	function META:SetPose(...)
		lib.btSoftBody_setPose(self.__ptr, ...)
	end
	function META:GetRcontacts(...)
		lib.btSoftBody_getRcontacts(self.__ptr, ...)
	end
	function META:SetNdbvt(...)
		lib.btSoftBody_setNdbvt(self.__ptr, ...)
	end
	function META:SetMass(...)
		lib.btSoftBody_setMass(self.__ptr, ...)
	end
	function META:Scale(...)
		lib.btSoftBody_scale(self.__ptr, ...)
	end
	function META:ResetLinkRestLengths(...)
		lib.btSoftBody_resetLinkRestLengths(self.__ptr, ...)
	end
	function META:SetTotalDensity(...)
		lib.btSoftBody_setTotalDensity(self.__ptr, ...)
	end
	function META:PredictMotion(...)
		lib.btSoftBody_predictMotion(self.__ptr, ...)
	end
	function META:Refine(...)
		lib.btSoftBody_refine(self.__ptr, ...)
	end
	function META:CutLink(...)
		lib.btSoftBody_cutLink(self.__ptr, ...)
	end
	function META:AppendAngularJoint(...)
		lib.btSoftBody_appendAngularJoint(self.__ptr, ...)
	end
	function META:AppendLink(...)
		lib.btSoftBody_appendLink(self.__ptr, ...)
	end
	function META:AddAeroForceToFace(...)
		lib.btSoftBody_addAeroForceToFace(self.__ptr, ...)
	end
	function META:InitializeClusters(...)
		lib.btSoftBody_initializeClusters(self.__ptr, ...)
	end
	function META:SetTag(...)
		lib.btSoftBody_setTag(self.__ptr, ...)
	end
	function META:ApplyForces(...)
		lib.btSoftBody_applyForces(self.__ptr, ...)
	end
	function META:IntegrateMotion(...)
		lib.btSoftBody_integrateMotion(self.__ptr, ...)
	end
	function META:GetClusters(...)
		lib.btSoftBody_getClusters(self.__ptr, ...)
	end
	function META:InitializeFaceTree(...)
		lib.btSoftBody_initializeFaceTree(self.__ptr, ...)
	end
	function META:GetTimeacc(...)
		lib.btSoftBody_getTimeacc(self.__ptr, ...)
	end
	function META:PrepareClusters(...)
		lib.btSoftBody_prepareClusters(self.__ptr, ...)
	end
	function META:SetWorldInfo(...)
		lib.btSoftBody_setWorldInfo(self.__ptr, ...)
	end
	function META:GetUserIndexMapping(...)
		lib.btSoftBody_getUserIndexMapping(self.__ptr, ...)
	end
	function META:AppendNote(...)
		lib.btSoftBody_appendNote(self.__ptr, ...)
	end
	function META:AppendMaterial(...)
		lib.btSoftBody_appendMaterial(self.__ptr, ...)
	end
	function META:ClusterAImpulse(...)
		lib.btSoftBody_clusterAImpulse(self.__ptr, ...)
	end
	function META:UpdateClusters(...)
		lib.btSoftBody_updateClusters(self.__ptr, ...)
	end
	function META:GetBUpdateRtCst(...)
		lib.btSoftBody_getBUpdateRtCst(self.__ptr, ...)
	end
	function META:GetFaceVertexData(...)
		lib.btSoftBody_getFaceVertexData(self.__ptr, ...)
	end
	function META:GetFdbvt(...)
		lib.btSoftBody_getFdbvt(self.__ptr, ...)
	end
	function META:GetNdbvt(...)
		lib.btSoftBody_getNdbvt(self.__ptr, ...)
	end
	function META:AppendNode(...)
		lib.btSoftBody_appendNode(self.__ptr, ...)
	end
	function META:ClusterDAImpulse(...)
		lib.btSoftBody_clusterDAImpulse(self.__ptr, ...)
	end
	function META:CheckLink(...)
		lib.btSoftBody_checkLink(self.__ptr, ...)
	end
	function META:AppendAnchor(...)
		lib.btSoftBody_appendAnchor(self.__ptr, ...)
	end
	function META:Translate(...)
		lib.btSoftBody_translate(self.__ptr, ...)
	end
	function META:GetCdbvt(...)
		lib.btSoftBody_getCdbvt(self.__ptr, ...)
	end
	function META:AppendFace(...)
		lib.btSoftBody_appendFace(self.__ptr, ...)
	end
	function META:GetCfg(...)
		lib.btSoftBody_getCfg(self.__ptr, ...)
	end
	function META:SolveConstraints(...)
		lib.btSoftBody_solveConstraints(self.__ptr, ...)
	end
	function META:CheckContact(...)
		lib.btSoftBody_checkContact(self.__ptr, ...)
	end
	function META:SetVolumeMass(...)
		lib.btSoftBody_setVolumeMass(self.__ptr, ...)
	end
	function META:GetInitialWorldTransform(...)
		lib.btSoftBody_getInitialWorldTransform(self.__ptr, ...)
	end
	function META:SetTotalMass(...)
		lib.btSoftBody_setTotalMass(self.__ptr, ...)
	end
	function META:EvaluateCom(...)
		lib.btSoftBody_evaluateCom(self.__ptr, ...)
	end
	function META:GetMaterials(...)
		lib.btSoftBody_getMaterials(self.__ptr, ...)
	end
	function META:GetTag(...)
		lib.btSoftBody_getTag(self.__ptr, ...)
	end
	function bullet.CreateSoftBody(...)
		return setmetatable({__ptr = lib.btSoftBody_new2(...)}, META)
	end
end
do -- CylinderShape
	local META = {}
	META.__index = META
	function META:GetUpAxis(...)
		lib.btCylinderShape_getUpAxis(self.__ptr, ...)
	end
	function META:GetRadius(...)
		lib.btCylinderShape_getRadius(self.__ptr, ...)
	end
	function META:GetHalfExtentsWithMargin(...)
		lib.btCylinderShape_getHalfExtentsWithMargin(self.__ptr, ...)
	end
	function META:GetHalfExtentsWithoutMargin(...)
		lib.btCylinderShape_getHalfExtentsWithoutMargin(self.__ptr, ...)
	end
	function bullet.CreateCylinderShape(...)
		return setmetatable({__ptr = lib.btCylinderShape_new2(...)}, META)
	end
end
do -- SoftRigidDynamicsWorld
	local META = {}
	META.__index = META
	function META:GetWorldInfo(...)
		lib.btSoftRigidDynamicsWorld_getWorldInfo(self.__ptr, ...)
	end
	function META:SetDrawFlags(...)
		lib.btSoftRigidDynamicsWorld_setDrawFlags(self.__ptr, ...)
	end
	function META:GetSoftBodyArray(...)
		lib.btSoftRigidDynamicsWorld_getSoftBodyArray(self.__ptr, ...)
	end
	function META:AddSoftBody(...)
		lib.btSoftRigidDynamicsWorld_addSoftBody(self.__ptr, ...)
	end
	function META:GetDrawFlags(...)
		lib.btSoftRigidDynamicsWorld_getDrawFlags(self.__ptr, ...)
	end
	function META:RemoveSoftBody(...)
		lib.btSoftRigidDynamicsWorld_removeSoftBody(self.__ptr, ...)
	end
	function bullet.CreateSoftRigidDynamicsWorld(...)
		return setmetatable({__ptr = lib.btSoftRigidDynamicsWorld_new2(...)}, META)
	end
end
do -- BU_Simplex1to4
	local META = {}
	META.__index = META
	function META:GetIndex(...)
		lib.btBU_Simplex1to4_getIndex(self.__ptr, ...)
	end
	function META:AddVertex(...)
		lib.btBU_Simplex1to4_addVertex(self.__ptr, ...)
	end
	function META:Reset(...)
		lib.btBU_Simplex1to4_reset(self.__ptr, ...)
	end
	function bullet.CreateBU_Simplex1to4(...)
		return setmetatable({__ptr = lib.btBU_Simplex1to4_new2(...)}, META)
	end
end
do -- BoxShape
	local META = {}
	META.__index = META
	function META:GetPlaneEquation(...)
		lib.btBoxShape_getPlaneEquation(self.__ptr, ...)
	end
	function META:GetHalfExtentsWithMargin(...)
		lib.btBoxShape_getHalfExtentsWithMargin(self.__ptr, ...)
	end
	function META:GetHalfExtentsWithoutMargin(...)
		lib.btBoxShape_getHalfExtentsWithoutMargin(self.__ptr, ...)
	end
	function bullet.CreateBoxShape(...)
		return setmetatable({__ptr = lib.btBoxShape_new2(...)}, META)
	end
end
do -- SphereSphereCollisionAlgorithm
	local META = {}
	META.__index = META
	function bullet.CreateSphereSphereCollisionAlgorithm(...)
		return setmetatable({__ptr = lib.btSphereSphereCollisionAlgorithm_new2(...)}, META)
	end
end
do -- GImpactCompoundShape
	local META = {}
	META.__index = META
	function META:AddChildShape(...)
		lib.btGImpactCompoundShape_addChildShape(self.__ptr, ...)
	end
	function META:GetCompoundPrimitiveManager(...)
		lib.btGImpactCompoundShape_getCompoundPrimitiveManager(self.__ptr, ...)
	end
	function bullet.CreateGImpactCompoundShape(...)
		return setmetatable({__ptr = lib.btGImpactCompoundShape_new2(...)}, META)
	end
end
do -- TranslationalLimitMotor2
	local META = {}
	META.__index = META
	function META:SetTargetVelocity(...)
		lib.btTranslationalLimitMotor2_setTargetVelocity(self.__ptr, ...)
	end
	function META:SetLowerLimit(...)
		lib.btTranslationalLimitMotor2_setLowerLimit(self.__ptr, ...)
	end
	function META:GetCurrentLimit(...)
		lib.btTranslationalLimitMotor2_getCurrentLimit(self.__ptr, ...)
	end
	function META:GetEquilibriumPoint(...)
		lib.btTranslationalLimitMotor2_getEquilibriumPoint(self.__ptr, ...)
	end
	function META:GetEnableSpring(...)
		lib.btTranslationalLimitMotor2_getEnableSpring(self.__ptr, ...)
	end
	function META:GetMaxMotorForce(...)
		lib.btTranslationalLimitMotor2_getMaxMotorForce(self.__ptr, ...)
	end
	function META:GetBounce(...)
		lib.btTranslationalLimitMotor2_getBounce(self.__ptr, ...)
	end
	function META:SetSpringDamping(...)
		lib.btTranslationalLimitMotor2_setSpringDamping(self.__ptr, ...)
	end
	function META:IsLimited(...)
		lib.btTranslationalLimitMotor2_isLimited(self.__ptr, ...)
	end
	function META:SetStopCFM(...)
		lib.btTranslationalLimitMotor2_setStopCFM(self.__ptr, ...)
	end
	function META:GetSpringDamping(...)
		lib.btTranslationalLimitMotor2_getSpringDamping(self.__ptr, ...)
	end
	function META:SetMotorERP(...)
		lib.btTranslationalLimitMotor2_setMotorERP(self.__ptr, ...)
	end
	function META:GetServoMotor(...)
		lib.btTranslationalLimitMotor2_getServoMotor(self.__ptr, ...)
	end
	function META:GetCurrentLinearDiff(...)
		lib.btTranslationalLimitMotor2_getCurrentLinearDiff(self.__ptr, ...)
	end
	function META:GetCurrentLimitErrorHi(...)
		lib.btTranslationalLimitMotor2_getCurrentLimitErrorHi(self.__ptr, ...)
	end
	function META:GetUpperLimit(...)
		lib.btTranslationalLimitMotor2_getUpperLimit(self.__ptr, ...)
	end
	function META:GetMotorCFM(...)
		lib.btTranslationalLimitMotor2_getMotorCFM(self.__ptr, ...)
	end
	function META:GetEnableMotor(...)
		lib.btTranslationalLimitMotor2_getEnableMotor(self.__ptr, ...)
	end
	function META:GetServoTarget(...)
		lib.btTranslationalLimitMotor2_getServoTarget(self.__ptr, ...)
	end
	function META:Delete(...)
		lib.btTranslationalLimitMotor2_delete(self.__ptr, ...)
	end
	function META:SetBounce(...)
		lib.btTranslationalLimitMotor2_setBounce(self.__ptr, ...)
	end
	function META:SetCurrentLinearDiff(...)
		lib.btTranslationalLimitMotor2_setCurrentLinearDiff(self.__ptr, ...)
	end
	function META:SetServoTarget(...)
		lib.btTranslationalLimitMotor2_setServoTarget(self.__ptr, ...)
	end
	function META:TestLimitValue(...)
		lib.btTranslationalLimitMotor2_testLimitValue(self.__ptr, ...)
	end
	function META:GetStopCFM(...)
		lib.btTranslationalLimitMotor2_getStopCFM(self.__ptr, ...)
	end
	function META:SetUpperLimit(...)
		lib.btTranslationalLimitMotor2_setUpperLimit(self.__ptr, ...)
	end
	function META:SetStopERP(...)
		lib.btTranslationalLimitMotor2_setStopERP(self.__ptr, ...)
	end
	function META:SetMotorCFM(...)
		lib.btTranslationalLimitMotor2_setMotorCFM(self.__ptr, ...)
	end
	function META:SetSpringStiffness(...)
		lib.btTranslationalLimitMotor2_setSpringStiffness(self.__ptr, ...)
	end
	function META:GetLowerLimit(...)
		lib.btTranslationalLimitMotor2_getLowerLimit(self.__ptr, ...)
	end
	function META:GetCurrentLimitError(...)
		lib.btTranslationalLimitMotor2_getCurrentLimitError(self.__ptr, ...)
	end
	function META:GetStopERP(...)
		lib.btTranslationalLimitMotor2_getStopERP(self.__ptr, ...)
	end
	function META:GetSpringStiffness(...)
		lib.btTranslationalLimitMotor2_getSpringStiffness(self.__ptr, ...)
	end
	function META:SetCurrentLimitError(...)
		lib.btTranslationalLimitMotor2_setCurrentLimitError(self.__ptr, ...)
	end
	function META:SetMaxMotorForce(...)
		lib.btTranslationalLimitMotor2_setMaxMotorForce(self.__ptr, ...)
	end
	function META:SetCurrentLimitErrorHi(...)
		lib.btTranslationalLimitMotor2_setCurrentLimitErrorHi(self.__ptr, ...)
	end
	function META:GetMotorERP(...)
		lib.btTranslationalLimitMotor2_getMotorERP(self.__ptr, ...)
	end
	function META:SetEquilibriumPoint(...)
		lib.btTranslationalLimitMotor2_setEquilibriumPoint(self.__ptr, ...)
	end
	function META:GetTargetVelocity(...)
		lib.btTranslationalLimitMotor2_getTargetVelocity(self.__ptr, ...)
	end
	function bullet.CreateTranslationalLimitMotor2(...)
		return setmetatable({__ptr = lib.btTranslationalLimitMotor2_new2(...)}, META)
	end
end
do -- CylinderShapeZ
	local META = {}
	META.__index = META
	function bullet.CreateCylinderShapeZ(...)
		return setmetatable({__ptr = lib.btCylinderShapeZ_new2(...)}, META)
	end
end
do -- TriangleShape
	local META = {}
	META.__index = META
	function META:GetVertexPtr(...)
		lib.btTriangleShape_getVertexPtr(self.__ptr, ...)
	end
	function META:CalcNormal(...)
		lib.btTriangleShape_calcNormal(self.__ptr, ...)
	end
	function META:GetPlaneEquation(...)
		lib.btTriangleShape_getPlaneEquation(self.__ptr, ...)
	end
	function META:GetVertices(...)
		lib.btTriangleShape_getVertices1(self.__ptr, ...)
	end
	function bullet.CreateTriangleShape(...)
		return setmetatable({__ptr = lib.btTriangleShape_new2(...)}, META)
	end
end
do -- RotationalLimitMotor
	local META = {}
	META.__index = META
	function META:SetTargetVelocity(...)
		lib.btRotationalLimitMotor_setTargetVelocity(self.__ptr, ...)
	end
	function META:GetAccumulatedImpulse(...)
		lib.btRotationalLimitMotor_getAccumulatedImpulse(self.__ptr, ...)
	end
	function META:GetLoLimit(...)
		lib.btRotationalLimitMotor_getLoLimit(self.__ptr, ...)
	end
	function META:SetCurrentLimitError(...)
		lib.btRotationalLimitMotor_setCurrentLimitError(self.__ptr, ...)
	end
	function META:SetLimitSoftness(...)
		lib.btRotationalLimitMotor_setLimitSoftness(self.__ptr, ...)
	end
	function META:SetCurrentPosition(...)
		lib.btRotationalLimitMotor_setCurrentPosition(self.__ptr, ...)
	end
	function META:SetMaxLimitForce(...)
		lib.btRotationalLimitMotor_setMaxLimitForce(self.__ptr, ...)
	end
	function META:GetMaxMotorForce(...)
		lib.btRotationalLimitMotor_getMaxMotorForce(self.__ptr, ...)
	end
	function META:GetBounce(...)
		lib.btRotationalLimitMotor_getBounce(self.__ptr, ...)
	end
	function META:GetLimitSoftness(...)
		lib.btRotationalLimitMotor_getLimitSoftness(self.__ptr, ...)
	end
	function META:SetNormalCFM(...)
		lib.btRotationalLimitMotor_setNormalCFM(self.__ptr, ...)
	end
	function META:GetDamping(...)
		lib.btRotationalLimitMotor_getDamping(self.__ptr, ...)
	end
	function META:IsLimited(...)
		lib.btRotationalLimitMotor_isLimited(self.__ptr, ...)
	end
	function META:SetCurrentLimit(...)
		lib.btRotationalLimitMotor_setCurrentLimit(self.__ptr, ...)
	end
	function META:SetStopCFM(...)
		lib.btRotationalLimitMotor_setStopCFM(self.__ptr, ...)
	end
	function META:SetDamping(...)
		lib.btRotationalLimitMotor_setDamping(self.__ptr, ...)
	end
	function META:GetTargetVelocity(...)
		lib.btRotationalLimitMotor_getTargetVelocity(self.__ptr, ...)
	end
	function META:SetAccumulatedImpulse(...)
		lib.btRotationalLimitMotor_setAccumulatedImpulse(self.__ptr, ...)
	end
	function META:GetStopERP(...)
		lib.btRotationalLimitMotor_getStopERP(self.__ptr, ...)
	end
	function META:Delete(...)
		lib.btRotationalLimitMotor_delete(self.__ptr, ...)
	end
	function META:GetCurrentPosition(...)
		lib.btRotationalLimitMotor_getCurrentPosition(self.__ptr, ...)
	end
	function META:GetMaxLimitForce(...)
		lib.btRotationalLimitMotor_getMaxLimitForce(self.__ptr, ...)
	end
	function META:SetLoLimit(...)
		lib.btRotationalLimitMotor_setLoLimit(self.__ptr, ...)
	end
	function META:TestLimitValue(...)
		lib.btRotationalLimitMotor_testLimitValue(self.__ptr, ...)
	end
	function META:SolveAngularLimits(...)
		lib.btRotationalLimitMotor_solveAngularLimits(self.__ptr, ...)
	end
	function META:SetEnableMotor(...)
		lib.btRotationalLimitMotor_setEnableMotor(self.__ptr, ...)
	end
	function META:GetCurrentLimitError(...)
		lib.btRotationalLimitMotor_getCurrentLimitError(self.__ptr, ...)
	end
	function META:GetStopCFM(...)
		lib.btRotationalLimitMotor_getStopCFM(self.__ptr, ...)
	end
	function META:GetHiLimit(...)
		lib.btRotationalLimitMotor_getHiLimit(self.__ptr, ...)
	end
	function META:GetNormalCFM(...)
		lib.btRotationalLimitMotor_getNormalCFM(self.__ptr, ...)
	end
	function META:SetStopERP(...)
		lib.btRotationalLimitMotor_setStopERP(self.__ptr, ...)
	end
	function META:SetBounce(...)
		lib.btRotationalLimitMotor_setBounce(self.__ptr, ...)
	end
	function META:SetMaxMotorForce(...)
		lib.btRotationalLimitMotor_setMaxMotorForce(self.__ptr, ...)
	end
	function META:SetHiLimit(...)
		lib.btRotationalLimitMotor_setHiLimit(self.__ptr, ...)
	end
	function META:NeedApplyTorques(...)
		lib.btRotationalLimitMotor_needApplyTorques(self.__ptr, ...)
	end
	function META:GetEnableMotor(...)
		lib.btRotationalLimitMotor_getEnableMotor(self.__ptr, ...)
	end
	function META:GetCurrentLimit(...)
		lib.btRotationalLimitMotor_getCurrentLimit(self.__ptr, ...)
	end
	function bullet.CreateRotationalLimitMotor(...)
		return setmetatable({__ptr = lib.btRotationalLimitMotor_new2(...)}, META)
	end
end
do -- CompoundShape
	local META = {}
	META.__index = META
	function META:UpdateChildTransform(...)
		lib.btCompoundShape_updateChildTransform(self.__ptr, ...)
	end
	function META:CreateAabbTreeFromChildren(...)
		lib.btCompoundShape_createAabbTreeFromChildren(self.__ptr, ...)
	end
	function META:RemoveChildShape(...)
		lib.btCompoundShape_removeChildShape(self.__ptr, ...)
	end
	function META:GetDynamicAabbTree(...)
		lib.btCompoundShape_getDynamicAabbTree(self.__ptr, ...)
	end
	function META:GetChildTransform(...)
		lib.btCompoundShape_getChildTransform(self.__ptr, ...)
	end
	function META:RemoveChildShapeByIndex(...)
		lib.btCompoundShape_removeChildShapeByIndex(self.__ptr, ...)
	end
	function META:GetChildList(...)
		lib.btCompoundShape_getChildList(self.__ptr, ...)
	end
	function META:RecalculateLocalAabb(...)
		lib.btCompoundShape_recalculateLocalAabb(self.__ptr, ...)
	end
	function META:GetUpdateRevision(...)
		lib.btCompoundShape_getUpdateRevision(self.__ptr, ...)
	end
	function META:GetNumChildShapes(...)
		lib.btCompoundShape_getNumChildShapes(self.__ptr, ...)
	end
	function META:GetChildShape(...)
		lib.btCompoundShape_getChildShape(self.__ptr, ...)
	end
	function META:CalculatePrincipalAxisTransform(...)
		lib.btCompoundShape_calculatePrincipalAxisTransform(self.__ptr, ...)
	end
	function META:AddChildShape(...)
		lib.btCompoundShape_addChildShape(self.__ptr, ...)
	end
	function bullet.CreateCompoundShape(...)
		return setmetatable({__ptr = lib.btCompoundShape_new2(...)}, META)
	end
end
do -- ConvexTriangleMeshShape
	local META = {}
	META.__index = META
	function META:GetMeshInterface(...)
		lib.btConvexTriangleMeshShape_getMeshInterface(self.__ptr, ...)
	end
	function META:CalculatePrincipalAxisTransform(...)
		lib.btConvexTriangleMeshShape_calculatePrincipalAxisTransform(self.__ptr, ...)
	end
	function bullet.CreateConvexTriangleMeshShape(...)
		return setmetatable({__ptr = lib.btConvexTriangleMeshShape_new2(...)}, META)
	end
end
do -- GImpactBvh
	local META = {}
	META.__index = META
	function META:GetNodeBound(...)
		lib.btGImpactBvh_getNodeBound(self.__ptr, ...)
	end
	function META:SetPrimitiveManager(...)
		lib.btGImpactBvh_setPrimitiveManager(self.__ptr, ...)
	end
	function META:BoxQuery(...)
		lib.btGImpactBvh_boxQuery(self.__ptr, ...)
	end
	function META:RayQuery(...)
		lib.btGImpactBvh_rayQuery(self.__ptr, ...)
	end
	function META:GetEscapeNodeIndex(...)
		lib.btGImpactBvh_getEscapeNodeIndex(self.__ptr, ...)
	end
	function META:HasHierarchy(...)
		lib.btGImpactBvh_hasHierarchy(self.__ptr, ...)
	end
	function META:IsLeafNode(...)
		lib.btGImpactBvh_isLeafNode(self.__ptr, ...)
	end
	function META:SetNodeBound(...)
		lib.btGImpactBvh_setNodeBound(self.__ptr, ...)
	end
	function META:GetNodeTriangle(...)
		lib.btGImpactBvh_getNodeTriangle(self.__ptr, ...)
	end
	function META:Update(...)
		lib.btGImpactBvh_update(self.__ptr, ...)
	end
	function META:GetNodeCount(...)
		lib.btGImpactBvh_getNodeCount(self.__ptr, ...)
	end
	function META:BuildSet(...)
		lib.btGImpactBvh_buildSet(self.__ptr, ...)
	end
	function META:GetPrimitiveManager(...)
		lib.btGImpactBvh_getPrimitiveManager(self.__ptr, ...)
	end
	function META:GetNodeData(...)
		lib.btGImpactBvh_getNodeData(self.__ptr, ...)
	end
	function META:GetLeftNode(...)
		lib.btGImpactBvh_getLeftNode(self.__ptr, ...)
	end
	function META:Delete(...)
		lib.btGImpactBvh_delete(self.__ptr, ...)
	end
	function META:IsTrimesh(...)
		lib.btGImpactBvh_isTrimesh(self.__ptr, ...)
	end
	function META:GetRightNode(...)
		lib.btGImpactBvh_getRightNode(self.__ptr, ...)
	end
	function META:BoxQueryTrans(...)
		lib.btGImpactBvh_boxQueryTrans(self.__ptr, ...)
	end
	function META:GetGlobalBox(...)
		lib.btGImpactBvh_getGlobalBox(self.__ptr, ...)
	end
	function bullet.CreateGImpactBvh(...)
		return setmetatable({__ptr = lib.btGImpactBvh_new2(...)}, META)
	end
end
do -- DefaultCollisionConfiguration
	local META = {}
	META.__index = META
	function META:GetSimplexSolver(...)
		lib.btDefaultCollisionConfiguration_getSimplexSolver(self.__ptr, ...)
	end
	function META:SetConvexConvexMultipointIterations(...)
		lib.btDefaultCollisionConfiguration_setConvexConvexMultipointIterations(self.__ptr, ...)
	end
	function META:SetPlaneConvexMultipointIterations(...)
		lib.btDefaultCollisionConfiguration_setPlaneConvexMultipointIterations(self.__ptr, ...)
	end
	function bullet.CreateDefaultCollisionConfiguration(...)
		return setmetatable({__ptr = lib.btDefaultCollisionConfiguration_new2(...)}, META)
	end
end
do -- TranslationalLimitMotor
	local META = {}
	META.__index = META
	function META:SetTargetVelocity(...)
		lib.btTranslationalLimitMotor_setTargetVelocity(self.__ptr, ...)
	end
	function META:GetAccumulatedImpulse(...)
		lib.btTranslationalLimitMotor_getAccumulatedImpulse(self.__ptr, ...)
	end
	function META:SetLowerLimit(...)
		lib.btTranslationalLimitMotor_setLowerLimit(self.__ptr, ...)
	end
	function META:GetCurrentLimit(...)
		lib.btTranslationalLimitMotor_getCurrentLimit(self.__ptr, ...)
	end
	function META:SetLimitSoftness(...)
		lib.btTranslationalLimitMotor_setLimitSoftness(self.__ptr, ...)
	end
	function META:SetRestitution(...)
		lib.btTranslationalLimitMotor_setRestitution(self.__ptr, ...)
	end
	function META:GetMaxMotorForce(...)
		lib.btTranslationalLimitMotor_getMaxMotorForce(self.__ptr, ...)
	end
	function META:GetLimitSoftness(...)
		lib.btTranslationalLimitMotor_getLimitSoftness(self.__ptr, ...)
	end
	function META:SetNormalCFM(...)
		lib.btTranslationalLimitMotor_setNormalCFM(self.__ptr, ...)
	end
	function META:GetDamping(...)
		lib.btTranslationalLimitMotor_getDamping(self.__ptr, ...)
	end
	function META:IsLimited(...)
		lib.btTranslationalLimitMotor_isLimited(self.__ptr, ...)
	end
	function META:SetStopCFM(...)
		lib.btTranslationalLimitMotor_setStopCFM(self.__ptr, ...)
	end
	function META:SetDamping(...)
		lib.btTranslationalLimitMotor_setDamping(self.__ptr, ...)
	end
	function META:GetCurrentLinearDiff(...)
		lib.btTranslationalLimitMotor_getCurrentLinearDiff(self.__ptr, ...)
	end
	function META:GetTargetVelocity(...)
		lib.btTranslationalLimitMotor_getTargetVelocity(self.__ptr, ...)
	end
	function META:GetUpperLimit(...)
		lib.btTranslationalLimitMotor_getUpperLimit(self.__ptr, ...)
	end
	function META:GetEnableMotor(...)
		lib.btTranslationalLimitMotor_getEnableMotor(self.__ptr, ...)
	end
	function META:GetStopERP(...)
		lib.btTranslationalLimitMotor_getStopERP(self.__ptr, ...)
	end
	function META:NeedApplyForce(...)
		lib.btTranslationalLimitMotor_needApplyForce(self.__ptr, ...)
	end
	function META:GetCurrentLimitError(...)
		lib.btTranslationalLimitMotor_getCurrentLimitError(self.__ptr, ...)
	end
	function META:GetStopCFM(...)
		lib.btTranslationalLimitMotor_getStopCFM(self.__ptr, ...)
	end
	function META:Delete(...)
		lib.btTranslationalLimitMotor_delete(self.__ptr, ...)
	end
	function META:GetLowerLimit(...)
		lib.btTranslationalLimitMotor_getLowerLimit(self.__ptr, ...)
	end
	function META:GetRestitution(...)
		lib.btTranslationalLimitMotor_getRestitution(self.__ptr, ...)
	end
	function META:SetAccumulatedImpulse(...)
		lib.btTranslationalLimitMotor_setAccumulatedImpulse(self.__ptr, ...)
	end
	function META:GetNormalCFM(...)
		lib.btTranslationalLimitMotor_getNormalCFM(self.__ptr, ...)
	end
	function META:SetUpperLimit(...)
		lib.btTranslationalLimitMotor_setUpperLimit(self.__ptr, ...)
	end
	function META:SetMaxMotorForce(...)
		lib.btTranslationalLimitMotor_setMaxMotorForce(self.__ptr, ...)
	end
	function META:TestLimitValue(...)
		lib.btTranslationalLimitMotor_testLimitValue(self.__ptr, ...)
	end
	function META:SetCurrentLinearDiff(...)
		lib.btTranslationalLimitMotor_setCurrentLinearDiff(self.__ptr, ...)
	end
	function META:SolveLinearAxis(...)
		lib.btTranslationalLimitMotor_solveLinearAxis(self.__ptr, ...)
	end
	function META:SetCurrentLimitError(...)
		lib.btTranslationalLimitMotor_setCurrentLimitError(self.__ptr, ...)
	end
	function META:SetStopERP(...)
		lib.btTranslationalLimitMotor_setStopERP(self.__ptr, ...)
	end
	function bullet.CreateTranslationalLimitMotor(...)
		return setmetatable({__ptr = lib.btTranslationalLimitMotor_new2(...)}, META)
	end
end
do -- DefaultSerializer
	local META = {}
	META.__index = META
	function META:WriteHeader(...)
		lib.btDefaultSerializer_writeHeader(self.__ptr, ...)
	end
	function META:InternalAlloc(...)
		lib.btDefaultSerializer_internalAlloc(self.__ptr, ...)
	end
	function bullet.CreateDefaultSerializer(...)
		return setmetatable({__ptr = lib.btDefaultSerializer_new2(...)}, META)
	end
end
do -- HingeConstraint
	local META = {}
	META.__index = META
	function META:GetMaxMotorImpulse(...)
		lib.btHingeConstraint_getMaxMotorImpulse(self.__ptr, ...)
	end
	function META:GetFrameOffsetA(...)
		lib.btHingeConstraint_getFrameOffsetA(self.__ptr, ...)
	end
	function META:TestLimit(...)
		lib.btHingeConstraint_testLimit(self.__ptr, ...)
	end
	function META:GetUpperLimit(...)
		lib.btHingeConstraint_getUpperLimit(self.__ptr, ...)
	end
	function META:GetInfo1NonVirtual(...)
		lib.btHingeConstraint_getInfo1NonVirtual(self.__ptr, ...)
	end
	function META:HasLimit(...)
		lib.btHingeConstraint_hasLimit(self.__ptr, ...)
	end
	function META:GetMotorTargetVelosity(...)
		lib.btHingeConstraint_getMotorTargetVelosity(self.__ptr, ...)
	end
	function META:GetAngularOnly(...)
		lib.btHingeConstraint_getAngularOnly(self.__ptr, ...)
	end
	function META:UpdateRHS(...)
		lib.btHingeConstraint_updateRHS(self.__ptr, ...)
	end
	function META:SetUseFrameOffset(...)
		lib.btHingeConstraint_setUseFrameOffset(self.__ptr, ...)
	end
	function META:GetInfo2NonVirtual(...)
		lib.btHingeConstraint_getInfo2NonVirtual(self.__ptr, ...)
	end
	function META:GetInfo2InternalUsingFrameOffset(...)
		lib.btHingeConstraint_getInfo2InternalUsingFrameOffset(self.__ptr, ...)
	end
	function META:GetLimitSign(...)
		lib.btHingeConstraint_getLimitSign(self.__ptr, ...)
	end
	function META:GetSolveLimit(...)
		lib.btHingeConstraint_getSolveLimit(self.__ptr, ...)
	end
	function META:GetHingeAngle(...)
		lib.btHingeConstraint_getHingeAngle(self.__ptr, ...)
	end
	function META:GetFrameOffsetB(...)
		lib.btHingeConstraint_getFrameOffsetB(self.__ptr, ...)
	end
	function META:SetLimit(...)
		lib.btHingeConstraint_setLimit(self.__ptr, ...)
	end
	function META:SetAxis(...)
		lib.btHingeConstraint_setAxis(self.__ptr, ...)
	end
	function META:SetMaxMotorImpulse(...)
		lib.btHingeConstraint_setMaxMotorImpulse(self.__ptr, ...)
	end
	function META:SetAngularOnly(...)
		lib.btHingeConstraint_setAngularOnly(self.__ptr, ...)
	end
	function META:SetFrames(...)
		lib.btHingeConstraint_setFrames(self.__ptr, ...)
	end
	function META:EnableMotor(...)
		lib.btHingeConstraint_enableMotor(self.__ptr, ...)
	end
	function META:GetEnableAngularMotor(...)
		lib.btHingeConstraint_getEnableAngularMotor(self.__ptr, ...)
	end
	function META:GetLowerLimit(...)
		lib.btHingeConstraint_getLowerLimit(self.__ptr, ...)
	end
	function META:GetInfo2Internal(...)
		lib.btHingeConstraint_getInfo2Internal(self.__ptr, ...)
	end
	function META:GetBFrame(...)
		lib.btHingeConstraint_getBFrame(self.__ptr, ...)
	end
	function META:GetUseFrameOffset(...)
		lib.btHingeConstraint_getUseFrameOffset(self.__ptr, ...)
	end
	function META:EnableAngularMotor(...)
		lib.btHingeConstraint_enableAngularMotor(self.__ptr, ...)
	end
	function META:GetAFrame(...)
		lib.btHingeConstraint_getAFrame(self.__ptr, ...)
	end
	function META:SetMotorTarget(...)
		lib.btHingeConstraint_setMotorTarget(self.__ptr, ...)
	end
	function bullet.CreateHingeConstraint(...)
		return setmetatable({__ptr = lib.btHingeConstraint_new2(...)}, META)
	end
end
do -- CollisionAlgorithmConstructionInfo
	local META = {}
	META.__index = META
	function META:GetManifold(...)
		lib.btCollisionAlgorithmConstructionInfo_getManifold(self.__ptr, ...)
	end
	function META:SetDispatcher(...)
		lib.btCollisionAlgorithmConstructionInfo_setDispatcher1(self.__ptr, ...)
	end
	function META:SetManifold(...)
		lib.btCollisionAlgorithmConstructionInfo_setManifold(self.__ptr, ...)
	end
	function META:GetDispatcher(...)
		lib.btCollisionAlgorithmConstructionInfo_getDispatcher1(self.__ptr, ...)
	end
	function META:Delete(...)
		lib.btCollisionAlgorithmConstructionInfo_delete(self.__ptr, ...)
	end
	function bullet.CreateCollisionAlgorithmConstructionInfo(...)
		return setmetatable({__ptr = lib.btCollisionAlgorithmConstructionInfo_new2(...)}, META)
	end
end
do -- HingeAccumulatedAngleConstraint
	local META = {}
	META.__index = META
	function META:SetAccumulatedHingeAngle(...)
		lib.btHingeAccumulatedAngleConstraint_setAccumulatedHingeAngle(self.__ptr, ...)
	end
	function META:GetAccumulatedHingeAngle(...)
		lib.btHingeAccumulatedAngleConstraint_getAccumulatedHingeAngle(self.__ptr, ...)
	end
	function bullet.CreateHingeAccumulatedAngleConstraint(...)
		return setmetatable({__ptr = lib.btHingeAccumulatedAngleConstraint_new2(...)}, META)
	end
end
do -- GImpactQuantizedBvh
	local META = {}
	META.__index = META
	function META:GetNodeBound(...)
		lib.btGImpactQuantizedBvh_getNodeBound(self.__ptr, ...)
	end
	function META:SetPrimitiveManager(...)
		lib.btGImpactQuantizedBvh_setPrimitiveManager(self.__ptr, ...)
	end
	function META:BoxQuery(...)
		lib.btGImpactQuantizedBvh_boxQuery(self.__ptr, ...)
	end
	function META:RayQuery(...)
		lib.btGImpactQuantizedBvh_rayQuery(self.__ptr, ...)
	end
	function META:GetEscapeNodeIndex(...)
		lib.btGImpactQuantizedBvh_getEscapeNodeIndex(self.__ptr, ...)
	end
	function META:HasHierarchy(...)
		lib.btGImpactQuantizedBvh_hasHierarchy(self.__ptr, ...)
	end
	function META:IsLeafNode(...)
		lib.btGImpactQuantizedBvh_isLeafNode(self.__ptr, ...)
	end
	function META:SetNodeBound(...)
		lib.btGImpactQuantizedBvh_setNodeBound(self.__ptr, ...)
	end
	function META:GetNodeTriangle(...)
		lib.btGImpactQuantizedBvh_getNodeTriangle(self.__ptr, ...)
	end
	function META:Update(...)
		lib.btGImpactQuantizedBvh_update(self.__ptr, ...)
	end
	function META:GetNodeCount(...)
		lib.btGImpactQuantizedBvh_getNodeCount(self.__ptr, ...)
	end
	function META:BuildSet(...)
		lib.btGImpactQuantizedBvh_buildSet(self.__ptr, ...)
	end
	function META:GetPrimitiveManager(...)
		lib.btGImpactQuantizedBvh_getPrimitiveManager(self.__ptr, ...)
	end
	function META:GetNodeData(...)
		lib.btGImpactQuantizedBvh_getNodeData(self.__ptr, ...)
	end
	function META:GetLeftNode(...)
		lib.btGImpactQuantizedBvh_getLeftNode(self.__ptr, ...)
	end
	function META:Delete(...)
		lib.btGImpactQuantizedBvh_delete(self.__ptr, ...)
	end
	function META:IsTrimesh(...)
		lib.btGImpactQuantizedBvh_isTrimesh(self.__ptr, ...)
	end
	function META:GetRightNode(...)
		lib.btGImpactQuantizedBvh_getRightNode(self.__ptr, ...)
	end
	function META:BoxQueryTrans(...)
		lib.btGImpactQuantizedBvh_boxQueryTrans(self.__ptr, ...)
	end
	function META:GetGlobalBox(...)
		lib.btGImpactQuantizedBvh_getGlobalBox(self.__ptr, ...)
	end
	function bullet.CreateGImpactQuantizedBvh(...)
		return setmetatable({__ptr = lib.btGImpactQuantizedBvh_new2(...)}, META)
	end
end
do -- SoftSoftCollisionAlgorithm
	local META = {}
	META.__index = META
	function bullet.CreateSoftSoftCollisionAlgorithm(...)
		return setmetatable({__ptr = lib.btSoftSoftCollisionAlgorithm_new2(...)}, META)
	end
end
do -- BroadphaseProxy
	local META = {}
	META.__index = META
	function META:SetMultiSapParentProxy(...)
		lib.btBroadphaseProxy_setMultiSapParentProxy(self.__ptr, ...)
	end
	function META:GetUid(...)
		lib.btBroadphaseProxy_getUid(self.__ptr, ...)
	end
	function META:IsConvex2d(...)
		lib.btBroadphaseProxy_isConvex2d(self.__ptr, ...)
	end
	function META:IsConvex(...)
		lib.btBroadphaseProxy_isConvex(self.__ptr, ...)
	end
	function META:IsSoftBody(...)
		lib.btBroadphaseProxy_isSoftBody(self.__ptr, ...)
	end
	function META:SetCollisionFilterGroup(...)
		lib.btBroadphaseProxy_setCollisionFilterGroup(self.__ptr, ...)
	end
	function META:GetMultiSapParentProxy(...)
		lib.btBroadphaseProxy_getMultiSapParentProxy(self.__ptr, ...)
	end
	function META:IsCompound(...)
		lib.btBroadphaseProxy_isCompound(self.__ptr, ...)
	end
	function META:Delete(...)
		lib.btBroadphaseProxy_delete(self.__ptr, ...)
	end
	function META:IsConcave(...)
		lib.btBroadphaseProxy_isConcave(self.__ptr, ...)
	end
	function META:SetCollisionFilterMask(...)
		lib.btBroadphaseProxy_setCollisionFilterMask(self.__ptr, ...)
	end
	function META:SetAabbMin(...)
		lib.btBroadphaseProxy_setAabbMin(self.__ptr, ...)
	end
	function META:IsInfinite(...)
		lib.btBroadphaseProxy_isInfinite(self.__ptr, ...)
	end
	function META:SetClientObject(...)
		lib.btBroadphaseProxy_setClientObject(self.__ptr, ...)
	end
	function META:GetAabbMax(...)
		lib.btBroadphaseProxy_getAabbMax(self.__ptr, ...)
	end
	function META:SetAabbMax(...)
		lib.btBroadphaseProxy_setAabbMax(self.__ptr, ...)
	end
	function META:IsNonMoving(...)
		lib.btBroadphaseProxy_isNonMoving(self.__ptr, ...)
	end
	function META:SetUniqueId(...)
		lib.btBroadphaseProxy_setUniqueId(self.__ptr, ...)
	end
	function META:IsPolyhedral(...)
		lib.btBroadphaseProxy_isPolyhedral(self.__ptr, ...)
	end
	function META:GetUniqueId(...)
		lib.btBroadphaseProxy_getUniqueId(self.__ptr, ...)
	end
	function META:GetCollisionFilterMask(...)
		lib.btBroadphaseProxy_getCollisionFilterMask(self.__ptr, ...)
	end
	function META:GetCollisionFilterGroup(...)
		lib.btBroadphaseProxy_getCollisionFilterGroup(self.__ptr, ...)
	end
	function META:GetClientObject(...)
		lib.btBroadphaseProxy_getClientObject(self.__ptr, ...)
	end
	function META:GetAabbMin(...)
		lib.btBroadphaseProxy_getAabbMin(self.__ptr, ...)
	end
	function bullet.CreateBroadphaseProxy(...)
		return setmetatable({__ptr = lib.btBroadphaseProxy_new2(...)}, META)
	end
end
do -- DefaultMotionState
	local META = {}
	META.__index = META
	function META:GetUserPointer(...)
		lib.btDefaultMotionState_getUserPointer(self.__ptr, ...)
	end
	function META:SetGraphicsWorldTrans(...)
		lib.btDefaultMotionState_setGraphicsWorldTrans(self.__ptr, ...)
	end
	function META:SetStartWorldTrans(...)
		lib.btDefaultMotionState_setStartWorldTrans(self.__ptr, ...)
	end
	function META:GetCenterOfMassOffset(...)
		lib.btDefaultMotionState_getCenterOfMassOffset(self.__ptr, ...)
	end
	function META:SetUserPointer(...)
		lib.btDefaultMotionState_setUserPointer(self.__ptr, ...)
	end
	function META:SetCenterOfMassOffset(...)
		lib.btDefaultMotionState_setCenterOfMassOffset(self.__ptr, ...)
	end
	function META:GetGraphicsWorldTrans(...)
		lib.btDefaultMotionState_getGraphicsWorldTrans(self.__ptr, ...)
	end
	function META:GetStartWorldTrans(...)
		lib.btDefaultMotionState_getStartWorldTrans(self.__ptr, ...)
	end
	function bullet.CreateDefaultMotionState(...)
		return setmetatable({__ptr = lib.btDefaultMotionState_new2(...)}, META)
	end
end
do -- GearConstraint
	local META = {}
	META.__index = META
	function META:SetAxisA(...)
		lib.btGearConstraint_setAxisA(self.__ptr, ...)
	end
	function META:GetRatio(...)
		lib.btGearConstraint_getRatio(self.__ptr, ...)
	end
	function META:GetAxisA(...)
		lib.btGearConstraint_getAxisA(self.__ptr, ...)
	end
	function META:SetRatio(...)
		lib.btGearConstraint_setRatio(self.__ptr, ...)
	end
	function META:GetAxisB(...)
		lib.btGearConstraint_getAxisB(self.__ptr, ...)
	end
	function META:SetAxisB(...)
		lib.btGearConstraint_setAxisB(self.__ptr, ...)
	end
	function bullet.CreateGearConstraint(...)
		return setmetatable({__ptr = lib.btGearConstraint_new2(...)}, META)
	end
end
do -- AxisSweep3
	local META = {}
	META.__index = META
	function META:AddHandle(...)
		lib.btAxisSweep3_addHandle(self.__ptr, ...)
	end
	function META:ProcessAllOverlappingPairs(...)
		lib.btAxisSweep3_processAllOverlappingPairs(self.__ptr, ...)
	end
	function META:TestAabbOverlap(...)
		lib.btAxisSweep3_testAabbOverlap(self.__ptr, ...)
	end
	function META:GetNumHandles(...)
		lib.btAxisSweep3_getNumHandles(self.__ptr, ...)
	end
	function META:UnQuantize(...)
		lib.btAxisSweep3_unQuantize(self.__ptr, ...)
	end
	function META:RemoveHandle(...)
		lib.btAxisSweep3_removeHandle(self.__ptr, ...)
	end
	function META:SetOverlappingPairUserCallback(...)
		lib.btAxisSweep3_setOverlappingPairUserCallback(self.__ptr, ...)
	end
	function META:GetHandle(...)
		lib.btAxisSweep3_getHandle(self.__ptr, ...)
	end
	function META:Quantize(...)
		lib.btAxisSweep3_quantize(self.__ptr, ...)
	end
	function META:UpdateHandle(...)
		lib.btAxisSweep3_updateHandle(self.__ptr, ...)
	end
	function META:GetOverlappingPairUserCallback(...)
		lib.btAxisSweep3_getOverlappingPairUserCallback(self.__ptr, ...)
	end
	function bullet.CreateAxisSweep3(...)
		return setmetatable({__ptr = lib.btAxisSweep3_new2(...)}, META)
	end
end
do -- MultiSphereShape
	local META = {}
	META.__index = META
	function META:GetSphereCount(...)
		lib.btMultiSphereShape_getSphereCount(self.__ptr, ...)
	end
	function META:GetSphereRadius(...)
		lib.btMultiSphereShape_getSphereRadius(self.__ptr, ...)
	end
	function META:GetSpherePosition(...)
		lib.btMultiSphereShape_getSpherePosition(self.__ptr, ...)
	end
	function bullet.CreateMultiSphereShape(...)
		return setmetatable({__ptr = lib.btMultiSphereShape_new2(...)}, META)
	end
end
do -- KinematicCharacterController
	local META = {}
	META.__index = META
	function META:SetUpAxis(...)
		lib.btKinematicCharacterController_setUpAxis(self.__ptr, ...)
	end
	function META:SetUseGhostSweepTest(...)
		lib.btKinematicCharacterController_setUseGhostSweepTest(self.__ptr, ...)
	end
	function META:SetFallSpeed(...)
		lib.btKinematicCharacterController_setFallSpeed(self.__ptr, ...)
	end
	function META:SetMaxSlope(...)
		lib.btKinematicCharacterController_setMaxSlope(self.__ptr, ...)
	end
	function META:GetGhostObject(...)
		lib.btKinematicCharacterController_getGhostObject(self.__ptr, ...)
	end
	function META:GetGravity(...)
		lib.btKinematicCharacterController_getGravity(self.__ptr, ...)
	end
	function META:GetMaxSlope(...)
		lib.btKinematicCharacterController_getMaxSlope(self.__ptr, ...)
	end
	function META:SetMaxJumpHeight(...)
		lib.btKinematicCharacterController_setMaxJumpHeight(self.__ptr, ...)
	end
	function META:SetJumpSpeed(...)
		lib.btKinematicCharacterController_setJumpSpeed(self.__ptr, ...)
	end
	function META:SetGravity(...)
		lib.btKinematicCharacterController_setGravity(self.__ptr, ...)
	end
	function bullet.CreateKinematicCharacterController(...)
		return setmetatable({__ptr = lib.btKinematicCharacterController_new2(...)}, META)
	end
end
do -- MultiBodyPoint2Point
	local META = {}
	META.__index = META
	function META:SetPivotInB(...)
		lib.btMultiBodyPoint2Point_setPivotInB(self.__ptr, ...)
	end
	function META:GetPivotInB(...)
		lib.btMultiBodyPoint2Point_getPivotInB(self.__ptr, ...)
	end
	function bullet.CreateMultiBodyPoint2Point(...)
		return setmetatable({__ptr = lib.btMultiBodyPoint2Point_new2(...)}, META)
	end
end
do -- PersistentManifold
	local META = {}
	META.__index = META
	function META:ClearUserCache(...)
		lib.btPersistentManifold_clearUserCache(self.__ptr, ...)
	end
	function META:ReplaceContactPoint(...)
		lib.btPersistentManifold_replaceContactPoint(self.__ptr, ...)
	end
	function META:RemoveContactPoint(...)
		lib.btPersistentManifold_removeContactPoint(self.__ptr, ...)
	end
	function META:GetContactPoint(...)
		lib.btPersistentManifold_getContactPoint(self.__ptr, ...)
	end
	function META:AddManifoldPoint(...)
		lib.btPersistentManifold_addManifoldPoint(self.__ptr, ...)
	end
	function META:GetBody(...)
		lib.btPersistentManifold_getBody0(self.__ptr, ...)
	end
	function META:GetCacheEntry(...)
		lib.btPersistentManifold_getCacheEntry(self.__ptr, ...)
	end
	function META:GetContactProcessingThreshold(...)
		lib.btPersistentManifold_getContactProcessingThreshold(self.__ptr, ...)
	end
	function META:GetCompanionIdA(...)
		lib.btPersistentManifold_getCompanionIdA(self.__ptr, ...)
	end
	function META:GetNumContacts(...)
		lib.btPersistentManifold_getNumContacts(self.__ptr, ...)
	end
	function META:ValidContactDistance(...)
		lib.btPersistentManifold_validContactDistance(self.__ptr, ...)
	end
	function META:GetIndex1a(...)
		lib.btPersistentManifold_getIndex1a(self.__ptr, ...)
	end
	function META:SetIndex1a(...)
		lib.btPersistentManifold_setIndex1a(self.__ptr, ...)
	end
	function META:ClearManifold(...)
		lib.btPersistentManifold_clearManifold(self.__ptr, ...)
	end
	function META:SetBodies(...)
		lib.btPersistentManifold_setBodies(self.__ptr, ...)
	end
	function META:GetContactBreakingThreshold(...)
		lib.btPersistentManifold_getContactBreakingThreshold(self.__ptr, ...)
	end
	function META:SetCompanionIdB(...)
		lib.btPersistentManifold_setCompanionIdB(self.__ptr, ...)
	end
	function META:SetCompanionIdA(...)
		lib.btPersistentManifold_setCompanionIdA(self.__ptr, ...)
	end
	function META:SetContactProcessingThreshold(...)
		lib.btPersistentManifold_setContactProcessingThreshold(self.__ptr, ...)
	end
	function META:SetContactBreakingThreshold(...)
		lib.btPersistentManifold_setContactBreakingThreshold(self.__ptr, ...)
	end
	function META:RefreshContactPoints(...)
		lib.btPersistentManifold_refreshContactPoints(self.__ptr, ...)
	end
	function META:SetNumContacts(...)
		lib.btPersistentManifold_setNumContacts(self.__ptr, ...)
	end
	function META:GetCompanionIdB(...)
		lib.btPersistentManifold_getCompanionIdB(self.__ptr, ...)
	end
	function bullet.CreatePersistentManifold(...)
		return setmetatable({__ptr = lib.btPersistentManifold_new2(...)}, META)
	end
end
do -- ConvexPointCloudShape
	local META = {}
	META.__index = META
	function META:SetPoints(...)
		lib.btConvexPointCloudShape_setPoints(self.__ptr, ...)
	end
	function META:GetUnscaledPoints(...)
		lib.btConvexPointCloudShape_getUnscaledPoints(self.__ptr, ...)
	end
	function META:GetNumPoints(...)
		lib.btConvexPointCloudShape_getNumPoints(self.__ptr, ...)
	end
	function META:GetScaledPoint(...)
		lib.btConvexPointCloudShape_getScaledPoint(self.__ptr, ...)
	end
	function bullet.CreateConvexPointCloudShape(...)
		return setmetatable({__ptr = lib.btConvexPointCloudShape_new2(...)}, META)
	end
end
return bullet